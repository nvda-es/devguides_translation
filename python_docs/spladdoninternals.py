# -*- coding: utf-8 -*-
documentation = [
_(u"""# NVDA Add-on internals: StationPlaylist Studio"""),
"",_(u"""Author: Joseph Lee"""),
"",_(u"""Based on StationPlaylist Studio Add-on for NvDA 18.02"""),
"",_(u"""## Introduction"""),
"",_(u"""If you are a radio broadcaster, you might be accustomed to activities involved when producing a show. This may include playlist selection, scheduling break notes, responding to requests, monitoring listener count and encoding status and so on. To assist a broadcaster, a broadcast automation program is used, and one of the popular apps is called StationPlaylist Studio."""),
"",_(u"""In NVDA Add-on Internals: StationPlaylist Studio, we'll learn about what Studio is and how the NVDA add-on works. You don't have to install or use the NVDA add-on to understand the ins and outs of this powerful add-on (using the add-on might help you better appreciate the defth of this material; for fuller experience, it is handy to have the add-on source code in front of you as you navigate this article). So let's get started by learning more about SPL Studio."""),
"",_(u"""### Introducing StationPlaylist Studio and the NVDA add-on"""),
"",_(u"""[StationPlaylist Studio](www.stationplaylist.com) is a broadcast automation software that helps broadcasters schedule trakcs, play jingles and more. It includes support for break notes, hourly playlist, track tagging and comes with tools to manage track playback such as setting track intros. In studio 5.00 and later, it includes its own stream encoder."""),
"",_(u"""Is Studio accessible? Surprisingly, yes. It is possible to use Studio features without using screen reader scripts and add-ons. However, there are times when a broadcaster would use scripts, such as announcing status changes, monitoring track intros and endings, enhanced support for encoders and so on, and NVDA add-on for StationPlaylist Studio (usually refered to as SPL) accomplishes this well."""),
"",_(u"""### Studio add-on: a history"""),
"",_(u"""In 2011, Geoff Shang, a seasoned blind broadcaster, started working on SPL Studio add-on. This early version (numbered 0.01) was developed to let NVDA announce various status changes such as automation toggle and so on. This initial version, co-developed by James Teh (one of the lead developers of NVDA screen reader) was considered a quick project, and further development ceased until 2013."""),
"",_(u"""In 2013, I (Joseph Lee) received several emails regarding NVDA's support for SPL Studio with a request for someone to write an add-on for it. As I was still new to add-on development then (this was after I developed Control Usage Assistant and GoldWave), I decided to take on this challenge in order to learn more Python and to practice what I learned in computer science labs at UC Riverside. I first downloaded the existing add-on (0.01) and installed Studio 5.01 on my computer to learn more about this program and to gather suggestions from SPL users. After little over a month of development and preview releases, I released Studio add-on 1.0 in January 2014."""),
"",_(u"""Most of the early versions (1.x, 2.x, 3.x, released throughout 2014) were mostly quick projects that bridged the gap between NVDA and other screen readers (Brian Hartgen's JAWS scripts were my inspiration and have studied documentation for Jeff Bishop's Window-Eyes scripts). These early versions, supporting Studio 4.33 and later, were also used to fix bugs encountered by Studio users - for instance, a broadcaster posted  a YouTube video explaining how NVDA was not reading edit fields, which was fixed early on. Later releases (4.x, 5.x, 6.x, released throughout 2015), further bridged the gap with other screen readers and introduced unique features (for instance, add-on 5.0 introduced a configuration dialog, and 6.0 introduced concept of a broadcast profile). In late 2016, seeing that some of my add-ons were using year.month scheme for versioning, I decided to switch SPL to follow this model after receiving comments from the NVDA community. As of time of writing, add-on 17.06 just hit the air."""),
"",_(u"""Highlights of past major releases and subsequent maintenance releases include:"""),
"",_(u"""* 1.x: Initial release, added end of track alarm and other features."""),
_(u"""* 2.x: Track Finder and better routines to recognize Studio versions."""),
_(u"""* 3.x: first long-term support (LTS) release, Cart Explorer, support for SAM Encoder and no need to stay on the encoder window during connection attempts. This was the last version to support Studio 4.33."""),
_(u"""* 4.x: Library scan, support for SPL encoder and studio 5.10."""),
_(u"""* 5.x: Track Dial, dedicated configuration dialog."""),
_(u"""* 6.x: Broadcast profiles, metadata streaming, column search and announcement reordering."""),
_(u"""* 7.x: second LTS release, add-on updates, time-based profile switching, Track Columns Explorer and others. This is the last version to support Studio 5.01. Renamed to 15.x in late 2016."""),
_(u"""* 16.10 (formerly 8.0): Columns explorer for Track Tool, selective data resets."""),
_(u"""* 17.04 (formerly 9.0: vertical column navigation, playlist snapshots, support for Studio 5.20."""),
_(u"""* 17.08 (10.0: listener request notification, column header announcement suppression. This is the last major version, with subsequent versions using continuous delivery."""),
_(u"""* 17.12: end of support for old Windows releases, add-on settings reorganization, extension points."""),
"",_(u"""Throughout this article, you'll get a chance to see how the add-on works, design philosophy and how the add-on is being developed, with glimpses into the past and future. My hope is that this add-on internals article would be a valuable reference for users and developers - for users to see the inner workings of this add-on, and for developers to use this add-on as an example of how an add-on is planned, implemented, tested, released and maintained."""),
"",_(u"""To download the add-on, go to http://addons.nvda-project.org/addons/StationPlaylist.en.html."""),
"",_(u"""## Design, code layout, layer sets and importance of Studio API and Studio window handle"""),
"",_(u"""So far, we talked about how the add-on was conceived and read about its history. Starting with this section, we'll tour the real internals of this add-on, starting with overall design and a few important notes. But before we get into that, there are some things we need to go over such as programming background, user experience and a few definitions."""),
"",_(u"""### A place to start: reader questions and definitions"""),
"",_(u"""I'm sure some readers might ask, \"doesn't writing articles on software internals require programming knowledge?\" Yes and no. Yes, as you may need some basic exposure to programming such as what a variable is, conditional execution and so forth. On the flip side, you don't have to be a programmer to write about internal workings of an add-on (the basic requirement is passion for teaching and a hope for users to learn something new). Same could be said about reading this article: you may need some exposure to programming, but you don't have to be a programmer to follow along."""),
"",_(u"""Another question might be, \"will this article teach me all there is to it when writing an add-on of my own?\" Yes and no. Yes, as you'll learn how add-on writers think when it comes to taking care of their add-ons and get a glimpse into add-on development processes. On the other side of the coin is scope of this article - this article does not serve as a definitive guide on add-on writing (there are documentation, linked at the end of this article that'll give you some basic overview). If you are familiar with add-on development and/or NVDA screen reader development and source code, you'll have slightly easier time understanding this article. I tried my best to make it easy for users to understand (although I do have to include some technical details)."""),
"",_(u"""Some definitions:"""),
"",_(u"""* Add-on: An add-on is a module for a program that adds additional features or changes the behavior of a program (3)."""),
_(u"""* API: Application Programming Interface, a set of specifications for programmers for using services offered by a program such as modules, functions and documentation (4). One of the most well-known API's is Python and its documentation (5)."""),
"",_(u"""With some basics out of the way, let's dive into SPL add-on internals (you should download the add-on source code, which can be found at https://github.com/josephsl/stationplaylist)."""),
"",_(u"""### Overall design and source code layout"""),
"",_(u"""StationPlaylist Studio add-on for NVDA consists of three app modules and a global plugin. Because Studio comes with Track Tool for managing tracks, the add-on includes an app module for Track Tool in addition to the main app module for Studio, as well as an app module for StationPlaylsit Creator."""),
"",_(u"""The overall design is that of a partnership between the main Studio app module and the Studio Utilities (SPLUtils) global plugin. Studio app module performs things expected from scripts such as responding to key presses, announcing status information, configuration management and so forth, while the global plugin is responsible for running Studio commands from anywhere and for encoder support (the add-on supports SAM and SPL encoders). In reality, the global plugin is subordinate to the app module, as the app module controls overall functionality of the add-on and because the global plugin requires Studio to be running to unlock some features (here, unlock means using layer commands and encoder support)."""),
"",_(u"""The source code consists of:"""),
"",_(u"""* appModules: This folder contains the main splstudio (app module) package and the app modules for Track Tool and Creator."""),
_(u"""* The SPL Studio package consists of various modules, which include __init__ (main app module and track item classes), configuration manager and user interfaces (splconfig and splconfui) and miscellaneous services (splmisc) as well as support modules and various wave files used by the add-on."""),
_(u"""* The main app module file is divided into sections. First, the overlay classes for track items are defined, then comes the app module, further divided into four sections: fundamental methods (constructor, events and others), time commands (end of track, broadcaster time, etc.), other commands (track Finder, cart explorer and others) and SPL Assistant layer. This allows me to identify where a bug is coming from and to add features in appropriate sections."""),
_(u"""* globalPlugins: This folder contains SPLStudioUtils package, which consists of __init__ (main plugin and SPL Controller layer) and encoder support module."""),
"",_(u"""### Design philosophy"""),
"",_(u"""When I set out to write the add-on in 2013, I put forth certain things the add-on should adhere to, including:"""),
"",_(u"""* Consistency: The add-on should have a consistent interface and command structure. Interface includes various GUI's such as add-on configuration dialog. For layer commands, I tried using native Studio command assignments."""),
_(u"""* Extensibility: The add-on should be organized and written in such a way that permits easy extensibility, hence the app module and the global plugin were divided into submodules, with each of them being a specialist of some kind (such as configuration management)."""),
_(u"""* Separation of concerns: Coupled with extensibility, this allowed me to provide just needed commands at the right time, which resulted in two layer command sets (explained below)."""),
_(u"""* Easy to follow source code: Although some may say excessive documentation is a noise, I believe it is important for a developer to understand how a function or a module came about. Also, I have used and read user guides for other screen reader scripts to better understand how a feature worked and come up with some enhancements to a point where I found some major bugs with JAWS scripts (one of them, which I hope Brian patched by now is microphone alarm where the alarm would go off despite the fact that microphone was turned off before alarm timeout has expired)."""),
_(u"""* Unique feature labels: One way to stand out was to give features interesting names. For instance, during add-on 3.0 development, I decided to give cart learn mode a name that better reflects what the feature does: Cart Explorer to explore cart assignments. Same could be set about NVDA's implementation of enhanced arrow keys (called Track Dial, as the feature is similar to flipping a dial on a remote control)."""),
_(u"""* Extensive collaboration and feedback cycle between users and developers: I believed that the real stars of the show were not the add-on code files, but broadcasters who'll use various add-on features. Because of this, I worked with users early on, and their continued feedback shapes future add-on releases. This collaboration and feedback cycle also helped me (the add-on author) understand how the add-on was used and to plan future features to meet the needs of broadcasters who may use this add-on in various scenarios (a good example is broadcast profiles, as you'll see in add-on configuration section)."""),
"",_(u"""### Why two layer sets?"""),
"",_(u"""When I first sat down to design the add-on, I knew I had to write both an app module and a global plugin (to perform Studio commands from anywhere), which led to defining two layer command sets for specific purposes:"""),
"",_(u"""* SPL Assistant: This layer command set is available in the app module and is intended to obtain status information and to manage app module features. I called this Assistant because this layer serves as an assistant to a broadcaster in reading various status information. More details can be found later in this article."""),
_(u"""* SPL Controller: This layer is for the global plugin and performs Studio commands from anywhere. I called this \"controller\" because it controls various functions of Studio from other programs. More details will be provided below."""),
"",_(u"""In the early days, I enforced this separation, but in add-on 6.0, it is possible to invoke SPL Assistant layer by pressing the command used to invoke SPL Controller. In add-on 7.0, it is possible for SPL Assistant to emulate commands from other screen reader scripts, and the mechanics of it is covered later in this article."""),
"",_(u"""### The \"magic\" behind layer commands"""),
"",_(u"""In order for layer commands to work, I borrowed code from another add-on: Toggle and ToggleX by Tyler Spivey. Toggle/ToggleX allows one to toggle various formatting announcement settings via a layer command set. It works like this:"""),
"",_(u"""* Dynamic Command:script binding and removal: It is possible to bind gestures dynamically via bindGesture/bindGestures method for an app module or a global plugin (bindGesture binds a single command to a script, whereas bindGestures binds commands to scripts from a gestures map or another container). To remove gesture map dynamically, the main/layer gestures combo was cleared, then the main gestures were bound."""),
_(u"""* Use of two or more gesture maps in the app module/global plugin: Normally, an app module or a global plugin that accepts keyboard input uses a single gestures map (called __gestures; a map is another term for dictionaries or associative array where there is a value tied to a key). But in order for layers to work, a second gestures map was provided to store layer commands (command and the bound script of the form \"command\":\"script\")."""),
_(u"""* Wrapped functions: Tyler used \"wraps\" decorator from functools to wrap how \"finally\" function is called from within the layer set (this was needed to remove bindings for layer commands after they are done). Also, a custom implementation of getScript function (app module/global plugin) was used to return either the main script of the layer version depending on context."""),
"",_(u"""A typical layer command execution is as follows:"""),
"",_(u"""1. First, assign a command to a layer (entry) command (add-on 2.0 and later; add-on 1.x used NVDA+Grave for SPL Controller and Control+NVDA+Grave for the Assistant layer; removed in 2.0 to prevent conflicts with language-specific gestures)."""),
_(u"""2. You press the layer entry command. This causes the app module/global plugin to perform the following:"""),
_(u"""	1. Layer conditions are checked. Until add-on 6.x, the app module wanted to see if you are in the Playlist Viewer (relaxed in add-on 7.0), and for the global plugin, checks if Studio is running."""),
_(u"""	2. Sets a flag telling NVDA that the Assistant/Controller layer is active."""),
_(u"""	3. Adds gestures for the layer set to the main gestures map via bindGestures function. In case of screen reader emulation in SPL Assistant, the appropriate gestures map is selected."""),
_(u"""3. You press a command in the layer set (such as A from Assistant to hear automation status, or press A to turn automation on if using SPL Controller layer). Depending on how the layer script is implemented, it either calls Studio API (for SPL Controller layer and for some Assistant commands) or simulates object navigation to fetch needed information (Assistant layer). In the app module, for performance reasons, the object is cached. More details on mechanics of this procedure in subsequent sections."""),
_(u"""4. After the layer command is done, it calls \"finish\" function (app module/global plugin) to perform clean up actions such as:"""),
_(u"""	* Clears layer flags."""),
_(u"""	* Removes the \"current\" gestures (main gestures and layer commands) and reassigns it to the main gestures map (this is dynamic binding removal)."""),
_(u"""	* Performs additional actions depending on context (for example, if Cart Explorer was in use)."""),
"",_(u"""### The importance of Studio window handle and Studio API"""),
"",_(u"""In order to use services offered by Studio, one has to use Studio API, which in turn requires one to keep an eye on window handle to Studio (in Windows API, a window handle (just called handle) is a reference to something, such as a window, a file, connection routines and so on). This is important if one wishes to perform Studio commands from other programs (Studio uses messages to communicate with the outside program in question via user32.dll's SendMessage function)."""),
"",_(u"""Starting from add-on 7.0, one of the activities the app module performs when started (besides announcing the version of Studio you are using) is to look for the handle to Studio's main window until it is found (this is done via a thread which calls user32.dll's FindWindowA (not FindWindowW) function every second), and once found, the app module caches this information for later use. A similar check is performed by SPL Controller command, as without this, SPL Controller is useless (as noted earlier). Because of the prominence of the Studio API and the window handle, one of the first things I do whenver new versions of Studio is released is to ask for the latest Studio API and modify the app module and/or global plugin accordingly."""),
"",_(u"""## Life of the SPL app module"""),
"",_(u"""Now you have a bit of an overview of the add-on, let's dive into the core components: SPL app module and support modules. In this section, we'll go through life of the SPL Studio app module: from start to finish and everything in between. We'll cover more specific features of the app module throughout this article."""),
"",_(u"""Note: For the rest of this article, you'll see some portions of the source code to let you better understand how something works (mostly pseudo code will be provided). Also, certain things will require explaining how NVDA Core (the screen reader itself) works (so you'll learn several things at once)."""),
"",_(u"""### SPL Studio app module: design and code overview"""),
"",_(u"""As noted previously, the SPL Studio app module (splstudio/__init__.py) consists of several sections. These include (from top to bottom):"""),
"",_(u"""* Imports: Many modules from Python packages and from NVDA screen reader are imported here, including IAccessible controls support, configuration manager and so on."""),
_(u"""* Layer command wrapper: I talked about how layer commands work in a previous chapter, and the \"finally\" function at the top is the one that makes this possible."""),
_(u"""* Few helper functions and checks: This includes a flag specifying minimum version of Studio needed, the cached value for Studio window handle (SPLWin) and place holders for threads such as microphone alarm timer (more on this in threads section). This section also includes helper functions such as \"messageSound\" (displays a message on a braille display and plays a wave file) and other helper functions."""),
_(u"""* Track item overlay classes: two classes are provided to support Playlist Viewer items in Studio 5.0x and 5.1x, respectivley. We'll come back to these objects later."""),
_(u"""* App module class: This is the core of not only the app module, but the entire add-on package. The app module class (appModules.splstudio.AppModule) is further divided into sections as described in add-on design chapter."""),
"",_(u"""Let's now tour the lifecycle of the app module object in question: before and during app module initialization, activities performed while the app module is active, death and add-on updates."""),
"",_(u"""### Before birth: NVDA's app module import routines"""),
"",_(u"""Before we go any further, it is important for you to understand how NVDA loads various app modules. This routine, available from source/appModuleHandler.py (NVDA Core), can be summarized as follows:"""),
"",_(u"""1. If a new process (program) runs, NVDA will try to obtain the process ID (PID) for the newly loaded process."""),
_(u"""2. Next, NVDA will look for an app module matching the name of the executable for the newly created process. It looks in various places, including source/appModules, userConfigDirectory/appModules and addonname/appModules, then resorting to the default app module if no app module with the given name is found."""),
_(u"""3. Next, NVDA will attempt to use Python's built-in __import__ function to load the app module, raising errors if necessary. No errors means the app module is ready for use."""),
_(u"""4. Once the newly loaded module is ready, NVDA will instantiate appModule.AppModule class (make it available). If a constructor (__init__ method) is defined, Python (not NVDA) will call the app module constructor (more on this below)."""),
"",_(u"""In case the app module's AppModule class has a constructor defined, Python will follow directions specified in the constructor. Just prior to performing app module specific constructor routines, it is important to call the constructor for the default app module first as in the following code:"""),
"",_(u"""	def __init__(self, *args, **kwargs):"""),
_(u"""		super(AppModule, self).__init__(*args, **kwargs)"""),
"",_(u"""This is a must because the default app module constructor performs important activities, including:"""),
"",_(u"""1. The default app module constructor will call another base constructor (this time, it is baseObject.ScriptableObject, containing gestures support among other important properties)."""),
_(u"""2. Initializes various properties, such as PID (process ID), app module name (if defined), application name and the handle to the app in question via kernel32.dll's OpenProcess function (XP/Server 2003 and Vista/Server 2008 and later requires different arguments)."""),
_(u"""3. Lastly, the constructor initializes process injection handle and helper binding handle in case such routines are required."""),
"",_(u"""### Birth: SPL Studio app module construction"""),
"",_(u"""Certain app module add-ons shipts with an app module with a constructor define, and SPL Studio is one of them. After calling the base constructor as described above, SPL app module's constructor (__init__ method that runs when the app module starts) does the following:"""),
"",_(u"""1. Checks whether a supported version of Studio is running, and if not, raises RuntimeError exception, preventing you from using the app module while an unsupported version of Studio is in use (as of add-on 7.0, you need to use Studio 5.00 and later)."""),
_(u"""2. Unless silenced by `globalVars.appArgs.minimal` being True, NVDA announces, \"Using SPL Studio version 5.01\" if Studio 5.01 is in use (of course, NVDA will say 5.10 when Studio 5.10 is in use). This is done via ui.message function (part of NVDA Core) which lets you hear spoken messages or read the message on a braille display. In reality, ui.message function calls two functions serially (one after the other): speech.speakMessage (speaking something via a synthesizer) and braille.handler.message (brailling messages on a braille display if connected)."""),
_(u"""3. Next, add-on settings and related subsystems are initialized by calling splconfig.initialize(). For add-on 6.x and 7.x, the first four steps are performed by the init (formerly initConfig) function itself, while in 8.0 it is handled by SPLConfig class constructor. Add-on 17.10 changes this significantly (see the next section). This is done as follows:"""),
_(u"""	1. For add-on 6.x and 7.x, loads a predefined configuration file named userConfigPath/splstudio.ini. In add-on 6.0 and later, this is known as \"normal profile). In add-on 6.x and 7.x, this is done by calling splconfig.unlockConfig() function that handles configuration validation via ConfigObj and Validator, and in 8.0 and later, this is part of SPLConfig constructor. In add-on 17.10 and later, this step will not take place if NVDA is told to use an in-memory config."""),
_(u"""	2. For add-on 6.0 and later, loads broadcast profiles from addonDir/profiles folder. These are .ini files and are processed just like the normal profile except that global settings are pulled in from the normal profile. In add-on 8.0, just like normal profile, this is done when constructing SPLConfig object. In add-on 17.10 and later, if the add-on is told to use normal profile only, this step will not occur."""),
_(u"""	3. Each profile is then appended to a record keeper container (splconfig.SPLConfigPool for 6.x and 7.x, splconfig.SPLConfig.profiles in 8.0 and later). Then the active profile is set and splconfig.SPLConfig (user configuration map) is set to the first profile in the configuration pool (normal profile; for add-on 5.x and earlier or if only normal profile is to be used (17.10 and later), there is (or will be) just one profile so append step is skipped)."""),
_(u"""	4. Starting from add-on 7.0 and enhanced in 17.10, unless saving settings to disk is prohibited or in-memory config is requested, Normal profile dictionary (not others) is cached. This is useful in keeping a record of settings loaded from disk versus run-time configuration and is employed when comparing values when saving profiles. See profile caching section in broadcast profiles for details and reasons."""),
_(u"""	5. If an instant profile is defined (a cached instant profile name is present), the instant profile variable is set accordingly."""),
_(u"""	6. If errors were found, NVDA either displays an error dialog (5.x and earlier) or a status dialog (6.0 and later) detailing the error in question and what NVDA has done to faulty profiles. This can range from applying default values to some settings to resetting everything to defaults (the latter will occur if validator reports that all settings in the normal profile are invalid or ConfigObj threw parse errors, commonly seen when file content doesn't make sense)."""),
_(u"""	7. In add-on 7.0, add-on update facility is initialized (splupdate.initialize). among other things, the initialization routine loads update check metadata. We'll meet add-on update routines (housed in splstudio/splupdate.py) later in this article."""),
_(u"""	8. Prepares routines used by time-based profile switching facility by loading triggers map and checking if NVDA should switch to the next profile (this is done if the show associated with the given profile hasn't ended yet). See time-based profile section for details."""),
_(u"""	9. Encoder settings file is loaded, and if ConfigObj throws errors, encoder settings will be reset to defaults."""),
_(u"""	10. In add-on 8.0, track comments are loaded (if any). See track items section for details."""),
_(u"""	11. Although not part of the init routine, starting from 17.12, various modules register one or more functions for action notifications. See extension points section for details."""),
_(u"""4. Starting with NVDA 2015.3, it became possible for an app module to request NVDA to monitor certain events for certain controls even if the app is not being used. This is done by calling eventHandler.requestEvents function with three arguments: process ID, window class for the control in question and the event to be monitored. For earlier versions of NVDA (checked via built-in hasattr function), this step is skipped, and background status monitor flag is then set accordingly. We'll discuss event handling throughout this article."""),
_(u"""5. Next, GUI subsystem is initialized (NVDA uses wxPython). This routine adds an entry in NVDA's preferences menu entitled \"SPL Studio Settings\", the add-on configuration dialog."""),
_(u"""6. As described above, the app module will look for the window handle for the Studio app."""),
_(u"""7. If the app module is told to announce status of metadata streaming and connect to predefined URL's, NVDA will do it at this point. This is done in the same function that looks for the Studio handle. In order to announce status messages as the last announcement after connecting to metadata servers, Studio app module places ui.message in the event queue to be handled by NVDA (queueHandler.queueFunction). More on internals of metadata announcement and related components in the SPL Assistant chapter."""),
_(u"""8. In add-on 7.0, if automatic update check is enabled, update check timer is started."""),
"",_(u"""#### Changes introduced in 17.10 due to volatile configuration flags"""),
"",_(u"""In add-on 17.10, several internal flags and associated command-line switches are introduced to control how the add-on settings are loaded and treated. Presence of these flags will significantly alter the way settings are loaded and saved. These flags should be used when instructed by the add-on developer, as they are used for troubleshooting or experimenting purposes."""),
"",_(u"""The flags are as follows:"""),
"",_(u"""1. Do not save changes to disk (configNoSave/--spl-confignosave): all profiles (including broadcast profiles) will be loaded from disk but changes will not be saved. With this flag turned on, profile caching will not occur, including normal profile."""),
_(u"""2. Load normal profile only (normalProfileOnly/--spl-confignormalonly): broadcast profiles will not be used, including ability to create new profiles and using time-based profile switching (see time-based profiles section for details). Combining this with configIsVolatile flag effectively makes normal profile a read-only config store."""),
_(u"""3. Use in-memory config (configInMemory/--spl-configinmemory): only normal profile will be used, but instead of loading settings from disk, an in-memory version with default settings applied will be used with no caching at all."""),
"",_(u"""Using flags that specify the use of normal profile only will restrict ability to create new broadcast profiles."""),
"",_(u"""### Life of the app module: events, commands and output"""),
"",_(u"""Once the Studio app module is ready, you can then move to Studio window and perform activities such as:"""),
"",_(u"""* Press commands, and NVDA will respond by either opening a dialog or speaking what it did."""),
_(u"""* Announce status changes such as microphone status. The length and format of these messages (and other add-on messages) are controlled by message verbosity flag (in case verbosity is set to advanced, NVDA will shorten these announcements, which comes from a messages pool). A special case is announcing artist and title of the currently playing track automatically, for which object navigation is employed. This is necessary due to a broken option in Studio itself."""),
_(u"""* Find tracks."""),
_(u"""* Examine information in columns via Track Dial and/or Columns Explorer (Track Dial was deprecated in 2017)."""),
_(u"""* Listen to progress of a library scan in the background."""),
_(u"""* Perform SPL Assistant gestures."""),
_(u"""* For 6.0 and later, manage broadcast profiles (we'll talk about broadcast profiles in configuration management section)."""),
_(u"""* For 17.12 and later, respond to actions such as broadcast profile switches."""),
"",_(u"""#### Extension points"""),
"",_(u"""Introduced in NVDA 2017.4, an extension point is a notification system from NVDA that tells modules and functions to perform tasks when something happens. For example, the braille subsystem will load a different braille display if different configuration profiles specify this change, or a speech synthesizer can filter certain text from spoken messages before announcing it to users."""),
"",_(u"""There are three extension point types:"""),
"",_(u"""* Action: a function can wait for something to happen, such as change of profiles, loading and saving settings and others, and act accordingly once an action takes place."""),
_(u"""* Decider: A data processor inside a script or a function can tell NVDA to continue processing data, such as passing a keystroke to remote system."""),
_(u"""* Filter: a speech processor can add, change, or remove texts before letting synthesizers announce the would-be spoken text."""),
"",_(u"""In Studio add-on, actions are used to notify modules of some action such as when Studio exits, broadcast profile switches and so on. There are two actions defined (in splactions module):"""),
"",_(u"""* Broadcast profile switch: notifies microphone alarm thread and metadata streaming configuration to switch streams or turn off the alarm (see below for details)."""),
_(u"""* Studio exiting: tells add-on dialogs to close without saving settings."""),
"",_(u"""### Death: termination routines"""),
"",_(u"""While using Studio add-on, you can stop using the add-on in various ways, including exiting or restarting NVDA, turning off your computer or logging off or closing Studio. Just like initialization routines, the Studio app module has specific directions to follow when add-on is closed."""),
"",_(u"""Here is a list of steps Studio app module performs when it is about to leave this world:"""),
"",_(u"""1. The \"terminate\" method is called. Just like the startup (constructor) routine, this method first calls the terminate method defined in the default app module, which closes handles and performs other closing routines."""),
_(u"""2. Calls splconfig.terminate() function to save add-on settings and perform shutdown routines for some features. This function goes through following steps in add-on 7.0:"""),
_(u"""	1. In add-on 7.0, if update check timer is running, the timer is told to stop, and update metadata is copied back to normal profile."""),
_(u"""	2. Unless disabled through flags in 17.10, profiles are saved (beginning with normal profile) to disk if and only if profile-specific settings were changed (an online cache used for storing profile settings when they are loaded is kept for this purpose). This step will not occur if an in-memory version of normal profile is in use."""),
_(u"""	3. If there is an instant switch profile defined, this is recorded in the normal profile, otherwise it is removed from the profile database."""),
_(u"""	4. Once all profiles are saved, various flags, active profile and config pool is cleared."""),
_(u"""	5. For add-on 5.x and earlier, there is only one broadcast profile to worry about, and this profile is saved at this point."""),
_(u"""	6. These steps are part of splconfig.SPLConfig.save method in add-on 8.0 and later."""),
_(u"""3. In 17.12 and later, NVDA notifies registered handlers for app terminate action. As noted above, this will cause add-on dialogs to close without saving settings."""),
_(u"""4. NVDA then attempts to remove SPL Studio Settings entry from NVDA's preferences menu, then various maps used by Studio add-on (such as Cart Explorer map) are cleared."""),
_(u"""5. As the app module is laid to rest, the window handle value for Studio window is cleared. This is a must, as the handle will be different next time Studio runs. At this point, NVDA removes splstudio (Studio app module) from list of app modules in use."""),
"",_(u"""### Add-on updates: updating to latest and greatest version"""),
"",_(u"""In add-on 7.0 and later, it is possible to update to the latest version of the add-on by using add-on update check facility. This is done by connecting to a server where the update add-on files are stored."""),
"",_(u"""The Studio add-on uses a combination of urllib library and development branches (explained later) to fetch the needed update metadata. The user can tell the add-on to check for updates automatically or one can perform this check manually."""),
"",_(u"""The update check is performed as follows:"""),
"",_(u"""1. If the add-on is told to check for updates, the Studio app module constructor will start a timer whose purpose is to call a function when it is time to check for an update."""),
_(u"""2. If automatic update check is enabled, the update manager (splconfig.updateInit) will determine when the update was checked last. This is done in order to perform update checks every 24 hours."""),
_(u"""3. Once the timer kicks in (automatic update check is on), the update check function (splupdate.updateChecker) will be called. This function uses two parameters to determine if a status progress tone should be played and to schedule the next update check."""),
_(u"""4. The update check function first connects to the URL for the current development branch (more on branches at the end of this article) and compares the filename returned by the server. If the file names does not match, the add-on will interpret this as presence of an update and will return a dictionary containing current add-on version, new version (parsed as a regular expression) and URL for the file, and if not, it returns nothing."""),
_(u"""5. If a new version is available and if the user said \"yes\" to update prompt, the update metadata (update timestamp) will be cached to be retrieved by the app module later."""),
_(u"""6. This process repeats if automatic check is enabled (a timer will be set to call this function again after 24 hours)."""),
"",_(u"""In case of a manual update check (described in SPL Assistant layer section), apart from not using a timer and stopping an update check timer temporarily (if needed), it will go through steps 3 through 5 from above."""),
"",_(u"""## Time announcements, alarms and adjusting basic settings"""),
"",_(u"""Now that we know how Studio app module is born and dies, it is time for us to look at what happens while the Studio add-on is alive, and we'll start with how Studio add-on announces time, work with alarms and uses basic settings."""),
"",_(u"""### Time announcement routines: a tale of four brothers"""),
"",_(u"""SPL Studio app module for NVDA comes with four time announcement commands. These are elapsed time, remaining time, broadcaster time and complete time including seconds. The first two uses Studio API to obtain needed information, while others use a combination of Python routines and Windows API functions."""),
"",_(u"""Three of these routines are assigned to commands (sometimes termed gestures). These are:"""),
"",_(u"""* Control+Alt+T: Remaining time"""),
_(u"""* Alt+Shift+T: Elapsed time"""),
_(u"""* NVDA+Shift+F12: Broadcaster time"""),
"",_(u"""One can then use Input Gestures dialog (part of NVDA screen reader) to change them or assign a command to complete time routine."""),
"",_(u"""### A step sideways with studioAPI function: A central Studio API handler and dispatcher"""),
"",_(u"""Before going any further, it is important to mention a function that not only is used by the first two time routines, but also comes in handy in SPL Assistant and other methods. This function, called studioAPI (part of the main app module and defined as a module-level function), sends messages to Studio window and retrieves the value returned. The signature is:"""),
"",_(u"""	studioAPI(arg, command)"""),
"",_(u"""With the arguments being the message to be sent to studio window (arg and command). At first glance, it may seem similar to user32's SendMessage function (in fact, that's what the studioAPI function will call), but unlike a typical SendMessage function routine, the Studio handle and message type is automatically filled in, hence only argument (WParem) and command (LParem) are needed."""),
"",_(u"""In older versions of the add-on, studioAPI did more than return results. It called a callback with or without an offset, as well as not return anything. However, the only callback passed in was time announcer (next section), thus in 2018, studioAPI function has been relegated to a thin wrapper around SendMessage function with Studio window handle and message typed filled in."""),
"",_(u"""### First applications of studioAPI function: Announcing elapsed and remaining times"""),
"",_(u"""When you press Control+Alt+T or Alt+Shift+T to hear remaining or elapsed time, the script will first check if you are in the main Playlist Viewer, and if so, will call studioAPI function with correct arguments and commands, the result then being fed to announceTime function. In fact, the only differences are argument that is used and the error message."""),
"",_(u"""### Broadcaster time: Simulating Studio's broadcaster clock"""),
"",_(u"""When you listen to radio shows, you may hear messages such as, \"five minutes to two\" or \"ten minutes past five\". This announcement is called broadcaster time."""),
"",_(u"""Studio does display broadcaster clock. However, because it is in the middle of the screen, one has to use object navigation commands to locate it, and this method was used in older Studio add-on releases. This involved locating the foreground window (api.getForegroundObject()) and navigating through a preset direction to arrive at the clock object, and this is still used in some places. However, this was prone to a critical problem: sometimes, the object we're interested in changed positions (a good example was when different builds of Studio 5.10 were released)."""),
"",_(u"""Recently, this method was abandoned in favor of using Python's time module to obtain current time and convert it into a format that is familiar to broadcasters, thus removing the need to use object navigation. When you press NVDA+Shift+F12, NVDA first fetches local time (time.localtime), then converts this into a format suitable for output. Along the way NVDA tries to emulate how Studio displays broadcaster clock. Recently, a slight modification was made so this process can be used to obtain time left to top of the hour when NVDA+Shift+F12 is pressed twice, with the difference being subtracting local time from top of the next hour. When processing is completefor both cases, NVDA announces the output text."""),
"",_(u"""### Complete time: Windows API to the rescue"""),
"",_(u"""Here, complete time refers to time including seconds. Normally, when you press NVDA+F12, NVDA excludes seconds when announcing time. All that is needed to announce seconds is to change the format argument for kernel32.dll's GetTimeFormat function. With this change, NVDA can announce time including seconds, but in order to use it, you need to assign a command to this feature (some app module commands are not assigned by default)."""),
"",_(u"""### Setting alarms"""),
"",_(u"""Studio app module comes with three alarms: song outro (ending), intro and microphone active alarm. Because we need to talk about some important things when talking about microphone alarm, we'll just tour the routine used when setting up the intro and outro alarms."""),
"",_(u"""When you press Alt+NVDA+1 or Alt+NVDA+2 to open end of track or song intro alarm dialogs, the dialog will display two controls:"""),
"",_(u"""* Alarm setting: a spin box (a sping control) is used to adjust alarm values. You can type the alarm value or use up or down arrow to change the value. If an incorrect value is entered, the maximum value (59 for end of track, 9 for song intro) will be used."""),
_(u"""* Notification check box: This sets whether alarm will play or not."""),
"",_(u"""In reality, a single dialog (splconfui.AlarmsCenter class) presents these two alarm dialogs (there are two additional dialogs, covered in the next section). The type of dialog to be shown is controled by an integer which denotes which dialog text to present. The process is outlined below:"""),
"",_(u"""1. Just before the dialog opens, checks if another dialog or the add-on settings dialog is opened, and if so, NVDA will ask you to close the previously opened dialog first."""),
_(u"""2. Tells NVDA that an alarm dialog is opened. This is meant to prevent the same dialog from being opened repeatedly."""),
_(u"""3. After the dialog is dismissed (either a new value is set or you click Cancel), NVDA clears the alarm opened flag, thereby letting other dialogs to be shown. """),
"",_(u"""We'll learn how the alarm values are stored and retrieved in the configuration management section, and you'll get to meet how intro and outro alarms work in the next chapter."""),
"",_(u"""#### Alarms Center"""),
"",_(u"""This single dialog that presents different alarm controls is known as 'Alarms Center\". In fact, not only this dialog houses end of track and track intro alarms, it includes microphone alarm controls, and all that's needed to change its appearance is a single integer that specifies which portion of the dialog should be shown. In case of Alarms Center dialog presented from add-on settings (see a later chapter on add-on configuration), all alarm controls will be shown (level = 0), with different levels controlling what controls should be shown as follows:"""),
"",_(u"""* 0: Alarms Center, displays all controls."""),
_(u"""* 1: End of track alarm."""),
_(u"""* 2: Track intro alarm."""),
_(u"""* 3: Microphone alarm controls."""),
"",_(u"""### Toggle settings"""),
"",_(u"""Studio add-on comes with some toggle settings that affect the operation of the app module. These include status announcements (Control+NVDA+1), library scan announcement (Alt+NVDA+R) and braille timer (Control+Shift+X). For each setting script, NVDA will first check the current value, change the value and announce the new value."""),
"",_(u"""Now you know how the alarm dialogs function, what happenn when you toggle some settings and went through a behind the scenes tour of various time announcement commands. There are other things we need to talk about, and we'll continue our discussion of the Studio app module with how alarms come into play and how status changes are announced."""),
"",_(u"""## Event handling: announcing status changes, activating alarms and more"""),
"",_(u"""When you are producing a live show, it is important for your screen reader to announce various status changes and happenings such as number of listeners, outro notification, playback status, alerting you of listener requests and so on. NVDA is an expert when it comes to handling status changes, activating alarms and more. In this section, we'll learn the magic behind this expertise: handling events."""),
"",_(u"""### NVDA is event-driven"""),
"",_(u"""Windows applications (especially those using Windows API) are event-driven programs. Somewhere in the application is an event loop that responds to various events, such as when a check box is clicked, computer is shutting down and so on. NVDA, being a Windows screen reader, does use events for various purposes, ranging from announcing new chat notification in Skype to ignoring it completely."""),
"",_(u"""To handle various events, NVDA uses an event queue (queue handler) and an event handler for event processing. When an event is fired by itself or from other programs, NVDA first checks if the given event is worthy of its attention. Then it performs actions associated with the event, such as announcing changes to a control (name, value, etc.), playing beeps and sounds (progress bar updates) and so on. For add-ons (mostly global plugins and app modules), NVDA is eager to listen to certain events and let controls fire events."""),
"",_(u"""Typically, an event handling routine is declared like this:"""),
"",_(u"""	event_eventname(module, object in question, next handler)"""),
"",_(u"""For example, for Studio app module, one event handler declared is gain focus (you have moved to a different control), and is written as follows:"""),
"",_(u"""	event_gainFocus(self, obj, nextHandler)"""),
"",_(u"""The routine is just like any other function (callable) except that the routine called nextHandler function at the end to allow other controls to respond to events."""),
"",_(u"""### What does events have to do with Studio app module?"""),
"",_(u"""Events and event handlers are crucial to the operation of the Studio app module, described as \"heartbeat\" of the add-on. Events and their handlers are used to perform bulk of the work required to allow the app module to function. These include:"""),
"",_(u"""* Announcing status changes such as when microphone is turned on or off."""),
_(u"""* Alarm notification, such as when end of intro is approaching."""),
_(u"""* Activating certain announcement and background tasks such as activating microphone alarm, announcing library scan progress and more."""),
_(u"""* Perform workarounds for issues such as focus problems when deleting a track."""),
"",_(u"""Of all the event handlers declared, the most important one is name change event. It is declared as follows:"""),
"",_(u"""	event_nameChange(self, obj, nextHandler)"""),
"",_(u"""When this event is fired by Studio, NVDA performs following operations:"""),
"",_(u"""1. Various checks are performed. These include, but are not limited to:"""),
"",_(u"""A. Make sure there is something to announce."""),
_(u"""B. If using another app, NVDA will ensure that background monitor flag is set (see the discussion on app module constructor in previous articles for more details)."""),
_(u"""C. If the status to be announced is a common one such as listener count, schedule and cart playback status, NVDA will check if it is permited to announce them."""),
"",_(u"""2. Depending on the type of control (mostly window class name), NVDA performs different operations (see below)."""),
_(u"""3. Lastly, NVDA calls nextHandler() to let other controls respond to name change event."""),
"",_(u"""### Status announcements versus alarm notification"""),
"",_(u"""There are two groups of controls NVDA is interested in: status bar and status text with window class name of TStatusBar and TStaticText, respectively (Studio is a Delphi application). Depending on which control fired the event, NVDA will respond differently."""),
"",_(u"""For status announcements (TStatusBar), NVDA:"""),
"",_(u"""1. Checks IAccessible child ID (position of the control relative to the parent control as exposed by MSAA (Microsoft Active Accessibility)/IAccessible)."""),
_(u"""2. If IAccessible child ID is 1, it either announces library scan progress or playback status."""),
_(u"""3. For other status bar objects (controls or windows), NVDA first checks if it is a toggle change (ends with \"On\" or \"Off\"), and if so, it does the following:"""),
"",_(u"""A. If you set status announcement to words (Control+NVDA+1), NVDA announces toggle change notification via speech."""),
_(u"""B. If status announcement is set to beeps, an appropriate wave file is selected for playback via NVWave module (nvwave.playWaveFile; this is done via messageSound function)."""),
_(u"""C. Braille output is not affected - it'll announce toggle changes."""),
_(u"""D. For cart edit mode or microphone toggle, extra steps are performed, (by calling extraAction method with the status string as the argument) such as activating microphone alarm or announcing that you are using Cart Explorer (if this is the case). We'll come back to how this works in future installments."""),
"",_(u"""4. For all other announcements, NVDA announces them. In case of schedule announcement, to prevent itself from repeating the same message, NVDA checks if a cached name is the same as the just changed name."""),
"",_(u"""For static text controls (mostly used for alarm notifications):"""),
"",_(u"""1. Checks whether NVDA is looking at remaining time for the intro or the whole track."""),
_(u"""2. For both cases, NVDA checks if it can braille this (braille timer is not off)."""),
_(u"""3. If NVDA is told to play or announce alarms (for outro and intro), NVDA plays appropriate tones (middle A (440 hertz) for outro, an octave above middle C (512 hertz) for intro), or if told to do so, warns you that end of track or intro is approaching (add-on 6.0 and later)."""),
"",_(u"""The structure of event_nameChange function defined in the Studio app module is such that it can be extended to handle name change event for other controls (it is a tree structure, with the root being the event and two subtrees, one for the status bar and another for static text). Just like other add-ons that define event handling routines, name change event calls nextHandler()."""),
"",_(u"""### Other events defined in the Studio app module"""),
"",_(u"""There are four more events defined in the Studio app module. They are:"""),
"",_(u"""* Gain focus: performs focus-related routines such as checking if you are in Insert Tracks dialog in order to turn off background library scanning (more on background library scan in a future installment)."""),
_(u"""* App module gain focus: Used to handle touchscreens (yes, Studio app module has a dedicated SPL touch mode) such as assigning additional commands."""),
_(u"""* App module lose focus: opposite of the event above."""),
_(u"""* Show: this event is specifically designed to respond to listener requests, discussed below."""),
"",_(u"""#### Listener requests"""),
"",_(u"""A seldom talked about component of StationPlaylist Studio is the ability to host a website with a PHP script to allow listeners to request tracks to be played by a broadcaster. When a request is made, Studio pops up a listener request dialog that lists requested tracks."""),
"",_(u"""Due to limitations of old NVDA releases, Studio app module did not have an easy way to detect the appearance of this dialog and notify you of listener requests. This is no longer the case, as NVDA allows show events to be registered for background event tracking. However, because anything can fire show events, tracking show events is not recommended. Knowing this, the Studio app module keeps an eye on show events for one and only one window: listener requests, represented by window class name of TRequests, with the only job assigned for this event handler being playing a sound when requests arrive provided that the requests pop-up option is set in Studio."""),
"",_(u"""So far, we have covered things that the app module performs wherever you are in Studio. the next few sections will cover how the app module handles specific situations, such as working with items in the playlist viewer, finding tracks, library scans and so on."""),
"",_(u"""## Track items, overlay classes and Track Finder"""),
"",_(u"""When you use the Studio add-on for NVDA, you may have noticed that you can perform certain commands while focused on track items, and that the command to find tracks is same as that of find command in web browsers. If you are curious about these, then this installment will let you see how it works. But first, we need to go over some more facts about NVDA screen reader, this time we'll talk about objects."""),
"",_(u"""### Important facts about NVDA's use of objects"""),
"",_(u"""One of the questions I and other add-on authors and NVDA developers received was, \"what exactly are objects and how are they used in NVDA?\" In programming, an object is instance of the object definition coming to life (this definition, called a \"class\", defines how certain things behave and how information can be retrieved from this object by other parts of the program; the programming paradigm that uses classes and related concepts is termed \"object-oriented programming\"). For example, someone may say, \"build me a phone book\", and a programmer will think about how phone book entries are stored and come up with a \"phone book\" (an array of phone entries), all done via objects."""),
"",_(u"""In graphical user interfaces (GUI's), an object is a more technical term for controls (sometimes called widgets). This includes windows, form fields, links, documents and so on. A control (object) can convey information such as state of the control, location, color and so on (the control contains both visible and internal attributes that can be used by other programs)."""),
"",_(u"""In NVDA world, all screen elements (controls) are objects. As such, when dealing with objects, NVDA uses accessibility API's to obtain needed information. To provide consistent user experience, differences between accessibility API's (IAccessible, UI Automation, Java Access Bridge and so on) are checked and provides a mechanism to announce same information across controls implemented using different frameworks. For example, when a check box is checked, NVDA will say \"checked\"\" - NVDA will know if you checked this box because the underlying accessibility API informs NVDA of this change, and the same information is spoken regardless of whether it is dealing with IAccessible, UIA and so on."""),
"",_(u"""Currently, NVDA can work with IAccessible, User Interface Automation (UIA), Java Access Bridge (JAB) and others (WAI ARIA is supported). Support modules for these API's lives in source/NVDAObjects directory of the NVDA Core source code."""),
"",_(u"""### Overlay classes: Customizing built-in objects"""),
"",_(u"""If NVDA was limited to using its own object handlers, we would be limited to information that is correctly exposed by accessibility API's (no app modules at all). But why is that NVDA can announce extra information for some controls and comes with various app modules for different applications? This is done through overlay classes - custom objects and their handlers built on top of API classes (built-in objects)."""),
"",_(u"""In essence, overlay classes are subclasses of stable API classes (subclasses are specialist classes deriving (inheriting) from one or more parent classes). This allows custom (overlay) objects to provide extra properties, ranging from control-specific commands to removing certain properties. For example, here's how NVDA's way of announcing toast notifications (Windows 8.x and 10) works:"""),
"",_(u"""1. Toasts are notifications from apps, and they are UIA objects (NVDAObjects.UIA.Toast)."""),
_(u"""2. When events fired by toasts are received by NVDA, it'll check to make sure it is dealing with toast notifications."""),
_(u"""3. When NVDA is dealing with toasts, it'll perform what it is told to do by toast objects (announce toasts provided by \"report help balloons\" is checked from Object Presentation dialog)."""),
"",_(u"""### Why do objects and overlay classes matter in Studio app module?"""),
"",_(u"""Some readers might ask this question after reading the above section on overlay classes. I had to introduce overlay classes because they are important in Studio app module: track items in playlist Viewer are overlay classes. In fact, there are two of them: track items for studio 5.0x (appModules.splstudio.SPLTrackItem) and 5.10 (appModules.splstudio.SPL510TrackItem; in case of 5.10, it derives its power from track item class for Studio 5.0x, which in turn is powered by IAccessible)."""),
"",_(u"""These classes were born when I started working on Studio 5.10 support in 2014. Because Studio 5.10 uses a different way of showing track properties, I had to come up with a way to take care of them. Adding to the urgency was the fact that Studio 5.10 uses check marks to indicate whether a track is selected for playback (Studio 5.0x and earlier uses check boxes), and when check marks are checked in Studio 5.10, NVDA would not announce newly checked state, fixed by defining a routine to be used when SPACE is pressed (via an overlay class). In addition, initial version of Track Finder (see below) was sensitive to object description changes, I modified it to account for differences between Studio versions."""),
"",_(u"""Then in 2015, when I was designing Track Dial (next section), I thought about scope of this feature. I thought, \"if I let this be invoked from everywhere, it could lead to issues such as errors and attempting to use Track Dial from somewhere other than track items\". Then I thought, \"perhaps I should limit this feature to main playlist viewer at the cost of making sure I identify track items correctly\". Given that I had experience with overlay classes and since there was already an overlay class for Studio 5.10 track items, I decided to go with the latter option, which led to defining a new overlay class for Studio 5.0x track items and letting 5.10 track items inherit from this new class."""),
"",_(u"""### Track items overview"""),
"",_(u"""Each track item in Studio's playlist viewer consists of a row of columns (6 for Studio 5.0x and earlier, 18 for 5.10 and later). As far as NVDA is concerned, it is an overlay class that provides a number of services, including:"""),
"",_(u"""* Routines for navigating and announcing various columns."""),
_(u"""* Announcing columns in specific order (see the next chapter on importance of column navigation)."""),
_(u"""* Obtaining track comments if defined (see track comments section below)."""),
_(u"""* For studio 5.10 and later, a routine to handle when check marks are checked (when you check a track by pressing SPACE, NVDA will announce the newly checked state and will update the braille display accordingly)."""),
"",_(u"""We'll come back to track items when talking about columns in the next article. For now, let's move onto two related features in Studio app module that works with track items: Track Finder and track comments. There is a second feature that deals with Track Finder, and we'll meet this feature in the next section."""),
"",_(u"""### Track Finder: Locating tracks given a search string"""),
"",_(u"""Track Finder allows you to search for tracks with the given artist or song title. This is done by performing a \"linear search\" - examining one track item to the next until the search term is found. This feature was partly inspired by similar features in other screen readers and NVDA's own find facility (cursorManager.FindDialog and its friends)."""),
"",_(u"""Track finder is not limited to searching for artist or title: a variation of this dialog (called Column Search) allows you to search for text in specific columns such as duration, file name and so on. Another variation of this dialog, called Time Range Finder (which is a separate dialog of its own (splmisc.SPLTimeRangeDialog) but modeled after Track Finder) uses Studio API to locate tracks with duration between minimum and maximum specified by a user."""),
"",_(u"""In reality, Track Finder and Column Search are a single dialog (splmisc.SPLFindDialog) that presents two dialogs (does this sound familiar?). For now, we'll talk about how the original Track Finder (add-on 2.x to 5.x) works (stay tuned for the next section to learn more about Column Search and the complete refactoring of track finder and its applications)."""),
"",_(u"""#### Original track Finder: commands, routines and controls"""),
"",_(u"""To use Track Finder, press Control+NVDA+F (wait, I saw this command before). For anyone who are accustomed to NVDA's browse mode, this command would be familiar: find text in webpages. This command performs activities similar to alarm dialogs (see previous articles): after conditions are checked (making sure you are in playlist viewer and you have added at least one track) and setting required flags, NVDA opens Track Finder dialog where you can enter a search term and press ENTER. NVDA will call track finder function (trackFinder) to locate the track with the given search term, and depending on search results, NVDA will move focus to the track or open a dialog saying results were not found."""),
"",_(u"""Two other commands are used as part of Track Finder: Find next and previous, assigned to NVDA+F3 and NVDA+Shift+F3, respectively (they also come from browse mode). When these commands are invoked, it'll check if you have searched for a term before, and if not, it'll open Track Finder dialog. If you have searched for a term before, NVDA will perform linear search with search direction specified (trackFinder method in the app module takes various parameters, and one of them is search direction)."""),
"",_(u"""#### Track Finder 1.0 versus 2.0"""),
"",_(u"""In add-on version 2.0 to 5.x, when told to find tracks, NVDA will look for search term in track descriptions (in case you are searching for artist in Studio 5.0x, NVDA will also check the name of the check box, as this holds artist name). Although this was simple to implement, it had some issues:"""),
"",_(u"""1. Because of track item changes in Studio 5.10, I had to spend some time adjusting the track finder formula."""),
_(u"""2. Wehn finding a track in a playlist with hundreds of tracks loaded, finding a track at the end of the playlist took several seconds, and this wasn't acceptable to users."""),
"",_(u"""In add-on 6.0, thanks to column search, Track Finder's performance was improved. Also, track finder was split into two functions: trackFinder still manages moving focus or showing the error dialog, while the linear search now lives in a private function. This design allows track finder routine to be used by more than one feature (in this case, place marker feature uses this, as you'll see in the next section."""),
"",_(u"""For both versions, the signature of trackFinder method (linear search routine in 1.0, search results manager in 2.0) in the Studio app module is:"""),
"",_(u"""	trackFinder(self, text, obj, directionForward=True, column=None)"""),
"",_(u"""Text is the search term, obj is where the search should begin, direction specifies search direction and column is used if Column Search is used (searching for text in specific columns). In Track Finder 2.0 (add-on 6.0), add an \"s\" to column keyword."""),
"",_(u"""In the next section, we'll learn more about how NVDA performs column navigation commands and how it is used in various features. We'll also meet how Track Finder refactor has helped implement an unexpected feature or two in the Studio add-on."""),
"",_(u"""## Method resolution  order and importance of column navigation in track items, Track Tool and other features"""),
"",_(u"""In the previous section, you saw how overlay classes work, as well as how track items in Studio are defined and used. We'll continue our tour of track items by looking at column navigation feature and how it is used in various places. But before we get into that, we need to talk about how NVDA knows how certain commands apply in specific situations via method resolution order."""),
"",_(u"""### Method resolution order: locating commands and defining command scope"""),
"",_(u"""If multiple classes (objects) are defined, especially if inheritance is involved, it becomes hard to determine which method is which and where various methods are defined. This becomes complicated when two or more classes inherit from a single parent, or multiple inheritance is in use (Python supports both scenarios)."""),
"",_(u"""One way Python solves this is through Method Resolution Order (MRO). Simply put, when a method is to be used, it first looks at whether this method is defined in the object it is dealing with, and if not, will consult the parent of this object."""),
"",_(u"""For example, suppose we have a list box that defines a scroll method, and a custom list box widget inherits from this list box (in effect, custom list box is a list box). To make matters slightly complicated, let's say the scroll method is not defined (not really defined) in the custom list box. Then when the user scrolls through the custom list box, Python will see that the custom list box does not have the scroll method, so it'll look at the parent (original list box) and use its scroll method (in this case, yes, Python will use the parent's scroll method)."""),
"",_(u"""In terms of NVDA, method resolution order comes in handy when dealing with overlay classes. This has wide ranging consequences, including ability to limit where certain commands can be used to not defining a command (setting the script bound to gesture to None), effectively forcing NVDA to look up a given gesture from the base class (parent). If NVDA cannot locate the command in question, it'll pass this to Windows, which then sends the command to the active program."""),
"",_(u"""### Finishing the puzzle: MRO and Studio's track items"""),
"",_(u"""As described in the previous section, Studio app module defines two classes for track items: one for Studio 5.0x and another for 5.1x. In reality, all that matters is the former, with the 5.10 class providing custom routines on top of the 5.0x track item class. In case of MRO, Studio 5.10 will be consulted if 5.10 is in use, then NVDA will consult Studio track item. For 5.0x, only original track item class will be consulted."""),
"",_(u"""The contents of the track item class (appModules.splstudio.SPLTrackItem) are as follows:"""),
"",_(u"""* initOverlayClass: This is run when the track item is first encountered. This method checks if Track Dial (see below) is active, and if so, assigns left and right arrow keys to Track Dial functions."""),
_(u"""* reportFocus: This is called when reporting track items to you (broadcaster). It's main job is to see if custom column order is defined (see below) and builds needed pieces if column order is specified."""),
_(u"""* Track column navigation: Various methods and scripts used by Track Dial and friends are defined, including announcing column information, handling leftmost column and so on. Add-on 8.0 adds Columns Explorer routines, and 17.04 adds vertical column navigation support."""),
_(u"""* Track comments: Routines related to working with comments for traks (see the previous section for details)."""),
"",_(u"""In addition, Studio 5.10 track item (appModules.splstudio.SPL510TrackItem) includes a script to announce changed state when SPACE is pressed (this is done by speaking and/or brailling track name (obj.name))."""),
"",_(u"""### Birth of Track Dial: from hesitation to possibilities"""),
"",_(u"""Note: Information on Track Dial is kept for reference purposes. Track Dial was deprecated in 2017 with the release of add-on 17.04."""),
"",_(u"""As I was writing the add-on, one of the top suggestions I received was ability to use enhanced arrow keys feature to review columns. This feature allows broadcasters using screen reader scripts to use arrow keys to review column information such as artist, duration and so on. As of time of this writing, all three screen reader scripts support this feature."""),
"",_(u"""At first, I told broadcasters that this wasn't possible. My impression back then (summer 2014) was that I had to manipulate track description text (obj.description) to enable this possibility. But seeing how other screen readers implement this convinced me that it might be possible to implement this for NVDA users, thus I started researching this in fall 2014."""),
"",_(u"""I started by looking for patterns in description text that could be used to give users an impression that column navigation was active (when it was not). I studied how Python handles regular expressions and manipulated substrings (str.find and slicing) with no satisfactory results. Then in 2015, while working on improving support for Studio's own stream encoder, I noticed that the encoder entries were SysListView32 objects (NVDAObjects.IAccessible.SysListView32). Careful study of this object, especially a method to retrieve column content, gave me an idea as to how to bring Track Dial to life."""),
"",_(u"""### The magic behind Track Dial: SysListView32 controls"""),
"",_(u"""SysListView32 controls are lists with items organized into columns. For example, certain apps use these controls to arrange entries into columns, such as in certain table-based apps, and in case of studio, displaying various status about encoders."""),
"",_(u"""When these controls are encountered, NVDA allows you to use table navigation commands (Control+Alt+arrows) to navigate between columns, provided that there are child objects (columns) exposed by the accessibility API implementation in use. Table navigation commands are supplied by another class (behaviors.RowWithFakeNavigation; the behaviors mix-in includes things NVDA should perform in various scenarios, including terminal input and output, editable text handling (via a dedicated module) and so on). This is all possible thanks to a method in SysListView32 class (NVDA Core) that allows one to retrieve column text, and this became the engine for Track Dial, Columns Explorer and other column navigation facilities in the Studio add-on (I say \"add-on\" because column navigation is used by both Studio and Track Tool)."""),
"",_(u"""The column text retrieval routine (which lives in SysListView32 and a copy lives in splstudio.splmisc module) is as follows:"""),
"",_(u"""1. Features requiring text from a specific column will call a private function in splstudio.splmisc module, which will take the current object and the column index as parameters."""),
_(u"""2. The column retriever first looks up the handle for the process where the control lives, then creates a place holder for the buffer to hold the column content."""),
_(u"""3. Next, it looks at the size of the underlying sysListView32 control (ctypes.sizeof) and asks Windows to allocate storage for an internal SysListView32 control via kernel32.dll's VirtualAllocEx. This is needed to store the resulting column text. Same is done for another place holder to store the actual column text by calling VirtualAllocEx."""),
_(u"""4. The retriever then creates an internal SysListView32 control used as a place holder to store column text, then asks Windows to tell the process where the column text lives to reveal the column text for the specified column (first calls WriteProcessMemory, sens a message via user32.dll's SendMessage to retrieve text length, then uses ReadProcessMemory to retrieve the actual column text if there is something to read). Once the column text is revealed, the retriever stores the text inside the text buffer (ctypes.create_unicode_buffer, allocated to store the resulting text)."""),
_(u"""5. Lastly, the retriever frees resources (VirtualFreeEx) and returns the just retrieved column text, which can be used by routines requesting this."""),
"",_(u"""### Column retrieval and navigation routines: from hesitation to a cornerstone"""),
"",_(u"""Column content retrieval routine has become one of the cornerstones of the Studio add-on. In addition to Track Dial, seven other routines uses it: Column Search, track place marker, column announcement order, Track Columns Explorer, vertical column navigation, playlist snapshots and Track Tool app module. Let's find out how seven of these work in more detail (playlist snapshots is described under SPL Assistant section, as it deserves a section of its own)."""),
"",_(u"""#### Track Dial: Navigating columns in track items"""),
"",_(u"""Note: no longer applicable since 17.04, included here for completeness."""),
"",_(u"""The column retriever routine is just one of the activities performed during Track Dial, and to see the beauty of this feature, assign a command to toggle Track Dial (you need to focus on the track item before opening Input Gestures dialog, as Track Dial is used by track items alone). Once you assign a command to toggle Track Dial and toggle this on, Studio will set a flag indicating that Track Dial is on, which causes left and right arrow keys to be assigned to column navigation commands (this flag is stored as part of the add-on configuration database). If you tell NVDA to play beeps for status announcements (see previous chapter), NVDA will play a high beep. Once you are done with Track Dial, press the just assigned command to turn off Track Dial, at which point left and right arrow keys return to their original functions, a low beep will be heard (if told to do so) and Track Dial flag will be cleared."""),
"",_(u"""When navigating columns, NVDA will check if you are at the edge of the track row, and if so, it will play a beep and repeat the last column text. If not, NVDA will look at the column you wish to navigate to (stored in the app module), then it'll call the column text retriever to retrieve the column text."""),
"",_(u"""To handle differences between Studio 5.0x and 5.1x, each track item class informs NVDA as to how leftmost column should be handled. For Studio 5.0x, leftmost column is artist field (obj.name will be checked), while track checked status is \"shown\" in Studio 5.10 (obj.name will be announced)."""),
"",_(u"""#### Custom column announcement order: What to announce and how"""),
"",_(u"""Track Dial routine also allowed another top request to come to life: column announcement order. This allows you (broadcaster) to hear columns in specific order and to exclude certain columns from being announced. This is housed in reportFocus method in the main track item class."""),
"",_(u"""In order to use this, you must tell NVDA to not use screen order (add-on settings dialog). Then open column announcement dialog and check the columns you wish to hear, then use the columns list to set column announcement order. The column announcement order is a list box with two buttons: move up and down."""),
"",_(u"""Once column order and included columns are defined, NVDA will use this information to build track item description text. This is done by repeatedly calling the column retriever routine for columns you wish to hear, then using the column order you defined to build parts of the description text (a combination of a list and str.join is used)."""),
"",_(u"""For example, if NVDA is told to announce title and artist (in that specific order), NVDA will first locate title, then will add artist information. This is then presented as, \"Title: some title, Artist: some artist\". It is also possible to suppress announcement of column headers, and this is controlled by the column header announcement checkbox in add-on settings."""),
"",_(u"""#### Track Columns Explorer: Retrieve information from specific columns"""),
"",_(u"""In add-on 7.0, it became possible to let NVDA announce information from specific columns. This is done by letting NVDA assign SPL Assistant, 1 through 0 (6 for Studio 5.0x) to a function to obtain information from specific column (slot); add-on 8.0 changes these commands to use Control+NVDA+number row. This is called Track Columns Explorer (usually termed Coloumns Explorer)."""),
"",_(u"""In addition to using column retriever routine in Track Dial, Columns Explorer needs to know Studio version in use, as Studio 5.1x shows columns not found in Studio 5.0x (this is checked when entering SPL Assistant as discussed later). Once column slots are defined, Columns Explorer performs the following:"""),
"",_(u"""1. Checks if you are indeed focused on a track item, and if not, it'll say \"not a track\"."""),
_(u"""2. Consults a list of column slots and locates corresponding column index for the slot in question."""),
_(u"""3. Uses column retriever routine to announce column header and content for the selected column slot."""),
"",_(u"""##### Optimization bonus: I've rearranged columns in studio 5.10..."""),
"",_(u"""Due to different control data structure in use, one can rearrange columns in Studio 5.10 and later. But how does NVDA know exactly which column is which? This is thanks to the fact that internal column position doesn't change. When you rearrange columns, you are changing the way columns are presented on screen. When column retriever function (described above) is invoked, Studio returns column content for a column index regardless of where this column is located on screen. Not only this makes Columns Explorer simpler to implement, it allows Track Dial to track (after manual intervention) column presentation changes on screen."""),
"",_(u"""#### Column Search: Finding text in specific columns"""),
"",_(u"""In the previous section, I mentioned that a single dialog performs double duty when talking about Track Finder. We'll now tour the other side of the coin: Column Search."""),
"",_(u"""Column Search dialog adds a second control to Track Finder: a list of columns. Once text is entered to be searched in a column, NVDA will use trackFinder routine (discussed earlier) to locate text in specific columns (I mentioned that trackFinder routine takes column(s) as the argument, and this is where this argument comes in handy). In fact, both regular Track Finder and Column Search uses the above column retriever routine to locate column text (the private linear search function introduced in Track Finder 2.0 locates text from specified columns, and for regular track finder, artist and title columns are examined). Just like the regular Track Finder, once search is done, it'll either move you to a track item or present an error dialog."""),
"",_(u"""So what causes one dialog to present both Track Finder and Column Search dialog? It's all thanks to the arguments passed into the find dialog constructor. The signature is:"""),
"",_(u"""	splmisc.SPLFindDialog(parent, obj, text, title, columnSearch=False)"""),
"",_(u"""The last argument (columnSearch) determines which version of the dialog to present. The object (obj) is needed to tell NVDA where to begin the search and to call the track finder routine defined in the object's app module."""),
"",_(u"""#### Track Place Marker: A variation of column search for finding filenames"""),
"",_(u"""Another feature that uses column routines is track place marker. You would drop a place marker at the current track (SPL Assistant, Control+K), move around the playlist, then move to the track with the marker set on it (SPL Assistant, K)."""),
"",_(u"""Once you drop a place marker, Studio app module will record the filename of the currently focused track, and when you wish to move to the marked track, NVDA will use column search routine to locate it. Unlike a typical column search, NVDA will call the private linear search routine directly and will select the column where filename is stored (in effect, you are asking NvDA to do a column search after choosing filename as the data you are looking for)."""),
"",_(u"""#### Vertical column navigation: just announce the column I want"""),
"",_(u"""Ever since implementing Track Dial, some broadcasters requested adding support for moving through tracks vertically (as in reading specific columns just like moving to a different row in a table). This also resolved an issue where pressing Control+Alt+up/down arrow keys caused the monitor to flip upside down. This is achieved by asking SPLTrackItem.reportFocus to announce just the column the user wants when Control+Alt+up/down arrow is pressed, all controlled by a hidden class variable. This feature not only works for vertical column navigation - it is also used when a broadcaster requests only one column be announced, and the column to be announced can be customed (not to be confused with column announcement order routine discussed above)."""),
"",_(u"""#### Track Tool: one routine, multiple app modules"""),
"",_(u"""Column retriever routine is not only employed by Studio app module, but is also used in Track Tool app module (part of the studio add-on). Track Tool's use of column retriever include Track Dial for Track Tool (same routine as the Studio app module and Studio must be running to use it) and announcing column information (Control+NVDA+1  through 0, now termed Columns Explorer for Track Tool)."""),
"",_(u"""### Few remarks"""),
"",_(u"""Of all the features in the StationPlaylist Studio add-on, column navigation is one of my favorites (besides Cart Explorer and encoder support and others). I enjoyed working with this routine and learned a few things about Windows API, as well as open possibilities not previously explorered before, such as Track Tool and Column Search. I hope that you'll find column navigation commands to be useful in your broadcasts."""),
"",_(u"""I would like to take this time to answer a question posed by some users and developers: Can NVDA be ported to other operating systems? No. The above column retriever routine is a prime example why this cannot be done easily: different operating systems use different API's, and porting NonVisual Desktop Access to other operating systems will involve significant architectural changes to use the new API's. In case of ReactOS, this isn't possible, as there are no stable foundation from which NVDA screen reader can exercise its full rights: accessibility API's are needed, stable driver development framework is needed, ability to run a program as a service must be ready and so on. Add to the fact that we have several add-ons relying on Windows API (including StationPlaylist Studio add-on) and you'll see the huge work involved in an attempt to port NVDA to other operating systems."""),
"",_(u"""## Microphone alarm and library scan: threads, threads and more threads"""),
"",_(u"""Of all the work done on Studio add-on, one of them stands out the most: background tasks. I spent many hours and months perfecting this concept, read documentation on this feature and learned a lot through this experience. Today, this work is used in various parts of the Studio app module and beyond, and we'll take a look at two most important result of this work: library scan and microphone alarm."""),
"",_(u"""### Brief feature overview"""),
"",_(u"""When you are producing a live show, you may forget that your microphone is active. The microphone alarm feature lets NVDA notify you if microphone has been active for a while. This happens even if you are using another program."""),
"",_(u"""Library scan comes in handy when you want to see the progress of a background library scan. Typically, you would initiate library scans from Insert Tracks dialog (press Control+Shift+R). NVDA will then tell you how the scan is going, and if you close Insert Tracks dialog, NVDA will continue to monitor library scans in the background."""),
"",_(u"""But there's more to it than a simple description when it comes to looking at internals of these features. As you'll see, these features use a concept that is gaining traction: running multiple tasks at once, or at least try to emulate it. We'll visit this concept first before returning to our regularly scheduled program of describing the internals of the two features above."""),
"",_(u"""### Recent trends in computing: more and more processors in a single computer"""),
"",_(u"""A decade ago, people thought a single core CPU was enough to run multiple programs. This involved the processor spending small fraction of a second devoted to each program. Nowadays, it has become common to see desktops, laptops, smartphones and other small devices using at least two cores (termed multi-core; two cores is dubbed \"dual core\"). As of 2017, many computers use processors with four cores (dubbed \"quad core\"), while enthusiasts prefer more cores (the current record holder for desktop computers (as of July 2017) is 18, held by Intel Core I9-7980XE, a 3 GHz unlocked processor which costs 2000 dollars; for servers where more cores are used, the current record holder is a group of eight processors (octa processor) called Intel Xeon E7-8895V3, with each processor boasting eighteen cores with base speed of 2.6 GHz)."""),
"",_(u"""Despite the fact that many computers come equipped with multi-core processors, not all programs take advantage of this. Python interpreter is one of those programs, and since NVDA is a Python-based screen reader and due to its operational architecture, many of its operations cannot take advantage of multiple processors. Fortunately, Python provides a way to simulate this - run certain tasks in the background, and this is utilized by NVDA and some of its add-ons as you'll see in this article on library scan and microphone alarm."""),
"",_(u"""### A gentle introduction to threads: multiple tasks at once"""),
"",_(u"""During normal business hours, a program will run from beginning to end with some interuptions (keyboard input, switching to a different part of the program and so on). However, there are times when the program will need to work with many things simultaneously, such as calculating distance between many points, adding multiple numbers at once, comparing many pairs of strings and so on. Fortunately, a mechanism called threads allow a program to do multiple things simultaneously."""),
"",_(u"""A thread is a procedure independent of other tasks. If one thread is busy with something, other threads can work on other tasks. The best analogy is multiple bank tellers in a bank: customers can talk to different tellers, with one teller working on updating customer records for a customer while another customer discusses fraudulent credit card charges with a different teller."""),
"",_(u"""A thread can be involved with parts of a task, devoted to a single task or multiple tasks. For example, an antivirus program could have multiple threads (workers) working independently of each other. One worker can display the overall progress of a scan, while other threads can scan multiple drives at once, with each thread devoted to scanning files and folders on separate drives. In NVDA world, multiple workers are involved to perform various tasks, including making sure NVDA is responsive, handling browse mode in different web browsers and so on."""),
"",_(u"""### Threads: a more geeky introduction"""),
"",_(u"""A thread (sometimes termed \"thread of execution) is an independent path of execution. A single process (app) can have as many threads as it desires (minimum is one for the main thread). Each thread can be asked to perform certain operations with other threads in parallel, which can range from a single, repetative task (part of a function) to being responsible for an entire module or a significant part of the program. In case of antivirus example above, each scanner thread is responsible for scanning an entire drive, with each of them reporting its progress to a manager thread which displays overall progress of a virus scan."""),
"",_(u"""Using threads means each thread can execute on a processor core on a multi-core system. Because of this, many people would want many programs to take advantage of this and finish their jobs faster. However, threads introduce disadvantages, namely many days spent designing careful coordination routines between threads, preventing attempts by multiple threads to change a critical value that a manager thread depends on (called race condition) and so forth."""),
"",_(u"""### Python's way of managing threads and the threading module"""),
"",_(u"""Python interpreter (and programs which uses them, including NVDA) is not exactly multithreaded. Because of internal issues, Python uses so-called global interpreter lock to prevent multiple threads from messing with each other. One way to bring true parallelism in Python is use of multiprocessing module (multiple Python interpreters, each one devoted to a single task), which has its own advantages and drawbacks (NVDA does not ship with multiprocessing module in the first place)."""),
"",_(u"""To manage threads, Python programs (including NVDA) use Python's threading module. This library includes various ways of managing threads, including defining which function can execute in a separate thread, coordinating sharing of information between threads (locks, semaphores (resource access counter) and so on), and letting a thread run its task after waiting for a while (called timers). Even with multiple threads defined, NVDA is mostly single-threaded (serial execution)."""),
"",_(u"""To use threads, a programmer will define the thread type (regular thread, timer and so on), define some properties and tell the thread which routine to execute. Once the thread is defined, the start (thread.start) method is called to let the thread do its work."""),
"",_(u"""### Threads in Studio app module"""),
"",_(u"""For the most part, Studio app module uses only one thread (NVDA's main thread) to do its job. However, there are times when multiple threads are used - up to three can be active at a time: NVDA's main thread (announcing status changes, alarms, Cart Explorer and others), microphone alarm (a timer) and library scan (a background thread). Another situation threads are used is when background encoder monitoring is enabled (see the encoder routines article for details and use of threads there)."""),
"",_(u"""The main reason for using threads is to prevent background tasks from blocking user input (commands will not work when a long running task is run from the main NVDA thread). This is more noticeable when library scan is active as you'll find out soon. For now, let's take a look at microphone alarm."""),
"",_(u"""#### Microphone alarm: A timer duo waiting to do their work"""),
"",_(u"""Simply put, microphone alarm is a timer (akin to a countdown timer). When the microphone becomes active, Studio app module will tell a timer thread to come alive. This timer's only job is to play the alarm sound and display a warning message, and it will wait a while (microphone alarm value in seconds; for example, five seconds)."""),
"",_(u"""The master switch which flips the microphone alarm timer is:"""),
"",_(u"""alarm = threading.Timer(micAlarm, messageSound, args=[micAlarmWav, micAlarmMessage])"""),
"",_(u"""Where \"micAlarm\" denotes how long this timer will wait and the second argument is the task to be performed (messageSound function). If microphone alarm is off (value is 0), this switch will be left alone forever (turned off until you enable the alarm by specifying a value above 0)."""),
"",_(u"""However, microphone alarm is more than a timer: a unique feature of timers is responding to events (a cancel event, that is). When the microphone becomes active, microphone alarm timer will become active. If you happen to turn off your microphone before microphone alarm kicks in, NVDA instructs microphone alarm to quit (timer is canceled). In other words, the \"real\" master switch is status change, and one of the activities performed by name change event handler (event_nameChange function described earlier) is to manage microphone alarm timer via doExtraAction method (in fact, microphone alarm and Cart Explorer are managed from this function)."""),
"",_(u"""In some cases, NVDA can be told to periodically notify you that microphone is active. If this is the case, NVDA will start a new timer (this time, wx.PyTimer) that'll run a function to do just that periodically after the initial microphone alarm is sounded. Just like the master microphone alarm timer, this time will quit if microphone is turned off."""),
"",_(u"""#### Library scan: a unique combination of Studio API and a background thread"""),
"",_(u"""When NVDA is told to keep an eye on background library scanning, it calls up another thread to perform this duty. This thread will ask Studio for number of items scanned so far and take appropriate action after scanning is complete (in fact, multiple helper functions are used)."""),
"",_(u"""The library scan routine is performed as follows:"""),
"",_(u"""1. NVDA will make sure you are not in Insert Tracks dialog (if you are, background library scan routine will not be invoked, as event_nameChange will perform this duty instead)."""),
_(u"""2. If you do close Insert Tracks while a scan is in progress, or invoke library scan from SPL Assistant (Shift+R), NVDA will instruct a thread to keep an eye on scan progress in the background(see below for signature) to allow you to use Studio commands and to let you hear scan progress from other programs."""),
_(u"""3. Library scan thread will ask Studio to return number of items scanned (this is done every second) and will store the result for record keeping."""),
_(u"""4. After the scan result is obtained, the thread will check where you are in studio, and if you are back in Insert Tracks dialog, the thread will terminate (see step 1)."""),
_(u"""5. Every five seconds, library scan thread will call a private function (which wants to see how many items were scanned and current library scan announcement setting) to announce library scan results as follows:"""),
_(u"""A. If you tell NVDA to announce scan progress, NVDA will say, \"scanning\" and/or play a beep (if told to do so)."""),
_(u"""B. If NVDA is told to announce scan count, number of items scanned so far will be announced (again with or without a beep)."""),
_(u"""C. This reporter function will not be invoked if you tell NVDA to ignore library scan completely or ask it to interupt you only when the overall scan is complete (you can press Alt+NVDA+R to cycle through different library scan announcement settings)."""),
_(u"""6. Once library scanning is complete (after checking scan result value every second and seeing that the previous scan result and the current one have same values), NVDA will announce scan results (in some cases, number of items scanned will be announced). In Studio 5.10 and later, the library scan counter will not be defined when scan completes, which is more efficient than keeping track of equalities."""),
"",_(u"""You can imagine what would have happened if the above operation was not a background task: cannot perform other NVDA commands until library scan is complete, cannot cancel this operation and what not. And this is the signature of the thread that performs the above operation:"""),
"",_(u"""libraryScanner = threading.Thread(target=self.libraryScanReporter, args=(_SPLWin, countA, countB, parem))"""),
"",_(u"""There are important arguments in use: the function (task) to be performed and arguments for this function. The most important argument is the last one: Studio 5.0x and 5.10 expects different arguments when told to report number of items scanned so far."""),
"",_(u"""Despite limitations of Python's threading routines, if used properly, it can open new possibilities, and you saw some of them above: microphone alarm and background library scan. Use of threads in the Studio app module also allows NVDA to be responsive while using Studio and allows background tasks to be faithful to the tasks at hand. We'll come back to threads when we talk about encoder connection routines. There is a more \"magical\" feature we'll visit, and this is our next stop on the SPL Studio Add-on Internals: Cart Explorer."""),
"",_(u"""## The magic behind Cart Explorer"""),
"",_(u"""A live radio broadcast would not be complete without jingles. This can range from station promotions (often called \"promos\"), advertisements, jingles to convey the mood of a show, segment jingles and more. Many station automation programs, including StationPlaylist Studio includes facilities to manage jingles (sometimes called carts), including defining a cart to be played when cart keys are pressed, announcing the name of the playing cart and saving uer specific carts to a safe location."""),
"",_(u"""For blind broadcasters, one of the things they worry is pressing a wrong jingle key by accident, thus script writers were asked to implement a way for broadcasters to learn which carts are assigned to cart keys. As of time of this post, all three screen readers (JAWS for Windows (script author: Brian Hartgen), Window-Eyes (script author: Jeff Bishop), NVDA (script author: Joseph Lee (I, the author of this article)) includes a feature to learn jingle assignments. As this is a series of articles on internals of an NVDA add-on, I'll give you an overview of what happens when you activate and explore cart assignments (in fact, this section was the most interesting and feedback driven portion of the add-on). Along the way you'll learn where Cart Explorer (NVDA's version of cart learn mode) draws its power and why it is very important."""),
"",_(u"""### Carts in StationPlaylist Studio"""),
"",_(u"""Studio comes in three editions: Demo (same as Pro but for limited time trial), Standard and Pro. The first user visible difference between Standard and Pro is number of cart assignments: Standard can store 48 jingles, while Pro can work with 96 of them."""),
"",_(u"""To play jingles, a broadcaster would use Cart Edit Mode Control+T), then assign a hotkey to a file. For Studio Standard, you can assign F1 through F12 by themselves or in combination with Control, Shift or Alt. In Demo and Pro, number row can be assigned (1 through 9, 0, hyphen (-) and equals (=) either by themselves or in combination with Control, Shift or Alt, for a grand total of 96 jingles). Once jingles are assigned, they will appear under cart menus (there are four cart menus, one for standalone keys (called main) and one each for Control, Shift and Alt)."""),
"",_(u"""### Where does Studio store carts?"""),
"",_(u"""Studio's \"carts\" are housed in Studio installation folder. There are four cart files (called banks) in use: a .cart file for each of the cart banks (main, Shift, Control, Alt). During normal business hours, Studio will work with these four banks unless told by a broadcaster to load carts from a different cart bank file."""),
"",_(u"""### Cart Explorer: my own Summer of Code"""),
"",_(u"""It was a hot day in June 2014 when I sat down to design a way to let broadcasters learn cart assignments. Since I was developing add-on 3.0 back then, I decided that this feature should be a top priority feature to be included in the upcoming release."""),
"",_(u"""When I started writing this feature, the first thing I thought about was its name. I felt \"cart learn mode\" didn't really convey the picture - after all, I reasoned that broadcasters will use this feature to explore cart assignments. Thus the name \"Cart Explorer\" was chosen - in effect, when you use this feature, you are browsing jingle assignments in preparation for a show."""),
"",_(u"""Next, I read JAWS script documentation to get a glimpse of how Brian has managed to implement cart learn mode. In JAWS scripts, script settings are stored in the user configuration directory (typically this is %systemdrive%\\Users\\%username%\\AppDate\\Roaming\\Freedom Scientific\\JAWS\\%JAWSVersion%\\Settings\\Enu; Brian, please correct me if I'm wrong). A section of this script configuration file is dedicated to carts, and JAWS scripts use a map of key names and cart values to announce cart information while cart learn mode is active."""),
"",_(u"""Based on this information, I started writing an ini file parser, seeing that broadcasters would store cart assignments in a configuration database. This was prone to a number of errors, including wrong cart name format, nonexistent cart key assignment, invalid configuration format and others. I once wrote a blog post (on this blog) explaining how this worked (times have changed, as you'll see very soon)."""),
"",_(u"""Then I became curious as to how Studio stores its own cart banks, and naturally, I opened the folder where carts were stored and opened each .cart file in Notepad++ (a very handy text editor). From reading the cart bank format (explained below), I thought it might be useful to write a cart bank file parser. Thus I resumed writing Cart Explorer routines, this time incorporating the cart bank format, not forgetting to handle suttle errors, and this is the routine used in add-on releases up to 5.x (6.0 uses a completely different yet related routine, as you'll see)."""),
"",_(u"""While writing the first version of Cart Explorer, I realized that this feature needed some real life testing, so I asked a seasoned blind broadcaster to test this feature. We spent a better part of Independence Day writing, debugging and rewriting this routine until we felt satisfied. In the end, our hard work paid off, as you can see in subsequent paragraphs."""),
"",_(u"""### Introducing Cart Explorer version 1"""),
"",_(u"""Cart Explorer version 1, shipped as part of add-on 3.0, worked as follows:"""),
"",_(u"""1. You press Control+NVDA+3 to activate Cart Explorer. When this happens, NVDA will make sure you are in main playlist viewer, then it will set a flag indicating that Cart Explorer is active."""),
_(u"""2. NVDA will then open and parse cart bank files, storing cart assignments in a dictionary of cart keys to cart names. This parser also takes care of some corner cases, including skipping unassigned carts and determining Studio edition in use. Once carts were parsed, NVDA says, \"Entering Cart Explorer\", and if errors occur, NVDA will inform you that it cannot enter Cart Explorer (this happens if the cart bank file doesn't exist)."""),
_(u"""3. While using Cart Explorer, if you press a cart key, NVDA will look up the name of the key in the carts dictionary, and announce the cart name associated with it (if found, otherwise, NVDA says, \"cart unassigned\")."""),
_(u"""4. It so happens that some people will activate Cart Edit Mode to modify cart assignments while in the middle of exploring carts. If this happens, NVDA will remind you (via doExtraAction function used by name change event) that Cart Explorer is active, and when Cart Edit Mode is turned off, NVDA will ask you to reenter Cart Explorer (this was done to parse newly updated cart bank files)."""),
_(u"""5. You press Control+NVDA+3, and NVDA will clear carts dictionary, thereby leaving Cart Explorer."""),
"",_(u"""But there was a major concern with this approach: what if a future version of Studio uses a different cart bank format? Thus, I revisited cart bank files again in July 2015, and this time, I noticed a familiar structure: comma-separated values, and thought about a possibility that a spreadsheet application such as Excel would handle this gracefully. To test my hypothesis, I opened .cart files in Excel, and voila, it presented itself just like any CSV file. Thus I worked on modifying cart parsing routine, this time using Python's CSV module to parse \"cart\" files (cart bank files are really CSV files in disguise). This new routine (described below) made its appearance as part of add-on 6.0."""),
"",_(u"""### The magic behind Cart Explorer version 2: handling CSV files"""),
"",_(u"""Since Python comes with a library to handle CSV files and since cart banks are CSV files, I rewrote Cart Explorer routine (a function in splmisc module which returns the carts dictionary) as follows:"""),
"",_(u"""1. When entering Cart Explorer, Car Explorer preparation routine (splmisc.cartExplorerInit) will take a snapshot of your user name and Studio edition (Studio's title bar indicates which version is in use). Then it initializes the carts dictionary and stores the Studio edition in use."""),
_(u"""2. Next, the preparation function will write down names and paths to cart banks. In case a user other than default user is using Studio, it'll modify the cart file names to match the name likely to be used by Studio to present user-specific cart banks. These cart names form one part of the cart bank path (the other part is the path to the folder where the carts live, obtained by using an environment variable)."""),
_(u"""3. For each cart bank, NVDA will ask Python to parse the cart bank as a CSV file (csv.reader; when finished, it returns a list of lists, with each list representing one row of a CSV table)."""),
_(u"""4. Once the csv version of the selected cart bank is ready, the row containing cart keys and cart names, together with the cart bank modifier and the carts dictionary are sent to a helper function (part of splmisc module) that will do the following:"""),
_(u"""A. Depending on Studio edition, this helper will work with only the first half (Standard will only work with function keys, which are the first twelve columns of this row) or the entire row (the rest are number row keys) will be processed."""),
_(u"""B. Depending on column position (items in the row list), it will see if function keys or number row keys should be assigned to the selected cart entry. This routine also checks the type of the cart bank (modifiers or none (main)) and modifies the cart key name accordingly."""),
_(u"""C. Next, the helper routine will try to locate the name of the jingle assigned to the cart key in question, and if there is one, it'll add the cart key and jingle name pair into the carts dictionary."""),
_(u"""5. Back at the cartExplorerInit function, if no erorrs were found while parsing a cart bank, it'll move onto the next one, otherwise it will inform the Studio app module by modifying a flag value in the carts dictionary (stored as an integer, representing number of cart bankks with errors)."""),
_(u"""6. By now cartExplorerInit is desperate to pass the carts dictionary to someone, and this someone turns out to be the Studio app module - once picked up by the app module, carts dictionary is hired by you to look up cart names for cart keys while you use Cart Explorer (to fire the carts dictionary, simply deactivate Cart Explorer by pressing Control+NVDA+3)."""),
"",_(u"""In effect, the routine above (the \"magic\" behind Cart Explorer) replaced a hand-written cart bank parser and simplified the add-on code (I regret not investigating CSV module in 2014). As far as user experience is concerned, this is same as Cart Explorer 1, with the difference being the parsing routine. With the addition of splmisc.cartExplorerInit, the majority of the splmisc module (miscellaneous services, containing the Track Finder/Column Search combo dialog, column retriever and Cart Explorer preparation tool) was completed. But the innovations continued."""),
"",_(u"""### Enter Cart Explorer version 3: file modification timestamps"""),
"",_(u"""There were two issues with Cart Explorer version 2: confusing statements when cart insert mode was active, and inability to detect that cart editing is finished. Cart insert mode allows broadcasters to press the cart command to have the file inserted into the playlist as a regular track. Inability to detect cart edit completion meant one had to reenter Cart Explorer to view updated cart assignments."""),
"",_(u"""The first issue was solved by telling users that Cart Explorer was active while cart insert mode was active. The resolution to the second issue required a bit of work, and involved rewriting parts of Cart Explorer (now version 3), which is included as of add-on 17.01 (optimized in 17.04). The biggest difference is recording file modification timestamps for carts when carts dictionary is being built (see above), and if cart edit is turned off, checking the timestamps of newly modified cart banks against previous timestamps (when cart edit is off, when cart assignments have changed, cart files are written back to disk) and skipping unmodified cart banks. In spring 2017, this was further optimized by allowing carts dictionary to be modified on the fly (only changed bits will be modified, including possible new assignments, changes and deletions). This means no more need to reenter cart Explorer when cart assignments have changed, a huge relief for broadcasters who need to change cart assignments for holidays or other special occasions."""),
"",_(u"""### Few remarks"""),
"",_(u"""Cart Explorer has come a long way; from a simple suggestion to the CSV parsing routine above to checking timestamps for cart assignment changes, Cart Explorer has changed to meet the needs of broadcasters using Studio and NVDA. I would like to improve this further in future releases (another suggestion I received was ability to specify cart file names for individual banks, and I'm thinking about implementing this in the near future)."""),
"",_(u"""One of the things you may have noticed as you read this article so far is how I and other developers continue to research better ways of accomplishing something. You also saw a glimpse of how developers and users shape a feature and how much work is involved to bring a feature suggestion to life. These activities (research and feature development collaboration) are just two of the pillars supporting Studio add-on for NVDA, and highlights how design philosophy and product development approach affects future course of product development."""),
"",_(u"""This ends our detailed tour of internals of major features in Studio app module. When we come back, we'll visit our friend from the past: SPL Assistant layer and inner workings of various layer commands."""),
"",_(u"""## All about StationPlaylist Assistant layer"""),
"",_(u"""You may recall visiting two layer command sets in a previous article: SPL Controller and SPL Assistant, the former used to perform Studio functions from any program and the latter for status announcements. I mentioned throughout this series that we'll tour these layer sets, and we'll start with SPL Assistant layer."""),
"",_(u"""### Talk about layer commands"""),
"",_(u"""One of the common features of Studio scripts for JAWS, Window-Eyes and NVDA is extensive use of layer commands. This was popularized by JAWS and its Studio layer (grave key). Some of the benefits of this approach include saving keyboard commands, reminding users as to commands available in Studio and so on."""),
"",_(u"""### Birth of SPL Assistant layer"""),
"",_(u"""As mentioned previously, since version 1.0 in January 2014, Studio add-on comes with two layer commands to represent the global plugin and the studio app module. In case of Studio app module and its layer set (SPL Assistant), I borrowed some commands from both JAWS and Window-Eyes scripts with some notable differences, namely some commands and how things were announced."""),
"",_(u"""When I sat down to design this layer set, I felt it would be helpful for broadcasters if most of the Assistant layer commands borrowed from Studio command assignments. For example, a broadcaster will press M to toggle microphone on and off, and in SPL Assistant layer, pressing M announces microphone status. Another example was Cart Edit Mode - pressing Control+T in Studio will toggle this, and pressing SPL Assistant, T will announce whether this mode is on or off (the reason for assigning T for Cart Edit Mode status will be discussed later)."""),
"",_(u"""Originally, one could invoke SPL Assistant layer by pressing Control+NVDA+grave key from within Studio. However, some NVDA translators told me that this key combination is used for NVDA screen reader commands in their language. Thus, in add-on 2.0 (late spring 2014), I decided to remove this command, which means in order for you (broadcasters) to invoke SPL Assistant layer, you need to go to Input Gestures dialog while focused in Studio, expand StationPlaylist category and look for the Assistant entry (I personally use Control+NVDA+grave, and in recent add-on development builds, I told Studio add-on to let SPL Controller layer command (discussed later) to invoke Assistant layer)."""),
"",_(u"""Another addition to SPL Assistant layer is ability to emulate layer commands provided by other screen readers. This is achieved by using gestures map for each screen reader (NVDA included), with the correct gestures map chosen when entering SPL Assistant layer. Currently, in addition to default NVDA layout, the add-on supports JAWS for Windows and Window-Eyes layer commands."""),
"",_(u"""### Categorizing SPL Assistant commands"""),
"",_(u"""Once you invoke SPL Assistant layer (a beep will be heard), you can perform one of the following operations:"""),
"",_(u"""* Status announcements (automation, microphone, etc.)."""),
_(u"""* Tools (library scan, track time analysis, obtaining playlist snapshots, columns explorer and so on)."""),
_(u"""* Configuration (switching broadcast profiles)."""),
_(u"""* Ask for help (opening SPL Assistant help dialog or the online user guide)."""),
_(u"""* Checking for add-on updates (manually)."""),
"",_(u"""For the first two categories, they can be divided further into commands which uses studio API (via statusAPI function discussed in a previous article), ones using Windows API (Columns explorer) and those relying on object navigation (multiple components are involved and is sensitive to user interface changes). We'll go through each of these categories in turn."""),
"",_(u"""#### SPL Assistant 1: status announcements"""),
"",_(u"""These commands allow you to obtain various status information such as title and duration of the next track, cart edit mode status and so on. These can be divided into those which uses object navigation (old style) and Studio API (new style) commands. In some cases, both methods are available and the appropriate version is chosen based on Studio version in use."""),
"",_(u"""The following commands (sorted alphabetically) utilize Studio API to perform needed functions:"""),
"",_(u"""* E: Announces if any metadata streaming URL's are defined."""),
_(u"""* H: Duration of tracks in the selected hour."""),
_(u"""* Shift+H: Duration of the remaining tracks in the hour slot."""),
_(u"""* P: Playback status."""),
_(u"""* Shift+1 through Shift+4 and Shift+0: Checks metadata streaming status for each URL (0 is DSP encoder). See below for details."""),
"",_(u"""Note that playlist remainder announcement (SPL Assistant, D) was part of this category until add-on 6.x. In add-on 7.0, due to refactoring work surrounding this command, it has been moved to tools category."""),
"",_(u"""##### A step sideways: Metadata streaming"""),
"",_(u"""Studio can be told to stream track metadata to five URL's: the DSP encoder address and four additional URL's (Options/Now Playing). By default, DSP encoder address is used to send metadata information."""),
"",_(u"""One of the activities Studio app module performs when starting is to check if metadata streaming is enabled on any URL's. In addition, NVDA can tell you status of metadata streaming for all uRL's (SPL Assistant, E) or for individual addresses (SPL Assistant, Shift+1 through Shift+4 and Shift+0). This is done through a metadata management and announcement function (metadataAnnouncer) that gathers streaming flags for URL's and presents status messages and connects to predefined servers if you tell Studio to connect to streaming servers."""),
"",_(u"""When the metadata announcer is called, NVDA does the following:"""),
"",_(u"""1. NVDA will look at connection flag (reminder = True, but in reality, this is mostly used as the connection flag), and if the flag is set, connects to a predefined set of streaming URL's."""),
_(u"""2. Gathers metadata streaming flags, starting with the DSP encoder."""),
_(u"""3. The announcer will count number of metadata enabled URL's used to format the status message."""),
_(u"""4. announces the status message. This message isn't announced right away if this function is called when the app module starts - after a short pause, the status message will be announced and an alarm sound will be played. This is done to make sure this message is the last message to be announced when Studio starts."""),
"",_(u"""##### Revisiting the past: object navigation"""),
"",_(u"""Before the new style routines were written, all commands used object navigation. Typically, the command will use a helper function and an object map to locate the needed object and will announce what you are looking for (typically obj.name or an error message). The process was as follows:"""),
"",_(u"""1. The Studio app module contains a map of indecies where the object lives in relation to the foreground window. For example, for a given object, if index was 0, NVDA nows that the object is the first child of the foreground object. Technically, it is a dictionary of lists, with each list item (indecies) corresponding to the version of Studio the add-on supports."""),
_(u"""2. To fetch needed objects and to record the command type, a number of constants are defined in the app module (all integers, denoting what you wish to hear). These constants serve as keys to the object index map."""),
_(u"""3. After entering SPL Assistant layer and once you press one of the commands below, NVDA will do the following:"""),
_(u"""	1. Each command will obtain the object in question by calling object fetcher (status function) with the announcement type as the parameter (status(SPLConstant; for example, for cart edit mode, the signature is self.status(self.SPLPlayStatus), with the constant denoting a status bar)."""),
_(u"""	2. The object fetcher (status function) will first consult an object cache (part of the Studio app module) hoping that the needed object is ready for use (for performance reasons)."""),
_(u"""	3. If the object was not cached, the fetcher will first write down the foreground window, then use the directions specified in the object index map (the constant passed into the status function is the key to this map and different values are returned based on Studio version) to locate, cache and return the object in question (in that order)."""),
_(u"""	4. Back at the routine for the command, it is up to the routine as to what to do with it (sometimes, the actual object is a child of the just returned object)."""),
"",_(u"""The commands which utilizes object navigation steps above include:"""),
"",_(u"""* A. Automation."""),
_(u"""* C: Title of the currently playing track."""),
_(u"""* I: Listener count (I have tried using Studio API to obtain this information, but after experimenting with it, object navigation routine was more stable)."""),
_(u"""* L: Line in."""),
_(u"""* M: Microphone."""),
_(u"""* N: Title and duration for the next track."""),
_(u"""* Shift+P: Track pitch."""),
_(u"""* R: Record to file."""),
_(u"""* S: Track scheduled for."""),
_(u"""* Shift+S: Duration of selected tracks in the current hour slot."""),
_(u"""* T: Cart Edit Mode (I assigned T to this command for efficiency reasons)."""),
_(u"""* U: Studio up time."""),
_(u"""* W: Weather and temperature (if configured)."""),
_(u"""* Y: Playlist modification."""),
"",_(u"""Note that in Studio 5.20 and later, some of these (such as automation) uses Studio API."""),
"",_(u"""For example, if you press A to obtain automation status from Studio 5.10:"""),
"",_(u"""1. Invoke SPL Assistant, then press A."""),
_(u"""2. The status function (object fetcher) is called, taking the status bar constant (SPLPlayStatus, which is 0) as the key to the index map."""),
_(u"""3. Object fetcher will see if the status bar object (cache dictionary with the key of 0) has been cached. For this example, it isn't."""),
_(u"""4. Seeing that the status bar isn't cached, object fetcher will now look at the index map and will decide which column to read (for this example, it is column 2 (index 1)). The column records the child position of the status bar relative to the foreground window (in our case, index is 6 or the seventh child)."""),
_(u"""5. Once the child object position index is obtained, object fetcher will locate the actual object and cache it (self._cachedStatusObjs[infoIndex] = fg.children[statusObj]), then returns the object to the automation announcement routine."""),
_(u"""6. Back at the script routine, NVDA will be reminded that it needs to look at one of the object's children (status bars can contain child objects if exposed by accessibility API's), then will announce one of it's contents (second child object, which records automation status)."""),
"",_(u"""In Studio 5.20 and later:"""),
"",_(u"""1. Invoke SPL Assistant, then press A."""),
_(u"""2. Calls Studio API to retrieve the given status flag (in this case, 1, which records automation status)."""),
_(u"""3. A lookup table with possible status bar messages is then consulted, and the appropriate message based on status flag and value is retrieved and announced."""),
"",_(u"""Not all status bar messages will use Studio API and status messages table. The lone exception is cart mode status, which requires consulting two flag values returned by Studio to construct the actual announcement (cart edit mode on/off and whether cart insert mode is active)."""),
"",_(u"""#### SPL Assistant 2: tools"""),
"",_(u"""These are miscellaneous commands in SPL Assistant, and three of them use Studio API:"""),
"",_(u"""* D: Remaining time for the opened playlist."""),
_(u"""* K: Moves to a marked track. This was discussed in column routines and place marker sections."""),
_(u"""* Control+K: Sets track place marker. Consult the place marker section to learn how it works."""),
_(u"""* Shift+R: Library scan. This is a convenience function to start library scan in the background, useful if you have added new tracks from a number of folders via Studio Options dialog. Consult a previous article on library scan for details on library scan internals."""),
_(u"""* 1 through 0 (6 for studio 5.0x): Columns Explorer (discussed earlier). Unlike other commands in this set, this routine uses Windows API only."""),
_(u"""* F8: Obtains playlist snapshot information for the currently loaded track. This feature uses a combination of Windows and Studio API's."""),
_(u"""* F9: Marks the current position of the playlist as start of track time analysis (more on this feature below)."""),
_(u"""* F10: Performs track time analysis (add-on 6.0)."""),
"",_(u"""##### Track time analysis: Duration of \"selected\" tracks"""),
"",_(u"""A few months ago, during a Skype chat with a number of add-on users, someone suggested a feature where NVDA will tell you how long it'll take to play selected tracks. Since I was familiar with this concept from JAWS scripts, I decided to work on it as part of add-on 6.0."""),
"",_(u"""The resulting routine (which is available if you are focused on the main playlist viewer with the playlist loaded) is as follows:"""),
"",_(u"""1. Move to the position in a playlist to mark as start of track time analysis."""),
_(u"""2. Enter SPL assistant, then press F9."""),
_(u"""3. Move to another track in the playlist, open SPL Assistant then press F10. NVDA will then:"""),
"",_(u"""A. Determine analysis range. For most cases, it'll be top to bottom analysis, but in some cases, it could be reverse (bottom to top). Also, a variable to hold total duration will be prepared."""),
_(u"""B. For each track in the analysis range, NVDA will obtain file name and track duration via Studio API. Once the track duration is received, it is then added to the total duration variable."""),
_(u"""C. Once time analysis (calculating total duration) is done, NVDA will announce number of tracks selected and the total duration using mm:ss format."""),
"",_(u"""If you are a seasoned NVDA user, you may have noticed a familiar pattern: the command to set a marker to copy review cursor text is NVDA+F9, and you would move to a different location and press NVDA+F10 to copy the selected text to the clipboard. Replacing the NVDA modifier key with SPL Assistant produces the commands above: F9 to mark current position for time analysis, and F10 to perform the actual calculation. I intentionally chose these two function keys to provide consistent experience and to reenforce concepts used in NVDA screen reader: review cursor."""),
"",_(u"""##### Playlist remainder announcement"""),
"",_(u"""Until add-on 6.x, playlist remainder announcement was based on Studio API. However, it was found that this \"remainder\" was actually the remaining time within the selected hour slot. To get around this, in add-on 7.0, this routine was rewritten to take advantage of Track Dial introduced in add-on 5.0 (see Track Dial section above)."""),
"",_(u"""Technically, a combination of column content fetching and track navigation routines are used to accomplish this. When SPL Assistant, D is pressed, NvDA will write down the focused track and will move down the playlist (starting from the focused track), recording the segue (total track duration minus crossfade). Once playlist navigation is complete, the total duration is then sent to time announcement routine (see above) for processing (converted to hours, minutes and seconds format)."""),
"",_(u"""#### SPL Assistant 3: configuration"""),
"",_(u"""There is another function key assigned to SPL Assistant: pressing F12 will switch to an instant switch profile (if defined). We'll come back to what is meant by \"instant switch profile\" and the mechanics of it (and internals of SPL Assistant, F12) in the next article."""),
"",_(u"""#### SPL Assistant 4: getting help"""),
"",_(u"""I believe that a product isn't complete without a good quality documentation. For this reason, SPL Assistant provides two commands to help you use the layer commands or the add-on itself. They are:"""),
"",_(u"""* F1: Displays a dialog presenting a list of SPL Assistant layer commands."""),
_(u"""* Shift+F1: Opens the online user guide (os.startfile)."""),
"",_(u"""#### SPL Assistant 5: Checking for add-on updates"""),
"",_(u"""Pressing Control+Shift+U after entering SPL Assistant layer will cause the add-on to check for add-on updates. Unlike the automatic update check process described earlier, this one is a manual check, thus it'll perform additional actions such as stopping the automatic update check timer before actually checking for updates. Another difference is that this command will display a results dialog if there are no updates or other errors are encountered, whereas in automatic check mode, they are not shown."""),
"",_(u"""### A surprise: some Assistant layer commands can be invoked without entering the layer first"""),
"",_(u"""There are times when a broadcaster will need to obtain certain information quickly. So the question becomes, \"is there a way to announce something without first invoking Assistant layer?\" Yes, you can assign a custom command for the following Assistant commands:"""),
"",_(u"""* Name of the next track."""),
_(u"""* Name of the current track."""),
_(u"""* Weather and temperature."""),
_(u"""* Playlist snapshots."""),
_(u"""* Track time analysis marker."""),
_(u"""* Track time analysis."""),
"",_(u"""For these routines, an extra step is performed to make sure that SPL Assistant flag is turned off automatically after the shortcut for these routines are pressed. Without this step, you might end up with a situation like the following:"""),
"",_(u"""1. You invoke Assistant layer."""),
_(u"""2. You then press the shortcut key (not the layer counterpart) for the layer command you wish to use."""),
_(u"""3. You press another key which may announce something else, or you hear the same thing twice if you do press the layer command counterpart to the command you have pressed. In effect, you have invoked two layer commands in one sitting (the purpose of the layer set is to let you hear one announcement at a time)."""),
"",_(u"""## Introducing configuration facilities: add-on settings dialog and broadcast profiles"""),
"",_(u"""We have arrived at our last station stop for Studio app module internals: configuration management. This facility allows a broadcaster to configure various options such as alarms, column announcement order and so on, as well as package settings for a show as a broadcast profile to be invoked during the show. Along the way you'll learn how NVDA screen reader stores various settings, what happens if something goes wrong and get into internals of how broadcast profiles work."""),
"",_(u"""### ConfigObj: NVDA's configuration manager assistant"""),
"",_(u"""NVDA uses ConfigObj library to manage settings. This Python module, inspired by Python's own Config Parser, allows developers to store settings in a text file, read and interpret settings and validate options against default configuration options."""),
"",_(u"""NVDA comes with a collection of default options. They live in source/config/__init__ and are used for various things, including presenting preferences, validating user configuration and so on. The config management module also includes facilities to handle profiles (a package of user settings to be used in an app, during say all or reserved for manual activation)."""),
"",_(u"""### NVDA configuration profiles: multiple configuration files, one online database"""),
"",_(u"""A number of users asked NV Access if it would be possible to have profiles where certain settings can take effect while one is using apps or during say all. NV Access listened and introduced configuration profiles in late 2013. As of August 2015, one can create a manual or an automated (triggered) profile, with the latter further divided into say all profile and app-specific one."""),
"",_(u"""Configuration profiles involve a few support routines and a careful coordination between configuration files. In essence, each configuration profile (stored in profiles folder in user configuration folder) is a snapshot of differences between the profile and the main user configuration file (named nvda.ini). When a profile becomes active, NVDA will load the profile file associated with the given profile and modify user settings according to values stored in the newly activated profile, and wwill record the name of the profile file to remind itself as to which profile is active (the default user configuration profile is named \"normal configuration\" with the file name of nvda.ini)."""),
"",_(u"""What if settings had errors? As part of the startup routine (portions of main function (source/core.py) prior to entering the main loop), NVDA will display a configuration error dialog if it detects serious issues with configuration values (in reality, ConfigObj notifies NVDA of this problem). You'll see this is also implemented in the Studio app module to deal with add-on configuration issues."""),
"",_(u"""### All about Studio add-on Configuration Manager"""),
"",_(u"""Until recently, Studio app module handled all add-on configuration routines. With the advent of add-on 5.0 which introduced add-on settings dialog, configuration management routines were split into a dedicated Configuration Manager (splstudio.splconfig). The new module takes care of configuration routines, including validating the user configuration, presenting add-on settings dialog and other dialogs inside it, handling broadcast profiles and more. In add-on 7.0, routines pertaining to configuration dialog were split into splconfui module. We'll cover each routine in this article."""),
"",_(u"""### How settings are loaded, used and saved"""),
"",_(u"""As mentioned in the chapter on life of the Studio app module, one of the things the app module does is load the add-on configuration database by calling splconfig.initialize function. The job of this function is to load the add-on configuration map from various places (for add-on 5.x, it will be the main configuration map only, while 6.0 also searches appModules/profiles folder to load broadcast profiles). The format of the configuration file is that of a typical ini file, and as far as NVDA is concerned, it is a dictionary."""),
"",_(u"""When the configuration database is ready, Studio app module will then use values stored in this settings dictionary to perform various tasks, including microphone alarm, announcing listener count and so on. If multiple profiles are defined, NVDA will start with the first configuration map (normal profile), and the active profile is denoted by splconfig.SPLConfig map (more on profiles in a moment)."""),
"",_(u"""After you are done using Studio, close Studio so settings can be saved to disk. This involves saving individual profiles, copying global settings to the normal profile and saving the normal profile to disk."""),
"",_(u"""### The Studio Add-on Settings Dialog"""),
"",_(u"""Studio app module allows you to configure various settings in two ways: via a shortcut key (discussed in an article on configuring basic settings) or via the settings dialog. When you use a shortcut key to change settings, NVDA will look up the value for the setting, change it, announce the new setting and store the newly changed value in the settings map."""),
"",_(u"""Alternatively, you can configure settings via the add-on settings dialog (Control+NVDA+0). As it is a settings dialog (powered by gui.SettingsDialog), it will look just like any NVDA preferences dialog. For some advanced options, this dialog is the only gateway to access them (covered below)."""),
"",_(u"""The add-on settings dialog (splconfui.SPLConfigDialog) contains following options:"""),
"",_(u"""* Broadcast profile controls (add-on 6.0 and later): inspired by NVDA screen reader's configuration profiles dialog, this group of controls shows a list of profiles loaded and buttons to create a brand new profile or a copy of an existing profile, rename and delete profiles. It also contains a button (really a toggle button) that tells NVDA to switch to the selected profile upon request (more on this in a second)."""),
_(u"""* Global settings: these are settings not affected by profiles. These include status announcements, announcing listener count, toggling Track Dial, library scan options and so on."""),
_(u"""* Profile-specific settings: Currently alarms, metadata streaming and column announcement settings are profile-specific. These are end of track alarm and the option to use this alarm, song ramp (intro) time and the setting to use this alarm, microphone alarm and microphone alarm interval. It also includes URL's for metadata streaming and column announcement order and inclusion. For numeric settings such as alarm value, it is a spin control (wx.SpinCtrl; use up or down arrow keys to change them)."""),
_(u"""* Reset settings: NVDA will ask if you wish to reset settings in the currently active profile back to factory defaults. This is done by using a function in splconfig module (splconfig.resetConfig) that will set current profile values to defaults (a default configuration map is included for this purpose; this map uses a configuration specification (confspec, part of defining validation routine via validator module (a close friend of ConfigObj), and this confspec is defined in the splconfig module)."""),
"",_(u"""When you press Control+NVDA+0 from Studio to open this dialog, the following will happen:"""),
"",_(u"""1. Just like alarm dialogs (see previous articles), NVDA will make sure no other dialogs are opened."""),
_(u"""2. It'll then call a function in splconfui module, which in turn will prepare the dialog to be shown."""),
_(u"""3. The preparation routine (SettingsDialog.makeSettings) will populate the dialog with controls and options associated with each control, with current options coming from configuration values stored in the active profile."""),
_(u"""4. Once the dialog is ready, it'll pop up and you'll land on the status message checkbox or list of active profiles depending on the add-on version (former is 5.x, latter is 6.0). You can then use typical dialog navigation commands to navigate through various options."""),
"",_(u"""After configuring some settings, click OK. NVDA will then locate the selected profile and tell SPLConfig to use this profile, then store options from the settings dialog into the configuration map."""),
"",_(u"""In case you discard new settings (clicking Cancel), NVDA will check to see if an instant switch profile is defined, and if so, it'll perform various operations depending on whether the instant profile has been renamed or deleted."""),
"",_(u"""### All about broadcast profiles"""),
"",_(u"""In Studio app module world, a broadcast profile (usually shortened to profile) is a group of settings to be used in a show. This is achieved by using a configuration profile container (splconfig.SPLConfigPool for add-on 6.x and 7.x, splconfig.SPLConfig.profiles for 8.0 and later) for storing these profiles, and one of them is used at any given time (by default, the first profile)."""),
"",_(u"""There are two ways of creating a profile: brand new or as a copy. Both uses the same dialog (splconfui.NewProfileDialog), with the difference being the base profile in use. For a brand new profile, settings from the normal profile will be used (minus profile-specific settings, which are set to default values), and for a copy, the new profile will contain all settings from the base profile. In both cases, a memory resident profile will be created and initialized just like other profiles (splconfig.unlockConfig/splconfig.SPLConfig.createProfile, taking the name of the new profile as a parameter); this was done to reduce unnecessary disk writes. Also, new/copy profile dialog (and other dialogs invoked from the main configuration dialog) will disable the main settings dialog."""),
"",_(u"""In case the selected profile is deleted, the profile will be removed from the profiles list, the configuration file associated with the profile will be deleted (if it exists) and a previously active profile will take over unless if the active profile itself is gone, in which case normal profile will be set as the active profile. In case of a rename operation, it'll look for a profile with the old name and change some properties to reflect name change. There is an important step the app module will performed if an instant switch profile is renamed or deleted (if renamed, the instant profile variable will hold the new name, and if deleted, instant profile value will be None). A similar procedure is invoked when dealing with time-based profiles."""),
"",_(u"""#### Introducing Config Hub"""),
"",_(u"""In add-on 6.x and 7.x, a combination of SPLConfig map and the config pool was used to allow users to switch between profiles. Because these were using facilities provided by other modules, this meant custom variables such as active profile flag had to live in splconfig module."""),
"",_(u"""To solve this problem and to allow centralized profile management, a concept of Configuration Hub (ConfigHub) was introduced in add-on 8.0. Inspired by NVDA's own configuration management facility and powered by Chain Map (a dictionary that holds multiple lookup maps), this class not only stores list of currently loaded profiles and the dictionary representing current settings, it also houses various records such as name of the active profile, a history of previously activated profiles and so on, as well as support routines for profile management."""),
"",_(u"""The various changes due to introduction of Config Hub are:"""),
"",_(u"""* Switching profiles: no longer need to copy settings back and forth between live config dictionary and the designated profile in the config pool. Profile switching is simple as swapping new and old profile maps."""),
_(u"""* A history of activated profiles is now kept inside this dictionary."""),
_(u"""* It is possible to pass in additional options when creating a new profile, such as whether it should be cached, validated now and so on."""),
"",_(u"""#### How does profile switching work"""),
"",_(u"""There are two times where a \"live\" profile switching will occur: activation or deactivation of instant switch profile, and when it is time to switch to a time-based profile."""),
"",_(u"""An instant switch profile is a profile to be switched to if told by the user. This is used before you connect to a streaming server to load settings appropriate for a show (as of time of this writing, only one can be selected as an instant switch profile; to define this profile, select a profile to be used as a show, then go to profile switching button and select it)."""),
"",_(u"""In contrast, a time-based profile is a special type of instant switch profile that will be activated at a specific date and time. A separate map (a pickle map) is employed to store settings related to these profiles, and the user-facing options can be found in triggers dialog found in add-on settings (see the next section for an overview of this dialog and the configuration format for this map)."""),
"",_(u"""To activate an instant switch profile, press SPL Assistant, F12. For time-based profile, it'll activate itself when it is time to do so (with help from a countdown timer located in splmisc module). In ither case, the switching procedure is as follows:"""),
"",_(u"""1. Performs some checks, including:"""),
_(u"""	* Checks if a switch profile (instant or time-based) is defined."""),
_(u"""	* For instant switch profiles, if a profile is defined, it'll make sure you are not using the instant switch profile yet."""),
_(u"""2. For add-on 7.x and earlier, saves the index of the active profile."""),
_(u"""3. Locates the name of the switch profile and the profile associated with it and switches to the switch profile (for add-on 7.x, reassigns SPLConfig to use the switch profile; for 8.0 and later, swaps normal profile with the instant profile map). At this point, NVDA may announce metadata streaming status if told to do so when switching profiles, and with 17.12, made simpler through an action extension point notifier that tells appropriate functions to respond to profile switch action."""),
_(u"""4. If no duration is specified for a time-based profile, NVDA will set next switch time and date by calling splconfig.setNextTrigger, otherwise this is delayed until the show is complete."""),
_(u"""5. If told to return to the previously active profile, it'll tell SPLConfig to use the previously active profile (the index for the previously active profile is located and is used to pull the profile with the given index from the config pool)."""),
_(u"""6. When deactivating a time-based profile, NVDA will now find out when the next switch date and time will be."""),
"",_(u"""#### Time-based switching fields and triggers dialog"""),
"",_(u"""For each time-based profile, a list with seven fields is employed to describe trigger (switch) date and time. These are:"""),
"",_(u"""* Trigger date (integer between 0 and 127): A 7-bit integer, denoting days on which a given profile should be activated. This field is used in profile triggers dialog to set or clear activation day checkboxes. A value of 0 means the profile should not be activated, and if so, it is removed from the triggers map."""),
_(u"""* Switch date and time (five integers): The first five fields used for constructing datetime.datetime object (year, month, day, hour, minute) are stored. This is used to let NVDA know when to switch profiles."""),
_(u"""* Duration (integer between 0 and 1439): An integer specifying the duration of this profile (show) in minutes. This is mainly used by a timer that becomes active when the profile in question becomes active, and the only job of this timer is to switch back to another profile when the show is complete."""),
"",_(u"""The triggers dialog, used to configure these fields for the selected profile, consists of two groups of controls:"""),
"",_(u"""* Trigger days: seven checkboxes, one for each day of the week. Checking or clearing these boxes sets corresponding bits in the trigger date field."""),
_(u"""* Switch time: three number entry fields denoting when to switch to this profile (hour and minute) and the duration of this show (minutes)."""),
"",_(u"""Once the data is gathered, NvDA will first check if trigger date checkboxes are checked (if no checkboxes are checked, the profile is removed). Next, NVDA will see if another profile has taken the given time slot, and if not, will proceed to store the next trigger date and time (will not be saved until OK button is clicked from the main add-on settings dialog)."""),
"",_(u"""This article concludes a detailed tour of Studio app module internals. The rest of this series will focus on SPL Studio Utilities global plugin, encoder support and a few thoughts on how the add-on is developed, starting with a tour of SPL Controller layer commands."""),
"",_(u"""## Introduction to SPL Utilities: SPLController and focusing to Studio window"""),
"",_(u"""Now that we've covered the \"kernel\" (innermost parts) of the Studio add-on, it is time to talk about the icing: SPL Utilities global plugins and its contents. The next few articles will talk about what the global plugin does, introduce you to inner workings of SPL Controller layer and tour how encoder support is implemented."""),
"",_(u"""### Studio app module versus SPL Utilities global plugin"""),
"",_(u"""As described in the add-on design article, SPL Studio add-on comes with two app modules and a global plugin. This was needed not only to differentiate between module types and expertese, but also allow Studio functions to be invoked from other programs. With the introduction of encoder support in add-on 3.0 (fall 2014), the global plugin portion of the add-on (SPL Utilities) took on an important role: working as an encoders manager to report connection status and to perform other routines."""),
"",_(u"""### SPL Utilities package contents"""),
"",_(u"""The SPL Utilities global plugin consists of the following modules:"""),
"",_(u"""* Main plugin code (__init__.py), containing essential global routines such as SPL Controller (described below) and a procedure to focus to Studio window upon request. This module defines constants used by Studio to receive messages, a function to focus to Studio window and the global plugin class containing definitions for SPL Controller layer commands."""),
_(u"""* Encoder support (encoders.py), outlining NVDA's support for various encoders (see the next article; the main global plugin module plays an important part in helping the encoder module as you'll see in the next article)."""),
"",_(u"""### SPL Controller layer"""),
"",_(u"""The SPL Controller layer (entry command unassigned, same reason as the Assistant layer entry command) is used to invoke Studio functions from anywhere. The entry routine is similar to the app module counterpart (SPL Assistant) except for the following:"""),
"",_(u"""* NVDA will make sure Studio is running (if so, it'll cache the window handle value just as in the Studio app module), otherwise it cannot enter SPL Controller layer."""),
_(u"""* All commands (except two) use Studio API (Studio API and use of user32.dll's SendMessage was described in a previous article)."""),
"",_(u"""For mechanics of layer commands, see a previous article on add-on design where layer commands were discussed."""),
"",_(u"""The following commands utilize Studio API:"""),
"",_(u"""* A/Shift+A: Automation on/off."""),
_(u"""* L/Shift+L: Line in on/off."""),
_(u"""* M/Shift+M/N: Microphone on/off/instant on/off toggle."""),
_(u"""* P: Play."""),
_(u"""* Q: Obtain various status information. Due to API changes, this command works better in studio 5.20 and later.)"""),
_(u"""* R: Remaining time for the currently playing track (if any)."""),
_(u"""* Shift+R: Library scan progress and umber of items scanned."""),
_(u"""* S/T: Stop with fade/instant stop."""),
_(u"""* U: Play/pause."""),
"",_(u"""For readers familiar with Studio keyboard commands, you'll find yourself at home (they are indeed Studio commands except pressing Shift will turn a feature off and Shift+R will remind you of Control+Shift+R for library scan from Insert Tracks dialog). The letter \"Q\" stands for \"query Studio status\"."""),
"",_(u"""Here are the two exceptions"""),
"",_(u"""* E: If you tell NVDA to monitor one or more encoders in the background, this command will announce number of encoders being monitored (see the next aritlce on the format of this message)."""),
_(u"""* F1: Opens a dialog displaying Controller layer commands (does this sound familiar?)."""),
"",_(u"""### Focusing to Studio window from anywhere"""),
"",_(u"""As you are broadcasting a show with Studio, you may find yourself in a situation where you need to switch to Studio quickly to take care of automation, insert new tracks and so on. An ideal situation is to switch to Studio when you press Alt+TAB (this isn't the case if you have more than two programs opened). For this reason, screen reader scripts for Studio includes a command to switch to Studio upon request (unassigned in NVDA)."""),
"",_(u"""Until 2016, this was accomplished with a function in the SPL Utilities module (SPLStudioUtils.fetchSPLForegroundWindow). This was employed not only by the main global plugin module (called from a script to focus to Studio window), but also used in encoders for various functions. The routine was as follows:"""),
"",_(u"""1. The focus to Studio script will check if Studio is running, and if so, it'll call the fetch window function, which in turn locates the desktop (shell) window to serve as the starting point for locating Studio window."""),
_(u"""2. NVDA will scan top-level windows (children of desktop object) until a Studio window (where the window's app module is the Studio app module) is found, and if found, NVDA will increment a Studio window candidate counter."""),
_(u"""3. Once top-level window scanning is complete, NVDA will take action based on what the Studio window candidate counter says before passing the foreground object back to the main script. It can do one of the following:"""),
_(u"""A. If counter is 0 (fg is None), NVDA will know that you have minimized Studio, so it'll tell you that Studio is minimized."""),
_(u"""B. If counter is 1, NVDA will locate the Studio window by looking for the main Studio window (user32.dll is involved)."""),
_(u"""C. For all other values, NVDA will assume the last window found is the Studio window (held in fg variable) and return it."""),
_(u"""4. Back at the focus to Studio script, NvDA will either announce if Studio is minimized or switch to the foreground window returned by the fetch window function (fg.SetFocus)."""),
"",_(u"""In 2017, this has been simplified to use SetForegroundWindow Windows API function with the handle to the Studio window being the only required parameter. Not only this simplified this routine significantly, it also improved performance of this command. One side effect is that it is no longer possible to detect Studio being minimized, but one can get a clue of this if NVDA says \"unavailable\" when trying to switch to Studio. One can then go to system tray and restore Studio window."""),
"",_(u"""### Conclusion"""),
"",_(u"""The routines discussed above (SPL Controller and the command to switch to Studio window) is one of the two pillars of the SPL Studio Utilities global plugin (the other is encoder support). With these routines, it became possible to perform playback operations without focusing to studio, and you can switch to Studio window from anywhere, anytime. We'll visit the other side of this global plugin story in the next StationPlaylist Add-on Internals article, and after that, we'll conclude with an interview with the maintainer of the add-on to learn about how he (I) develop new add-on features."""),
"","",_(u"""## Encoder support"""),
"",_(u"""We have now arrived at the penultimate chapter in this Add-on Internals article for StationPlaylist add-on: encoder support, the second pillar for the SPL Utilities global plugin. We'll talk about how encoder support is implemented, how NVDA can detect stream labels and a behind the scenes overview of what happens when you connect to a streaming server."""),
"",_(u"""### Encoder support: From suggestion to implementation"""),
"",_(u"""Originally, I wasn't planning on including encoder support into the SPL add-on. However, after talking to some Studio users who were using SAM encoders and seeing how other screen readers supported it, I decided to investigate SAM encoder support in summer 2014."""),
"",_(u"""The first issue I had to solve was making NVDA recognize the encoder entries themselves. Once that was solved, the next task was announcing connection error messages, which led to figuring out how SAM encoders react when connected to a streaming server."""),
"",_(u"""Originally, I manipulated text written to the screen to obtain needed status messages (via text infos). This routine caused some to experience screen flickering issues when connecting to a streaming server. This was resolved by using encoder description (obj.description), which opened up a possibility to monitor changes to this text via a background thread (more on this routine below), which also eliminated a need to stay on the encoders window until connected."""),
"",_(u"""While I was resolving problems with SAM encoders, I also worked on refactoring encoder support code to support StationPlaylist encoders (add-on 4.0). Initially, encoder support code was optimized for SAM encoders, but the current code structure (explained below) was written to extend basic encoder support easily, and as a result, both SAM and SPL encoder entries present similar interfaces and commands, including a common encoder configuration dialog (add-on 7.0)."""),
"",_(u"""### Encoder entries: Yet another overlay class family"""),
"",_(u"""Just like Studio track items (see the section on track items), encoder entries are overlay classes. Each encoder type (SAM or SPL) inherits from a single encoder object (SPLStudioUtils.encoders.EncoderWindow) that provides basic services such as settings commands, announcing stream labels and so on. Then each encoder type adds encoder-specific routines such as different connection detection routines, ways of obtaining stream labels and so on. Speaking of stream labels and settings, the base encoder class is helped by some friends from the encoder module itself, including a configuration map to store stream labels and basic settings, a routine to obtain encoder ID (encoder string and the IAccessible child ID) and so on."""),
"",_(u"""On top of the base encoder class are two encoder classes, representing SAM encoder entries and SPL encoder entries. SAM encoder entries (SPLStudioUtils.encoders.SAMEncoderWindow) is laid out just like Studio's track items, whereas SPL encoder entries (SPLStudioUtils.encoders.SPLEncoderWindow) is a typical SysListView32 control (see an article on column routines for more information). Both classes provide similar routines, with the only difference being how connection messages are handled."""),
"",_(u"""### Common services: basic settings, stream labels and related methods"""),
"",_(u"""All encoder classes provide the following common services:"""),
"",_(u"""* Configuring settings: four settings can be configured:"""),
_(u"""	* Pressing F11 will tell NVDA if NVDA should switch to Studio when the encoder is connected."""),
_(u"""	*Pressing Shift+F11 will ask Studio will play the next track when connected."""),
_(u"""	* Pressing Control+F11 will enable background encoder monitoring (more on this in a second)."""),
_(u"""	* Enabling or disabling connection progress tones (add-on 7.0, configurable from encoder settings dialog described below)."""),
_(u"""	* Once these settings are changed, the new values will be stored in appropriate flag in the encoder entry, which in turn are saved in the configuration map."""),
_(u"""* Retrieves settings. This is done by various property methods - once called, these methods will look up various settings for the encoder from the configuration map (key is the setting flag, value is the encoder ID)."""),
_(u"""* Monitors and responds to connection status changes. The response routine (onConnection method) attempts to set focus to Studio and/or play the first checked track if configured to do so."""),
_(u"""* Loads stream labels when an encoder first gains focus (if this was loaded earlier, it could be a waste of space, especially if encoders are never used)."""),
_(u"""* Announces stream labels (if defined) via reportFocus method. In contrast with the Studio track item version, an encoder's reportFocus routine:"""),
_(u"""	1. Locates stream labels for the current encoder (the configuration map stores stream labels as dictionaries (sections), with each dictionary representing the encoder type, key is the encoder position and the value is the label; each encoder, when told to look up stream labels, will consult its own labels dictionary)."""),
_(u"""	2. If a label is found, NVDA will announce the label (in braille, surrounded by parentheses)."""),
_(u"""* Define and remove stream labels. This is done via stream labels dialog (F12) that'll make sure you entered a label (if not, the encoder position is removed from the encoder-specific stream labels dictionary)."""),
_(u"""* Updates stream label position when told to do so (via a dialog, activated by pressing Control+F12). This is needed if encoders were removed, as you may hear stream label for an encoder that no longer exists. This is implemented as a variation of find predecessor algorithm."""),
_(u"""* Announces encoder columns. The base class can announce encoder position (Control+NVDA+1) and stream label (Control+NVDA+2), while SAM can announce encoder format, status and description and SPL allows one to hear encoder format and transfer rate/connection status."""),
_(u"""* In add-on 7.0, a central configuration dialog for configuring encoder settings for the selected encoder (include stream labels and the four settings described above) has been added. Press Control+NVDA+0 to open this dialog."""),
"",_(u"""### Encoder ID's"""),
"",_(u"""An encoder ID is a string which uniquely identifies an encoder. This consists of a string denoting the encoder type (SAM for SAM encoder, for instance), followed by the encoder position (separated by a space). For instance, the first SAM encoder is given the ID \"SAM 1\". The ID's are used to look up stream labels, configure settings and to identify encoders being monitored (SPL Controller, E)."""),
"",_(u"""### More and more threads: connection messages and background encoder monitoring"""),
"",_(u"""As we saw in a previous chapter, threads allow developers to let programs perform certain tasks in the background. Even in encoder support, threads are employed for various tasks, including connection message announcement and background encoder monitoring."""),
"",_(u"""Each encoder overlay class (not the base encoder) includes dedicated connection handling routines (reportConnectionStatus). Depending on how you invoke this, it starts up as follows:"""),
"",_(u"""* If background encoder monitoring is off and you press F9 to connect, NVDA will run this routine in a separate thread. For SAM, this is checked right after sending F9 to the application, and for SPL, this is done after clicking \"connect\" button (manipulates focus in the process)."""),
_(u"""* If background encoder monitoring is on before pressing F9, the routine will run from another thread when this setting is switched on. Then when you press F9, NvDA knows that the background monitoring thread is active, thus skipping the above step."""),
"",_(u"""The connection handling routine performs the following:"""),
"",_(u"""1. Locates status message for the encoder entry. For SAM, it is the description text, and for SPL, it is one of the entry's child objects (columns). This will be done as long as Studio and/or NVDA is live (that is, if the thread is running)."""),
_(u"""2. Announces error messages if any and will try again after waiting a little while (fraction of a second)."""),
_(u"""3. If connected, NvDA will play a tone, then:"""),
_(u"""	* Do nothing if not told to focus to studio nor play the next track."""),
_(u"""	* Focuses to studio and/or plays the next track if no tracks are playing by calling onConnect method."""),
_(u"""4. For other messages, NVDA will periodically play a progress tone and announce connection status so far as reported by the encoder."""),
_(u"""5. This loop repeats as long as this encoder is being monitored in the background."""),
"",_(u"""### Encoder-specific routines"""),
"",_(u"""In addition to basic services, each encoder routine has its own goodies, including:"""),
"",_(u"""For SAM encoders:"""),
"",_(u"""* To disconnect, press F10."""),
_(u"""* You can press Control+F9 or Control+F10 to connect or disconnect all encoders (does not work well in recent SAM releases, according to my tests). A workaround was developed to fix this problem (opens context menu and activates the correct item on its own)."""),
"",_(u"""For SPL encoders:"""),
"",_(u"""* When you press F9 to connect, NVDA does the following:"""),
_(u"""	1. Locates \"connect\" button, and if it says \"Connect\", clicks it (obj.doAction)."""),
_(u"""	2. Moves focus back to the entry (self.SetFocus)."""),
_(u"""* To disconnect, press TAB until you arrive at \"Disconnect\" button and press SPACE."""),
"",_(u"""## Final notes and add-on development process overview"""),
"",_(u"""Now that we've visited internals of StationPlaylist Studio add-on, I'd like to give you a tour of my lab where I develop this add-on. Along the way you'll learn how an add-on is born, coded, tested, released and maintained."""),
"",_(u"""### Lab setup, development equipment and software"""),
"",_(u"""For all my software development, I use two computers: a touchscreen laptop and a desktop, both running Windows 10 and latest NVDA next branch snapshots. Both also run Cygwin and/or Windows Subsystem for Linux (WSL, otherwise known as BASH on Ubuntu on Windows)to run various command-line tools (Git, SCons, etc.), and in case I need to compile NVDA from source code, installed Visual Studio 2015 with latest update and other dependencies."""),
"",_(u"""In case of SPL add-on, I have different Studio versions installed: 5.11 on my laptop and 5.20 on the desktop. This allows me to work on both versions at once (both computers have the full source code of the add-on, though I tend to write bug fixes on my laptop and experiment with new things on my desktop)."""),
"",_(u"""### Git: a \"smart\" source code manager"""),
"",_(u"""Like other NVDA developers and many add-on writers, I use Git for source code management (contrary to its slogan, Git is very smart). This is a distributed system, meaning a local repository contains the complete record of how the source code is managed (no need to connect to a server to commit and fetch updates). For example, using just my local copy of the SPL add-on source code, I can view commit history and generate older add-on releases."""),
"",_(u"""Another advantage of Git is extensive support for branches. A branch is a development workflow separate from other branches. For example, NVDA screen reader uses at least three branches for its workflow: next (alpha), master (live beta) and rc (release candidate, used to build official releases). SPL add-on uses this approach as well: there are at least two branches in use, called master and stable used for ongoing development or release and maintenance, respectively (we'll come back to branches in a secon). With the advent of Test Drive program (see below), a third branch named \"staging\" or \"next\" is used to gather all work done on branches under one roof for testing purposes."""),
"",_(u"""### How an add-on feature is born"""),
"",_(u"""Let's go through a typical development process for an add-on feature by looking at how broadcast profiles was developed (for more information on broadcast profiles, refer to configuration management section above)."""),
"",_(u"""I started working on broadcast profiles in March 2015 while developing add-on 5.0. This was a natural extension of add-on settings dialog: whereas this dialog (and the configuration database it uses) only dealt with a single profile, I thought it might be a good idea to allow multiple profiles to be defined and to let the settings dialog respond to profile changes."""),
"",_(u"""There was an important reason for writing this feature: Since NVDA supports multiple configuration profiles and since some broadcasters were hosting multiple shows, I thought it would be a good idea to implement a similar feature in the SPL add-on. Thus, I envisioned broadcast profiles to be used primarily by people hosting multiple shows, with each show defined as a profile."""),
"",_(u"""In March and April 2015, I started rewriting certain parts of add-on configuration manager (splstudio.splconfig) in preparation for developing broadcast profiles (now included as part of add-on 6.0). I started by writing todo comments (where appropriate) describing what the future feature should be like. I then modified initConfig and saveConfig (discussed in app module articles), initially telling them to work with the default profile (the one and only configuration map then), then I left it alone until add-on 5.0 was released in June 2015."""),
"",_(u"""In June 2015, I opened a new branch (initially using the codename \"starfish\") to house code related to broadcast profiles. Before any \"real\" code was written, I studied NvDA source code dealing with configuration profiles to learn more about how Jamie (James Teh from NV Access) implemented this feature. Once I understood how it worked, I copied, pasted and changed the code to match the overall add-on code base (giving nV Access the credit they deserve)."""),
"",_(u"""One of the first things I had to decide was how to store profiles. I experimented with using ConfigObj sections, one per profile, but this proved to be problematic (a profile could be given the name of an existing configuration map key). I then went back to NVDA source code to find out how NV Access solved this problem (using separate ini files), implemented it, and was met with another problem: transfering values between profiles. This was resolved by specifying whether a setting was \"global\" (applies to all profiles) or specific to a profile. Next came profile controls in the add-on settings dialog and using choice events to set alarm values using values from the selected profile."""),
"",_(u"""The last thing I did before merging the broadcast profiles branch to master branch in July was revising configuration error dialog and writing documentation for broadcast profiles. Once the documentation was ready and small issues were fixed after going through many rounds of testing (on my own computer and from the profiles branch itself), broadcast profiles branch was merged into master. But the development didn't stop there: thanks to provisions I made, it was quite simple to implement instant switch profiles (again it had issues which are now largely resolved)."""),
"",_(u"""### Dealing with threaded code: headaches during development of background encoder monitoring feature"""),
"",_(u"""You may recall our discussion of Cart Explorer and how it went through extensive testing to arrive at the current state (this was a difficult code segment). When it comes to difficulty, nothing beats multithreaded code, especially if it involves multiple threads working in parallel (rather, almost parallel), and I tasted this when writing background encoder monitor (add-on 5.0). This involved tracking how many threads were running to make sure no unnecessary threads were running, catching suttle errors and race conditions (a connection attempt could run a thread without checking if the encoder is being monitored) and so on. Thankfully, I went through a similar set of problems a few months earlier when I struggled with library scan (add-on 4.0), and that experience taught me to be careful with threads (and to experience fewer headaches)."""),
"",_(u"""### Add-on development process"""),
"",_(u"""Follow me as I show you how a typical SPL add-on version is developed, released and maintained:"""),
"",_(u"""1. Before starting work on the new add-on version, I write down some goals the add-on should achieve, including feature ideas, user (your) suggestions and so on. With changes to the process in 2017, a feature development may span multiple versions."""),
_(u"""2. I then hold a conference call with add-on users to see what they think about some ideas and gather feedback (these are also written down)."""),
_(u"""3. I then create separate branches for each feature in order to isolate  code and not to break existing code."""),
_(u"""4. Next, I write todo comments reminding myself as to what the feature should be like, then I start working on it. As each feature is being developed, I do mental simulations as to how you might use the feature under development, such as possible errors, messages spoken and so on."""),
_(u"""5. Once the feature is quite stable, I test the feature to uncover bugs and to fill in the missing pieces. When it comes to testing, I test the new feature branch on both of my computers running different versions of Studio to make sure it works across versions (if not, I go back and modify the code to recognize differences between Studio versions)."""),
_(u"""6. Starting in fall 2015, I've merged development branches into a staging branch for testing purposes. This branch is also used to generate try (Test Drive program) builds so those who've signed up for early access program can leave feedback (try builds are generated about once a week)."""),
_(u"""7. After testing the feature for a while and if the feature is stable, I merge the feature branch into master."""),
_(u"""8. Every few weeks, I publish master branch snapshots to gather feedback from users willing to test drive snapshots. With the advent of add-on updates in add-on 7.0, one can update between snapshots or stable versions (whichever branch one is using, the update check routine wil use that branch; for example, if one is using master snapshots, updates will be fetched from master branch only)."""),
_(u"""9. At some point, I set release target window for the next add-on version (for 6.0, it was December 2015). This determines when feature freeze should be and beta release window (for 6.0, beta 1 was released in October 2015). Between feature freeze and the first beta release, I concentrate on code refinements and bug fixes. This has changed significnatly in 2017 (see below)."""),
_(u"""10. After going through several beta cycles (typically two), I ask NVDA community add-on reviewers to review my add-on code and request add-on release during the release window (this is done by merging master branch into stable branch)."""),
_(u"""11. Once the add-on version is released, subsequent maintenance versions (localization updates, bug fixes, minor tweaks) will be released from the stable branch, with the master branch containing the code for the next major version."""),
_(u"""12. Once the next version enters beta cycle, further maintenance releases may or may not happen (an exception is long-term support release, described below)."""),
"",_(u"""#### Changes in 2017"""),
"",_(u"""In late 2016, I and some users had a conference call regarding the future direction of the add-on. During this call, participants felt that the add-on now includes all the features people need, so it was decided to scale back on features and focus on compatibility with new Studio releases. In the end, it was decided that a version of the add-on to be released in 2017 will be the final major version of the Studio add-on, with future updates being byte-sized chunks."""),
"",_(u"""This decision also aligned with my other add-ons where new versions were released every month or so, along with the fact that features are complete for most add-ons. The new regular update schedule for SPL add-on was implemented as of June 2017."""),
"",_(u"""There were two more implications of this decision:"""),
"",_(u"""* No more waits: a new stable feature should not be held up for up to six months if it is ready for the public, thus updates include both new features and bug fixes."""),
_(u"""* The Test Drive program (see below) should not be an exclusive thing anymore, but an opt-in process, as I felt early feedback loop is crucial to success of a product such as this add-on."""),
"",_(u"""With this in mind, the following things were changed in 2017:"""),
"",_(u"""* No more betas: the development branch (now called slow ring) is considered live beta branch."""),
_(u"""* Anyone can switch to try build branch (now called fast ring snapshots) provided that they are willing to provide early feedback."""),
_(u"""* Long-term support updates are now tied to new major Studio releases. This criteria was extended in late 2017 to include critical changes to NVDA (see below)."""),
"",_(u"""#### Long-term support release"""),
"",_(u"""A typical add-on version is supported until the next add-on version is released (currently several weeks to months). However, there are times when an add-on version receives extended support (termed long-term support (LTS) release). This happens if the next major version of Studio is released, a version of Studio with user interface changes is released, or critical changes are expected in future NVDA releases such as ending support for a Windows version."""),
"",_(u"""A LTS version is a major version or a major periodic release of the SPL add-on with some notable differences:"""),
"",_(u"""* Support duration: A LTS version is supported for at least a year."""),
_(u"""* Features: A LTS version may contain some features from future add-on releases provided that they can be safely backported."""),
_(u"""* Studio version supported: A LTS version is the last version to support the oldest supported Studio version. This is designed to give people plenty of time to upgrade to newer Studio releases."""),
_(u"""* Last version with old NVDA technology in use: in some cases, LTS releases are made to support users of old NVDA releases. After the LTS release is created, add-on source code will shift to using newer code from NVDA. This criteria will first be applied to an LTS release scheduled for 2018 as a result of NVDA's end of support for Windows XP, Vista and 7 without Service Pack 1."""),
"",_(u"""As of December 2017, the most recent LTS version is add-on 15.x, formerly 7.x until October 2016 (October 2016 to December 2017). Previous LTS release (and so far the only unsupported LTS by far) was 3.x (September 2014 to June 2015). For example, add-on 3.x was maintained thus:"""),
"",_(u"""1. Add-on 3.0 was released in September 2014."""),
_(u"""2. Add-on 3.5 (December 2014) could have been the last maintenance version for add-on 3.x if it was not a LTS version."""),
_(u"""3. When add-on 4.0 was released (January 2015), add-on 3.6 was released, backporting some features from 4.0. Users were told that add-on 3.x will be the last version to support Studio versions earlier than 5.00. From that time on, add-on 3.x was taken off the stable branch and was moved to an internal branch."""),
_(u"""4. When add-on 5.0 beta was released (May 2015), add-on 3.x (3.9 was available then) entered end of support countdown (no more maintenance releases)."""),
_(u"""5. A few weeks later, when add-on 5.0 came out (June 2015), add-on 3.x became unsupported."""),
"",_(u"""The next LTS release is scheduled for early 2019 not only because it will be the last version to support Studio 5.10 (not 5.11), and also to part ways with Windows releases prior to Windows 7 Service Pack 1 (due to announcement from NV Access that 2017.3 will be the last version to support old releases)."""),
"",_(u"""### Final thoughts"""),
"",_(u"""As I end this article on StationPlaylist Studio Add-on Internals, I feel it is time I reveal why my add-ons are free: it is because I love you users and as a service for NVDA user and developer community (and in extension, to all blind broadcasters using SPL Studio). What brings me joy as an add-on writer is the fact that this add-on (and accompanying documentation) has made impact in your lives and lives of listeners to your shows, as well as to other NVDA users and developers around the world. Thank you users for your continued support and feedback, and I promise once again that all my add-on code (including SPL Studio add-on) will be free and anyone is welcome to study and improve upon it."""),
"",_(u"""For add-on writers looking for quality add-on documentation, I hope this series gave you an inspiration as to how to write amazing documentation in your future projects. For people new to add-on writing or for those interested in writing an add-on, I hope this Add-ons Internals series served as a handy resource for your projects, and in extension, gave you an idea as to how certain NVDA functions work. If you'd like to reference this documentation or use it as a blueprint, you are more than welcome to do so. Thank you community add-on reviewers for your continued support and reviews."""),
"",_(u"""### Important notices and credits"""),
"",_(u"""I'd like to thank StationPlaylist staff for continued collaboration with screen reader users in regards to accessibility of Studio. A special thanks goes to Jamie Teh from NV Access and Geoff Shang (original add-on author) for giving me and others a foundation for future goodies. As always, the biggest thanks goes to you, the users of SPL add-on for your continued feedback and teaching me new things about studio."""),
"",_(u"""Source code notice: to protect copyrights, parts of Studio API has not been documented. Also, source code discussed throughout this series may change as future add-on versions are developed."""),
"",_(u"""Copyrights: StationPlaylist Studio, Track Tool and StationPlaylist Encoders are copyright StationPlaylist.com. NonVisual Desktop Access is copyright 2006-2016 NV access Limited (released under GPL). SAM Encoders is copyright Spatial Audio. Microsoft Windows and Windows API are copyright Microsoft Corporation. Python is copyright Python Software Foundation. StationPlaylist Studio add-on for NvDA is copyright 2011, 2013-2016 Geoff Shang, Joseph Lee and others (released under GPL). Other products mentioned are copyrighted by owners of these products (licenses vary)."""),
"",_(u"""## References"""),
"",_(u"""1. JAWS scripts for StationPlaylist Studio (Hartgen Consultancy): http://www.hartgen.org/studio.html"""),
_(u"""2. Window-Eyes app for StationPlaylist (Jeff Bishop/AI Squared): https://www.gwmicro.com/App_Central/Apps/App_Details/index.php?scriptid=1268&readMore&media=print"""),
_(u"""3. Plug-in (Wikipedia): https://en.wikipedia.org/wiki/Plug-in_(computing)"""),
_(u"""4. Application Programming Interface (Wikipedia): https://en.wikipedia.org/wiki/Application_programming_interface"""),
_(u"""5. Python 2.7.13 documentation overview (Python Software Foundation): https://docs.python.org/2/"""),
_(u"""6. Handle (Wikipedia): https://en.wikipedia.org/wiki/Handle_(computing)"""),
_(u"""7. What is a Windows handle (Stack Overflow): http://stackoverflow.com/questions/902967/what-is-a-windows-handle"""),
_(u"""8. FindWindow (user32.dll) reference (Windows API): https://msdn.microsoft.com/en-us/library/windows/desktop/ms633499(v=vs.85).aspx"""),
_(u"""9. SendMessage (user32.dll) reference (Windows API): https://msdn.microsoft.com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx"""),
_(u"""10. NVDA Developer Guide (NV Access): http://www.nvaccess.org/files/nvda/documentation/developerGuide.html"""),
_(u"""11. OpenProcess (kernel32.dll) reference (Windows API): https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320(v=vs.85).aspx"""),
_(u"""12. wxPython online docs: http://www.wxpython.org/onlinedocs.php"""),
_(u"""13. Higher order functions (How do you make a higher order function): http://effbot.org/pyfaq/how-do-you-make-a-higher-order-function-in-python.htm"""),
_(u"""14. Time (Python documentation, Python Software Foundation): https://docs.python.org/2/library/time.html"""),
_(u"""15. GetTimeFormat (kernel32.dll) reference (Windows API): https://msdn.microsoft.com/en-us/library/windows/desktop/dd318130(v=vs.85).aspx"""),
_(u"""16. Event loop (Wikipedia): https://en.wikipedia.org/wiki/Event_loop"""),
_(u"""17. Event-driven programming (Wikipedia): https://en.wikipedia.org/wiki/Event-driven_programming"""),
_(u"""18. Sinclair, Rob. Microsoft Active Accessibility architecture, Microsoft Developer Network, August 2000. https://msdn.microsoft.com/en-us/library/ms971310.aspx"""),
_(u"""19. UI Automation Overview, Microsoft Developer Network. https://msdn.microsoft.com/en-us/library/ms747327(v=vs.110).aspx"""),
_(u"""20. Java Access Bridge overview, Java SE Desktop Accessibility, Oracle. http://www.oracle.com/technetwork/articles/javase/index-jsp-136191.html"""),
_(u"""21. Introduction to OOP (Object-Oriented Programming) with Python, Voidspace. http://www.voidspace.org.uk/python/articles/OOP.shtml"""),
_(u"""22. Non-Programmer's Tutorial for Python 3/Intro to Object Oriented Programming in Python 3 - Wikibooks. https://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_3/Intro_to_Object_Oriented_Programming_in_Python_3"""),
_(u"""23. Method Resolution Order, The History of Python, june 23, 2010. http://python-history.blogspot.com/2010/06/method-resolution-order.html"""),
_(u"""24. List View, Microsoft Developer Network: https://msdn.microsoft.com/en-us/library/windows/desktop/bb774737(v=vs.85).aspx"""),
_(u"""25. List View Messages, Microsoft Developer Network: https://msdn.microsoft.com/en-us/library/windows/desktop/ff485961(v=vs.85).aspx"""),
_(u"""26. List View Item structure, Microsoft Developer Network: https://msdn.microsoft.com/en-us/library/windows/desktop/bb774760(v=vs.85).aspx"""),
_(u"""27. VirtualAllocEx (kernel32.dll) reference (Windows API): https://msdn.microsoft.com/en-us/library/windows/desktop/aa366890(v=vs.85).aspx"""),
_(u"""28. VirtualFreeEx (kernel32.dll) reference (Windows API): https://msdn.microsoft.com/en-us/library/windows/desktop/aa366894(v=vs.85).aspx"""),
_(u"""29. WriteProcessMemory (kernel32.dll) reference (Windows API): https://msdn.microsoft.com/en-us/library/windows/desktop/ms681674(v=vs.85).aspx"""),
_(u"""30. ReadProcessMemory (kernel32.dll) reference (Windows API): https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx"""),
_(u"""31. Ctypes (Python documentation, Python Software Foundation): https://docs.python.org/2/library/ctypes.html"""),
_(u"""32. Thread (Wikipedia): https://en.wikipedia.org/wiki/Thread_(computing)"""),
_(u"""33. Multi-core processor (wikipedia): https://en.wikipedia.org/wiki/Multi-core_processor"""),
_(u"""34. Multi-core introduction, Intel Developer Zone, March 5, 2012: https://software.intel.com/en-us/articles/multi-core-introduction"""),
_(u"""35. Intel Core I7-5960X specifications (Intel ARK): http://ark.intel.com/products/82930/Intel-Core-i7-5960X-Processor-Extreme-Edition-20M-Cache-up-to-3_50-GHz"""),
_(u"""36. Intel Xeon E7-8895V3 specifications (Intel ARK): http://ark.intel.com/products/84689/Intel-Xeon-Processor-E7-8895-v3-45M-Cache-2_60-GHz"""),
_(u"""37. Global Interpreter Lock (Python Wiki): https://wiki.python.org/moin/GlobalInterpreterLock"""),
_(u"""38. Threading (Python documentation, Python Software Foundation): https://docs.python.org/2/library/threading.html"""),
_(u"""39. Multiprocessing (Python documentation, Python Software Foundation): https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing"""),
_(u"""40. Comma-separated values (Wikipedia): https://en.wikipedia.org/wiki/Comma-separated_values"""),
_(u"""41. RFC 4180 (Common Format and MIME Type for Comma-Separated Values (CSV) Files), Internet Engineering Task Force: https://tools.ietf.org/html/rfc4180"""),
_(u"""42. Import or export text (.txt or .csv) files, Microsoft Office Support for Microsoft Excel: https://support.office.com/en-za/article/Import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba"""),
_(u"""43. CSV (Python documentation, Python Software Foundation): https://docs.python.org/2/library/csv.html"""),
_(u"""44. Cache (Wikipedia): https://en.wikipedia.org/wiki/Cache_(computing)"""),
_(u"""45. Os (Python documentation, Python Software Foundation): https://docs.python.org/2/library/os.html"""),
_(u"""46. Configparser (Python documentation, Python Software Foundation): https://docs.python.org/2/library/configparser.html"""),
_(u"""47. ConfigObj documentation: http://www.voidspace.org.uk/python/configobj.html"""),
_(u"""48. Validate module documentation: http://www.voidspace.org.uk/python/validate.html"""),
_(u"""49. Spin control (wx.SpinCtrl) documentation (WXPython): http://wxpython.org/Phoenix/docs/html/SpinCtrl.html"""),
_(u"""50. SetForegroundWindow (user32.dll) reference (Windows API): https://msdn.microsoft.com/en-us/library/windows/desktop/ms633539(v=vs.85).aspx"""),
]