# -*- coding: utf-8 -*-
documentation = [
_(u"""# Design Overview"""),
"",_(u"""This article attempts to provide an overview of NVDA's technical design and architecture."""),
_(u"""It is necessarily somewhat technical in nature."""),
_(u"""You should have a reasonable knowledge of programming and object oriented programming concepts in particular, as well as at least a basic knowledge of Python, before attempting to understand NVDA's design """),
_(u"""Please see the code documentation for the relevant classes for more information."""),
"",_(u"""## Terminology"""),
"",_(u"""### Abbreviations"""),
_(u""" * API: Application programming interface"""),
_(u""" * GUI: Graphical user interface"""),
"",_(u"""### Definitions"""),
_(u""" * Caret: The system cursor; i.e."""),
_(u"""the cursor generally moved when you use the normal cursor keys."""),
_(u""" * Script: A function which is executed in response to input from the user such  as key presses from the keyboard, manipulating braille display controls and taps on touchscreens."""),
_(u"""Also known as a command."""),
_(u""" * Widget: An individual component in a GUI with which a user can interact;"""),
_(u""" e.g. a button, an editable text field, a list box, etc."""),
_(u"""Also known as a control or object."""),
"",_(u"""## General"""),
"",_(u"""### Programming Languages"""),
_(u"""NVDA is primarily written in the [Python programming language](http://www.python.org/), which allows for rapid development among other benefits."""),
_(u"""Code that needs to be [injected into other processes](#in-process-code) is written in C++ for high performance."""),
"",_(u"""### Accessibility APIs"""),
_(u"""In order to make graphical widgets accessible to assistive technologies, operating systems and applications can use special purpose accessibility APIs."""),
_(u"""These APIs provide information about the widget such as its name, type/role (button, check box, editable text field, etc.), description, value, states (checked, unavailable, invisible, etc.) and keyboard shortcut."""),
_(u"""Accessibility APIs also provide events to allow assistive technologies to monitor changes, such as when the focus changes, properties of an object (such as name, description, value, and state) change, etc."""),
_(u"""Rich accessibility APIs provide additional information, including the ability to access detailed information about and track the cursor in editable text controls, and table information such as row and column coordinates."""),
_(u"""NVDA relies heavily on accessibility APIs to gather information."""),
_(u"""Several accessibility APIs are used, including Microsoft Active Accessibility (MSAA) (also known as IAccessible), [IAccessible2](http://www.linuxfoundation.org/en/Accessibility/IAccessible2), Java Access Bridge and UI Automation."""),
"",_(u"""### Native APIs"""),
_(u"""Some widgets do not expose sufficient information via accessibility APIs to make them fully accessible."""),
_(u"""For example, MSAA, which is the accessibility API used by most standard Windows controls, does not provide the ability to obtain the location of the cursor or retrieve individual units of text in editable text fields."""),
_(u"""However, some widgets provide their own native APIs (not specific to accessibility) which can be used to obtain this information."""),
_(u"""NVDA makes use of these APIs where possible; e.g. in standard edit controls."""),
"",_(u"""### Operating System Functions"""),
_(u"""Aside from accessibility and native APIs, Windows provides many functions which can be used to obtain information and perform tasks."""),
_(u"""Information that can be obtained includes the class name of a window, the current foreground window and system battery status."""),
_(u"""Tasks that can be performed include moving/clicking the mouse and sending key presses."""),
"",_(u"""## NVDA Components"""),
_(u"""NVDA is built with an extensible, modular, object oriented, abstract design."""),
_(u"""It is divided into several distinct components."""),
"",_(u"""### Launcher"""),
_(u"""The launcher is the module which the user executes to start NVDA."""),
_(u"""It is contained in the file `nvda.pyw`."""),
_(u"""It handles command line arguments, performs some basic initialisation and starts the [core](#core) (unless NVDA is already running or a command line option specifies otherwise)."""),
"",_(u"""### Core"""),
_(u"""The core (in the function `core.main`) loads the configuration, initialises all other components and then enters the main loop."""),
_(u"""In each iteration of the main loop, the core pumps the [API](#api-handlers) and [input](#input-handlers) handlers, [registered generators](#registered-generators) and the main queue."""),
_(u"""All events, scripts, etc. are indirectly queued to this main queue by API and input handlers, so pumping the main queue causes these to be executed."""),
_(u"""At the end of the iteration, the core then goes to sleep until more work is added to the main queue, at which point the core will again wake and perform another iteration. """),
_(u"""The main loop continues to iterate / sleep until NVDA is instructed to exit either by the user or a newly started copy of NVDA."""),
_(u"""Once NVDA is instructed to exit, the core terminates all other components, saves the configuration if appropriate and then exits."""),
"",_(u"""#### Event and Script Handling"""),
_(u"""Rather than queuing scripts and events directly to the main queue, this is abstracted using the `eventHandler` and `scriptHandler` modules."""),
_(u"""Input and API handlers use these modules to queue or directly execute scripts and events."""),
"",_(u"""#### Registered Generators"""),
_(u"""Some tasks need to run in the background without causing NVDA to block (freeze) while waiting for them to complete."""),
_(u"""They need to execute code regularly, but at no specific time interval."""),
_(u"""NVDA allows Python generator functions to be registered for this purpose."""),
_(u"""Once registered, the generator will be pumped once for each iteration/tick of the main loop."""),
_(u"""Examples of this include the say all and speak spelling functionality."""),
_(u"""They are registered using `queueHandler.registerGeneratorObject`."""),
"",_(u"""### Input Handlers"""),
_(u"""The input handlers handle input from various sources."""),
_(u"""Currently, there are three main input handler modules: `keyboardHandler`, `mouseHandler` and `touchHandler`. [Braille display drivers](#output-drivers) can also handle input."""),
_(u"""These handlers listen for input and generate appropriate [input gestures](#input-gestures) and events."""),
"",_(u"""### Input Gestures"""),
_(u"""An input gesture is an abstract representation of a single piece of input from the user; e.g. a key press."""),
_(u"""All input gestures derive from the base `inputCore.InputGesture` class."""),
_(u"""This allows all input to be handled in a consistent, unified way."""),
_(u"""For example, any input gesture can be bound to any script, both in code and by the user."""),
"",_(u"""### API Handlers"""),
_(u"""These handle initialisation, listening for events and termination for specific accessibility and native APIs."""),
_(u"""They also contain utility functions useful for working with their API."""),
_(u"""When an event is received for a widget, an appropriate [NVDA object](#nvda-objects) is fetched or constructed and an event is then queued for that NVDA object."""),
_(u"""Together with [NVDA objects](#nvda-objects), they abstract the handling of queries and events for specific APIs so that the bulk of NVDA need not be concerned with specific APIs."""),
_(u"""To introduce support for a new API, a developer just creates another API handler and appropriate NVDA objects without needing to change the majority of the code."""),
_(u"""API handler modules include `IAccessibleHandler` for MSAA/IAccessible and IAccessible2, `JABHandler` for Java Access Bridge and `UIAHandler` for UI Automation."""),
"",_(u"""### Output Modules"""),
_(u"""Separate modules encapsulate the handling of output functionality."""),
_(u"""Currently, there are two main output modules: `speech` and `braille`."""),
_(u"""There is also the `tones` module, which is used to output tones/beeps, and `nvWave` module used to play wave files indicating specific events."""),
"",_(u"""### Output Drivers"""),
_(u"""Synth drivers are drivers to allow NVDA to utilise particular speech synthesisers."""),
_(u"""They are derived from the `synthDriverHandler.SynthDriver` base class."""),
_(u"""Braille display drivers are drivers to allow NVDA to utilise particular braille displays."""),
_(u"""They are derived from the `braille.BrailleDisplayDriver` base class."""),
"",_(u"""### NVDA Objects"""),
_(u"""An NVDA object (NVDAObject) is an abstract representation of a single widget in NVDA."""),
_(u"""All NVDA objects derive from the base `NVDAObjects.NVDAObject` class."""),
_(u"""Methods and properties are used to query information about, handle events from and execute actions on the widget represented by the NVDA object in an abstract way."""),
_(u"""This means that the bulk of NVDA need not be concerned with specific accessibility or native APIs, but can instead work with a single, abstract representation."""),
_(u"""This allows for the seamless support and integration of many vastly different APIs."""),
_(u"""It is here that the full power of object oriented programming is used."""),
_(u"""Many methods are implemented on the base `NVDAObject` class and only need to be overridden if specific functionality is required."""),
_(u"""Similarly, if a particular widget is non-standard, problematic, provides additional information using other mechanisms, etc., it can simply subclass another NVDA object and override methods as appropriate."""),
_(u"""NVDA objects that might be used in any application are contained in the NVDAObjects package. [App modules](#app-modules) may also define NVDA objects specific to an application."""),
"",_(u"""A part from properties such as a widget's name, role, states etc, NVDA objects also include relational properties such as parent, next, previous and first child."""),
_(u"""These allow both the user and code to navigate the entire Operating System and its applications in a tree-like structure."""),
_(u"""The root of the tree being the Desktop, whos children is all the top-level windows for all open applications, each containing further subtrees of more widgets representing an application's user interface."""),
_(u""" """),
_(u"""### Text Ranges"""),
_(u"""When working with editable text controls, NVDA needs to be able to obtain information about the text in the widget."""),
_(u"""Aside from just retrieving the entire text, proper navigation requires retrieval of specific units of text (e.g. paragraphs, lines, words and characters), as well as the ability to find and set the location of the caret and selection."""),
_(u"""Also, if the widget supports formatting, NVDA should be able to retrieve text attributes such as font name, size, bold, italic, underline and whether there is a spelling error."""),
_(u"""Each API provides a different way of querying and manipulating text."""),
_(u"""Just as NVDA objects provide an abstract representation of a widget, TextInfo objects provide an abstract representation of a range of text."""),
_(u"""These objects are derived from the `textInfos.TextInfo` base class."""),
"",_(u"""TextInfo objects contain properties and methods to:"""),
_(u"""* Move or expand the range by units such as character, word, line and paragraph"""),
_(u"""* compare the start and end of a range with itself or another range"""),
_(u"""* Fetch the text and formatting of the range"""),
_(u""" """),
_(u""" You can fetch a TextInfo object from an NVDA object via its `makeTextInfo` method, passing in the particular `textInfos.POSITION_*` constant depending on whether you want to fetch a range representing the position of the caret, selection, start or end of the text, or the entire text."""),
_(u""" """),
_(u"""### Global Commands"""),
_(u"""The global commands object (`globalCommands.GlobalCommands`) contains built-in global scripts; i.e."""),
_(u"""they can be executed everywhere."""),
_(u"""For example, the review, report current focus and date/time scripts are all located in global commands."""),
"",_(u"""### Plugins"""),
_(u"""NVDA allows third-parties to extend NVDA's functionality through plugins and add-ons."""),
_(u"""These may define custom NVDA objects for specific applications, add global features and add support for new braille displays and speech synthesizers."""),
_(u"""There are three plugin types: appModules, globalPlugins and drivers, with drivers further divided between speech synthesizer and braille display support."""),
"",_(u"""#### App Modules"""),
_(u"""Generally, most widgets may appear in any application and an [NVDA object](#nvda-objects) should therefore be included in the main `NVDAObjects` package."""),
_(u"""However, there are sometimes cases where a widget is implemented specifically for one application, as well as cases where a single event must be overridden or a script must be provided only in one application."""),
_(u"""An app module provides support specific to an application for these cases."""),
_(u"""An app module is derived from the `appModuleHandler.AppModule` base class."""),
_(u"""App modules receive events for all [NVDA objects](#nvda-objects) in the application and can bind scripts which can be executed anywhere in that application."""),
_(u"""They can also implement their own NVDA objects for use within the application."""),
"",_(u"""#### Global Plugins"""),
_(u"""Aside from application specific customisation using [app modules](#app-modules), it is also possible to extend NVDA on a global level."""),
_(u"""For example, new global commands can be added, behaviour can be changed and new GUI toolkits can be supported."""),
_(u"""This can be done using global plugins."""),
_(u"""A global plugin is derived from the `globalPluginHandler.GlobalPlugin` base class."""),
_(u"""Similar to [global commands](#global-commands), they can bind scripts which can be executed everywhere."""),
_(u"""More specifically, global plugins receive events for all [NVDA objects](#nvda-objects) in the Operating System and can bind scripts which can be executed anywhere."""),
_(u"""They can also implement their own global [NVDA Objects](#nvda-objects)."""),
"",_(u"""### Tree Interceptors"""),
_(u"""Sometimes, it is necessary to intercept events and scripts for an entire hierarchy (or tree) of [NVDA objects](#nvda-objects)."""),
_(u"""For example, this is necessary to seamlessly handle complex documents which consist of many objects."""),
_(u"""This can be done using a tree interceptor."""),
_(u"""A tree interceptor (TreeInterceptor) is derived from the `treeInterceptorHandler.TreeInterceptor` base class."""),
_(u"""It receives events and scripts for all [NVDA objects](#nvda-objects) beneath and including the root NVDA object of the tree interceptor."""),
_(u"""Tree interceptors are created when a TreeInterceptor class is returned from the `treeInterceptorClass` property of an NVDA object."""),
_(u"""Tree interceptors are used mostly for web documents, where all events and scripts for NVDA objects within a document need to be handled by the document (root NVDA object) itself."""),
"",_(u"""#### Browse mode documents"""),
_(u"""Complex documents such as web pages are very often not flat; i.e. information does not simply run from top to bottom."""),
_(u"""Because of this, complex document browsers often do not provide a way to navigate documents using the caret, and even when they do, it is often problematic."""),
_(u"""Therefore, screen readers need to create their own flat representation of a document from the object hierarchy provided by the browser and allow the user to navigate this flat representation."""),
_(u"""Browse mode documents are a subclass of `TreeInterceptor` that provide scripts that allow navigating the document in a linear fashion."""),
"",_(u"""##### Virtual buffers"""),
_(u"""Due to the extreme slowness of performing large numbers of [out-of-process](#out-of-process-code) queries, some complex documents are accessed by NVDA by using [in-process code](#in-process-code), which collects all the content of a document in one go, and allows NVDA to search and fetch parts of this cached content on demand."""),
_(u"""These are known as virtual buffers."""),
_(u"""A virtual buffer (VirtualBuffer) in NVDA is derived from the `virtualBuffers.VirtualBuffer` base class and is a type of [browse mode document](##browse-mode-documents)."""),
"",_(u"""### GUI"""),
_(u"""NVDA has its own graphical user interface to allow for easy configuration and other user interaction."""),
_(u"""This code is primarily contained in the `gui` package. [wxPython](http://www.wxpython.org/) is used as the GUI toolkit."""),
"",_(u"""### Configuration management"""),
_(u"""NVDA includes an extensive configuration management facility including various preferences dialogs, ability to apply a given configuration in apps and so forth."""),
_(u"""The base configuration options, as well as routines that manage configuration profiles and other management routines are housed in the `config` package, and NVDA uses [ConfigObj](http://www.voidspace.org.uk/python/configobj.html) to store configuration options."""),
"",_(u"""## Special Object Functions"""),
"",_(u"""### Events"""),
_(u"""NVDA object, global plugin, app module and tree interceptor instances can all contain special methods which handle events for NVDA Objects."""),
_(u"""These methods are all named beginning with \"event_\"; e.g. `event_gainFocus` and `event_nameChange`."""),
_(u"""These events are generally executed by a call to `eventHandler.executeEvent`, which is in turn generally called resultant to events queued by [API Handlers](#api-handlers)."""),
_(u"""Most events do not take any additional arguments."""),
_(u"""Global plugins, app modules and tree interceptors are passed a handler function which should be called if the event should be handled by the next handler;"""),
_(u"""e.g. the object itself."""),
"",_(u"""Although an event is always for a particular NVDA object, it first has a chance of being handled by global plugins, app modules or tree interceptors."""),
_(u"""If an event is handled by one of these, meaning that an `event_*` method was found and executed, the event stops there and does not go further, unless the method that handled it specifically calls the `nextHandler` function object passed to it. """),
"",_(u"""The chain of handlers is as follows:"""),
_(u"""* The first found global plugin"""),
_(u"""* The next found global plugin (until no more are found)"""),
_(u"""* The app module containing the NVDA object the event is for, I.e. fetched from the NVDA object's `appModule` property. """),
_(u"""* The tree interceptor containing the NVDA object the event is for. I.e. fetched from the NVDA object's `treeInterceptor` property if the property is not `None`"""),
_(u"""* The NVDA object itself."""),
"",_(u"""### Scripts"""),
_(u"""NVDA object, global plugin, app module and tree interceptor instances can all contain special methods called scripts which are executed in response to [input gestures](#input-gestures) from the user."""),
_(u"""These methods are all named beginning with \"script_\"; e.g. `script_reportCurrentFocus` and `script_dateTime`."""),
_(u"""Script methods are passed the input gesture that triggered them."""),
_(u"""Input gestures are bound to scripts in the class using a `scriptHandler.script` function decorator."""),
_(u"""They can also be bound at runtime using `bindGesture`."""),
_(u"""These are inherited from `baseObject.ScriptableObject`."""),
"",_(u"""Similar to events, input gestures have a chance to be handled by a script at one of many levels."""),
_(u"""But unlike events, once an input gesture finds and executes a script, there is no clean way to have the input gesture handled by a subsequent level."""),
_(u""" """),
_(u""" The chain of handlers is as follows:"""),
_(u"""* The first found global plugin """),
_(u"""* The next found global plugin (until no more are found)"""),
_(u"""* The app module containing the currently focused NVDA object, I.e. fetched from the NVDA object's `appModule` property """),
_(u"""* The tree interceptor containing the currently focused NVDA object, I.e. fetched from the NVDA object's `treeInterceptor` property if the property is not `None`"""),
_(u"""* The currently focused NVDA object"""),
_(u"""* the first ancestor (parent) of the currently focused NVDAObject, if the found script's `canPropagate` property is True"""),
_(u"""* the next ancestor of the currently focused NVDAObject, if the found script's `canPropagate` property is True..."""),
_(u""" * Global commands"""),
_(u""" """),
_(u"""## Inter-process Communication"""),
_(u"""In general terms, every running application or service on a computer, including NVDA, is a separate process."""),
_(u"""No process can access data in another process except via special operating system mechanisms."""),
_(u"""This is called inter-process communication (IPC)."""),
"",_(u"""### Out-of-process Code"""),
_(u"""NVDA functions primarily out-of-process."""),
_(u"""That is, events and queries for information from other processes must be marshalled (communicated) between NVDA and the process in question using IPC."""),
_(u"""This is many times slower than queries and events managed in the same process."""),
_(u"""However, for the majority of screen reader functionality, this performance hit is insignificant."""),
"",_(u"""### In-process Code"""),
_(u"""When large numbers of queries need to be made in one hit, working [out-of-process](#out-of-process-code) is far too slow."""),
_(u"""A noteworthy example is rendering a web page into a flat representation, as is done by [virtual buffers](#virtual-buffers)."""),
_(u"""In these cases, code can be \"injected\" into the remote process."""),
_(u"""Because this code is running in the same process, queries and events are much faster, as they do not have to be marshalled between processes, which means that large numbers of queries are quite fast."""),
_(u"""NVDA can then perform single out-of-process queries for relevant information."""),
_(u"""In-process code must be small and light-weight, as it is being injected into other processes."""),
_(u"""It must also be as fast as possible to allow for maximum performance."""),
_(u"""Python is unsuitable for this task."""),
_(u"""All of NVDA's in-process code is written in C++, which allows for maximum performance and minimal overhead."""),
]