# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR ORGANIZATION
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-22 09:10+0200\n"
"PO-Revision-Date: 2021-10-22 12:38+0200\n"
"Last-Translator: José Manuel Delicado <jmdaweb@hotmail.com>\n"
"Language-Team: \n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: pygettext.py 1.5\n"
"X-Generator: Poedit 3.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ..\python_docs\spladdoninternals.py:3
msgid "# NVDA Add-on internals: StationPlaylist"
msgstr "# Complementos de NVDA vistos por dentro: StationPlaylist"

#: ..\python_docs\spladdoninternals.py:4
msgid "Author: Joseph Lee"
msgstr "Autor: Joseph Lee"

#: ..\python_docs\spladdoninternals.py:5
msgid "Based on StationPlaylist Add-on for NVDA 21.10"
msgstr "Basado en el complemento StationPlaylist para NVDA 21.10"

#: ..\python_docs\spladdoninternals.py:6
msgid "## 2021 Preface and notes"
msgstr "## Prólogo y notas de 2021"

#: ..\python_docs\spladdoninternals.py:7
msgid ""
"This guide has gone through many revisions, style changes, and updated to "
"include features in latest add-on releases. When first published in 2015, it "
"was done as a series of blog posts. Now in 2021, edits were made to remove "
"traces of old style and update this guide to reflect add-on features as of "
"2021 and beyond."
msgstr ""
"Esta guía ha pasado por muchas revisiones, cambios de estilo, y se ha "
"actualizado para incluir características de las últimas versiones del "
"complemento. Cuando se publicó por primera vez en 2015, se elaboró como una "
"serie de entradas de blog. Ahora en 2021, se está editando para eliminar las "
"huellas del estilo anterior y actualizándose para reflejar las últimas "
"características del 2021 y más allá."

#: ..\python_docs\spladdoninternals.py:8
msgid ""
"In 2018, the scope of the add-on has expanded to cover StationPlaylist "
"Creator and Track Tool. For the most part, this guide will still cover "
"StationPlaylist Studio alone, but there are important changes made in recent "
"releases that'll ask us to consider other programs in StationPlaylist suite. "
"In particular, trakc item class inheritance hierarchy has changed so many "
"column navigation commands are available when dealing with tracks across SPL "
"apps. As a result, the add-on itself was renamed in 2019 to just "
"\"StationPlaylist\"."
msgstr ""
"En 2018 también se expandió el ámbito del complemento para cubrir "
"StationPlaylist Creator y la herramienta de pista. En su mayor parte, esta "
"guía todavía cubrirá StationPlaylist Studio únicamente, pero hay cambios "
"importantes que se han hecho en las versiones más recientes que nos harán "
"plantearnos añadir otros programas de la suite StationPlaylist. En "
"particular, la jerarquía de herencia de la clase de elemento de pista ha "
"cambiado, por lo que muchas órdenes de navegación por columnas están "
"disponibles al tratar con pistas en las aplicaciones de SPL. Como resultado, "
"el propio complemento se renombró en 2019 a \"StationPlaylist\"."

#: ..\python_docs\spladdoninternals.py:9
msgid ""
"Later in 2018, add-on update feature was removed in favor of Add-on Updater "
"add-on. Although the source code for this feature is gone, information "
"pertaining to it will be documented here for sake of completeness (after "
"all, Add-on Updater's update checking mechanism can trace its roots to "
"Studio add-on)."
msgstr ""
"Más tarde en 2018, la función de búsqueda de actualizaciones se eliminó en "
"favor del complemento Add-on Updater. Aunque el código fuente de esta "
"función ya se ha ido, la información relacionada con él permanecerá aquí con "
"motivos de completitud (a fin de cuentas, el complemento Add-on Updater "
"tiene sus raíces en el complemento de Studio)."

#: ..\python_docs\spladdoninternals.py:10
msgid ""
"Then came 2019, and so did Python 3, abstract classes, and new encoder "
"types. The old days of just dealing with SAM and SPL encoders is over, and "
"encoder support has been redesigned from ground up in 2020. Compared to old "
"add-on releases, the scope of SPL Utilities global plugin has been reduced "
"in favor of giving more autonomy to encoder support app modules (mostly SPL "
"Engine). Along with this, the add-on has been updated to be powered strictly "
"by Python 3."
msgstr ""
"Después vino 2019, y con él llegaron Python 3, las clases abstractas, y "
"nuevos tipos de codificadores. Aquellos días de tratar sólo con los "
"codificadores SAM y SPL se acabaron, y se ha rediseñado el soporte de "
"codificadores de arriba a abajo en 2020. En comparación con versiones "
"antiguas del complemento, el ámbito de la extensión global de utilidades de "
"SPL se ha reducido en favor de una mayor autonomía para los módulos de "
"aplicación de soporte del codificador (mayoritariamente el motor de SPL). "
"Aparte de esto, se ha actualizado el complemento para apoyarse estrictamente "
"en Python 3."

#: ..\python_docs\spladdoninternals.py:11
msgid ""
"In 2020, the add-on has gone through another major change: removal of "
"unnecessary features and splitting broadcast profiles management from add-on "
"settings dialog. In the old days, add-on settings management was intimately "
"tied to broadcast profiles, and that was the reason why broadcast profiles "
"panel was an integral part of add-on settings dialog. In early 2020, several "
"bugs stemming from design decisions years ago came to light such as applying "
"settings changes to wrong profile. Together with a need to make add-on "
"settings panels independent of each other in order to allow users to open "
"alarms panel from anywhere (described later), it was decided to split "
"broadcast profiles panel into its own dialog."
msgstr ""
"En 2020, el complemento ha sufrido otro cambio importante: eliminación de "
"características innecesarias y separación de la gestión de perfiles de "
"emisión y las opciones del complemento. Antes, la gestión de ajustes del "
"complemento se encontraba íntimamente relacionada con los perfiles de "
"emisión, y esa era la razón por la que el panel de perfiles de emisión era "
"parte integral del diálogo de opciones del complemento. A principios de "
"2020, salieron a la luz varios fallos causados por decisiones de diseño de "
"hace años, tales como la aplicación de los ajustes en el perfil equivocado. "
"Junto a la necesidad de hacer los paneles de opciones del complemento "
"independientes entre sí para permitir a los usuarios abrir el panel de "
"alarmas desde cualquier parte (descrito más adelante), se decidió separar el "
"panel de perfiles de emisión y ponerlo en su propio diálogo."

#: ..\python_docs\spladdoninternals.py:12
msgid ""
"Another big change in 2020 was removing unnecessary and problematic "
"features. For years, Window-Eyes users were supported by having a dedicated "
"command layout in SPL Assistant layer. As Window-Eyes usage has declined, "
"the dedicated command layout was removed. Another removed feature is time-"
"based (triggered) broadcast profiles as it became clear that defining "
"instant switch profiles were enough, coupled with design problems in the "
"feature itself that showed up in recent years. Just like add-on update "
"feature, time-based profiles feature will be described to provide historical "
"overview."
msgstr ""
"Otro gran cambio de 2020 fue la eliminación de características innecesarias "
"y problemáticas. Durante años, los usuarios de Window Eyes recibían soporte "
"mediante un diseño de órdenes dedicado en la capa del asistente de SPL. "
"Según ha ido decayendo el uso de Window Eyes, el diseño de órdenes dedicadas "
"se ha eliminado. Otra función eliminada es la de perfiles de emisión basados "
"en tiempo (disparados), ya que quedó claro que definir perfiles de cambio "
"instantáneo es suficiente, y la característica en sí tiene problemas de "
"diseño que se han descubierto en los últimos años. Al igual que la función "
"de actualización del complemento, la función de perfiles basados en tiempo "
"se describirá para proporcionar una visión general histórica."

#: ..\python_docs\spladdoninternals.py:13
msgid ""
"2021 may turn out to be a turning point for the add-on. I (Joseph Lee) will "
"be stepping down from maintaining this add-on. My hope is that new "
"maintainers (whoever might be) will step up and improve this add-on greatly."
msgstr ""
"2021 puede convertirse en un punto de inflexión para el complemento. Yo "
"(Joseph Lee) dejaré de mantener este complemento. Tengo la esperanza de que "
"los nuevos encargados de su mantenimiento (quienes quiera que sean) sigan "
"adelante y hagan fantásticas mejoras a este complemento."

#: ..\python_docs\spladdoninternals.py:14
msgid "## Introduction"
msgstr "## Introducción"

#: ..\python_docs\spladdoninternals.py:15
msgid ""
"If you are a radio broadcaster, you might be accustomed to activities "
"involved when producing a show. This may include playlist selection, "
"scheduling break notes, responding to requests, monitoring listener count "
"and encoding status and so on. To assist a broadcaster, a broadcast "
"automation program is used, and one of the popular apps is called "
"StationPlaylist Studio."
msgstr ""
"Si eres locutor de radio, podrías estar acostumbrado a las actividades "
"involucradas al producir un programa. Aquí se pueden incluir la selección de "
"la lista de reproducción, programación de notas de interrupción, respuesta a "
"peticiones, monitorización del número de oyentes y estado de la "
"codificación, entre otras. Para asistir a un locutor, se usa un programa de "
"automatización de la emisión, y uno de los más populares se llama "
"StationPlaylist Studio."

#: ..\python_docs\spladdoninternals.py:16
msgid ""
"In NVDA Add-on Internals: StationPlaylist, we'll learn about what "
"StationPlaylist Studio (and other StationPlaylist (SPL) suite of apps) is "
"and how the NVDA add-on works. You don't have to install or use the NVDA add-"
"on to understand the ins and outs of this powerful add-on (using the add-on "
"might help you better appreciate the defth of this material; for fuller "
"experience, it is handy to have the add-on source code in front of you as "
"you navigate this article). So let's get started by learning more about SPL "
"suite of applications."
msgstr ""
"En Complementos de NVDA vistos por dentro: StationPlaylist, aprenderemos qué "
"es Studio (y la suite de aplicaciones de SPL) y cómo funciona este "
"complemento de NVDA. No tienes que instalar o utilizar este potente "
"complemento para entender sus peculiaridades, (usar el complemento podría "
"ayudarte a apreciar la importancia de este material; para una experiencia "
"más completa, es útil que tengas el código fuente del complemento ante ti "
"mientras navegas por este artículo). Ahora, empecemos aprendiendo más sobre "
"la suite de aplicaciones SPL."

#: ..\python_docs\spladdoninternals.py:17
msgid ""
"Note: throughout this guide, unless specified otherwise, the terms "
"\"StationPlaylist\", \"SPL\", and \"Studio\" refer to the same thing."
msgstr ""
"Nota: a lo largo de esta guía, a menos que se especifique lo contrario, los "
"términos \"StationPlaylist\", \"SPL\" y \"Studio\" hacen referencia a la "
"misma cosa."

#: ..\python_docs\spladdoninternals.py:18
msgid "### Introducing StationPlaylist app suite and the NVDA add-on"
msgstr ""
"### Presentación de la suite de aplicaciones de StationPlaylist y el "
"complemento para NVDA"

#: ..\python_docs\spladdoninternals.py:19
msgid ""
"[StationPlaylist suite](www.stationplaylist.com) is a collection of programs "
"to help broadcasters plan, run, and do related activities around "
"broadcasting. The apps consist of Studio, Creator, Track Tool, Streamer and "
"others."
msgstr ""
"[La suite de StationPlaylist](www.stationplaylist.com) es una colección de "
"programas para ayudar a los locutores a planear, ejecutar y hacer "
"actividades relacionadas con la emisión. Las aplicaciones constan de Studio, "
"Creator, la herramienta de pista, Streamer y otras."

#: ..\python_docs\spladdoninternals.py:20
msgid ""
"StationPlaylist Studio is a broadcast automation software that helps "
"broadcasters schedule trakcs, play jingles and more. It includes support for "
"break notes, hourly playlist, track tagging and comes with tools to manage "
"track playback such as setting track intros. In studio 5.00 and later, it "
"includes its own stream encoder."
msgstr ""
"StationPlaylist Studio es un software de automatización de emisiones que "
"ayuda a los locutores a planificar pistas, reproducir jingles y más. Incluye "
"soporte para notas de interrupción, listas de reproducción por cada hora, "
"etiquetado de pistas y viene con herramientas para gestionar la reproducción "
"de pistas, como establecer la introducción de pista. En Studio 5.00 y "
"posteriores, se incluye un codificador de flujos propio."

#: ..\python_docs\spladdoninternals.py:21
msgid ""
"StationPlaylist Creator and Remote Voice Track (VT) are mostly used for "
"planning a show and designing playlists to be used by Studio. It can be used "
"to define spot groups, custom track categories and more. Whereas Creator is "
"limited to local playlists, Remote VT is used to manage playlists stored on "
"a remote computer."
msgstr ""
"StationPlaylist Creator y Remote Voice Track (VT) se usan mayoritariamente "
"para planificar un programa y diseñar listas de reproducción para que las "
"use Studio. Pueden usarse para definir grupos de spots, categorías "
"personalizadas de pista y más. Mientras que Creator se limita sólo a listas "
"de reproducción locales, Remote VT se usa para gestionar listas de "
"reproducción almacenadas en un ordenador remoto."

#: ..\python_docs\spladdoninternals.py:22
msgid ""
"StationPlaylist Track Tool is mainly used for managing tracks. It is often "
"employed to define introductions, cue points and other properties of tracks."
msgstr ""
"La herramienta de pista de StationPlaylist se usa principalmente para "
"gestionar pistas. Con frecuencia se emplea para definir introducciones, "
"puntos clave y otras propiedades de las pistas."

#: ..\python_docs\spladdoninternals.py:23
msgid ""
"StationPlaylist Streamer is useful for broadcasting a show with something "
"other than Studio. As such, it comes with support for various encoders and "
"digital signal processing (DSP) modules."
msgstr ""
"StationPlaylist Streamer es útil para emitir un programa con algo diferente "
"a Studio. Por tanto, viene con soporte para diversos codificadores y módulos "
"procesadores de señal digital (DSP)."

#: ..\python_docs\spladdoninternals.py:24
msgid ""
"In addition to the components above, StationPlaylist suite includes "
"additional tools such as VT Recorder, and a host of internal support modules "
"such as SPL Engine used for DSP processing and other tasks."
msgstr ""
"Además de los componentes anteriores, la suite de StationPlaylist incluye "
"herramientas adicionales como el grabador de pistas de voz, y un conjunto de "
"módulos internos de soporte como el motor SPL para procesar DSP y otras "
"tareas."

#: ..\python_docs\spladdoninternals.py:25
msgid ""
"Is Studio suite accessible? Surprisingly, yes. It is possible to use app "
"features without using screen reader scripts and add-ons. However, there are "
"times when a broadcaster would use scripts, such as announcing status "
"changes, monitoring track intros and endings, enhanced support for encoders "
"and so on, and NVDA add-on for StationPlaylist (usually refered to as SPL) "
"accomplishes this well."
msgstr ""
"¿Es la suite de Studio accesible? Sorprendentemente, sí. Es posible utilizar "
"las funciones de Studio sin usar scripts para lectores de pantalla y "
"complementos. Sin embargo, hay veces en las que un locutor usaría scripts, "
"como el anunciado de cambios de estado, monitorización de inicio y fin de "
"pistas, soporte mejorado para codificadores y demás, y el complemento de "
"NVDA para StationPlaylist (al que nos referiremos normalmente como SPL) "
"resuelve todo esto bien."

#: ..\python_docs\spladdoninternals.py:26
msgid "### StationPlaylist add-on: a history"
msgstr "### Complemento StationPlaylist: una historia"

#: ..\python_docs\spladdoninternals.py:27
msgid ""
"In 2011, Geoff Shang, a seasoned blind broadcaster, started working on SPL "
"Studio add-on. This early version (numbered 0.01) was developed to let NVDA "
"announce various status changes such as automation toggle and so on. This "
"initial version, co-developed by James Teh (a former lead developer of NVDA "
"screen reader) was considered a quick project, and further development "
"ceased until 2013."
msgstr ""
"En 2011, Geoff Shang, un locutor ciego experimentado, comenzó a trabajar en "
"el complemento para SPL Studio. Esta versión temprana (numerada como 0.01) "
"fue desarrollada para hacer que NVDA verbalizara diversos cambios de estado, "
"como la alternancia de automatización y así. Esta versión inicial, co-"
"desarrollada con James Teh (uno de los principales desarrolladores del "
"lector de pantalla NVDA) se consideró como un proyecto rápido, y el "
"desarrollo cesó hasta 2013."

#: ..\python_docs\spladdoninternals.py:28
msgid ""
"In 2013, I (Joseph Lee) received several emails regarding NVDA's support for "
"SPL Studio with a request for someone to write an add-on for it. As I was "
"still new to add-on development then (this was after I developed Control "
"Usage Assistant and GoldWave), I decided to take on this challenge in order "
"to learn more Python and to practice what I learned in computer science labs "
"at UC Riverside. I first downloaded the existing add-on (0.01) and installed "
"Studio 5.01 on my computer to learn more about this program and to gather "
"suggestions from SPL users. After little over a month of development and "
"preview releases, I released Studio add-on 1.0 in January 2014."
msgstr ""
"En 2013, yo (Joseph Lee) recibí varios correos relacionados con el soporte "
"de NVDA para SPL Studio con una petición de que alguien escribiera un "
"complemento para él. Como todavía era nuevo en el desarrollo de complementos "
"(esto vino después de que desarrollara Control Usage Assistant y GoldWave), "
"decidí aceptar este reto para aprender más sobre Python y practicar lo "
"aprendido en los laboratorios de ciencias de la computación en UC Riverside. "
"Primero descargué el complemento existente (0.01) e instalé Studio 5.01 en "
"mi ordenador para aprender más sobre este programa y recopilar sugerencias "
"de otros usuarios de SPL. Después de un mes de desarrollo y versiones de "
"prueba, liberé el complemento para Studio 1.0 en enero de 2014."

#: ..\python_docs\spladdoninternals.py:29
msgid ""
"Most of the early versions (1.x, 2.x, 3.x, released throughout 2014) were "
"mostly quick projects that bridged the gap between NVDA and other screen "
"readers (Brian Hartgen's JAWS scripts were my inspiration and have studied "
"documentation for Jeff Bishop's Window-Eyes scripts). These early versions, "
"supporting Studio 4.33 and later, were also used to fix bugs encountered by "
"Studio users - for instance, a broadcaster posted  a YouTube video "
"explaining how NVDA was not reading edit fields, which was fixed early on. "
"Later releases (4.x, 5.x, 6.x, released throughout 2015), further bridged "
"the gap with other screen readers and introduced unique features (for "
"instance, add-on 5.0 introduced a configuration dialog, and 6.0 introduced "
"concept of a broadcast profile). In late 2016, seeing that some of my add-"
"ons were using year.month scheme for versioning, I decided to switch SPL to "
"follow this model after receiving comments from the NVDA community. As of "
"time of writing, another significant shift took place in 20.x and 21.x "
"releases."
msgstr ""
"La mayoría de las primeras versiones (1.x, 2.x, 3.x, publicadas a lo largo "
"de 2014) fueron principalmente proyectos rápidos que reducían la brecha "
"entre NVDA y otros lectores de pantalla (los scripts para JAWS de Brian "
"Hartgen fueron mi fuente de inspiración y he estudiado la documentación de "
"los scripts para Window Eyes creados por Jeff Bishop). Estas primeras "
"versiones, que daban soporte a Studio 4.33 y versiones posteriores, se "
"utilizaron también para solucionar fallos encontrados por usuarios de Studio "
"- por ejemplo, un locutor subió un vídeo a YouTube explicando que NVDA no "
"estaba leyendo los cuadros de edición, cosa que se solucionó rápidamente. "
"Las siguientes versiones (4.x, 5.x, 6.x, publicadas a lo largo de 2015), "
"profundizaron en reducir las diferencias con otros lectores de pantalla e "
"introdujeron características únicas (por ejemplo, el complemento 5.0 vino "
"con un diálogo de configuración, y el 6.0 introdujo el concepto de perfil de "
"emisión). Ya avanzado 2016, viendo que algunos de mis complementos estaban "
"adoptando el esquema año.mes para las versiones, decidí cambiar SPL para que "
"siguiera este modelo tras recibir comentarios de la comunidad de NVDA. En el "
"momento en que escribo este artículo, se está llevando a cabo otra "
"transformación significativa en las versiones 20.x y 21.x."

#: ..\python_docs\spladdoninternals.py:30
msgid ""
"Highlights of past major releases and subsequent maintenance releases "
"include:"
msgstr ""
"Lo reseñable de las versiones pasadas principales y de mantenimiento es lo "
"siguiente:"

#: ..\python_docs\spladdoninternals.py:31
msgid "* 1.x: Initial release, added end of track alarm and other features."
msgstr ""
"* 1.x: versión inicial, añadida alarma de fin de pista y otras "
"características."

#: ..\python_docs\spladdoninternals.py:32
msgid "* 2.x: Track Finder and better routines to recognize Studio versions."
msgstr ""
"* 2.x: buscador de pista y procedimientos mejores para reconocer versiones "
"de Studio."

#: ..\python_docs\spladdoninternals.py:33
msgid ""
"* 3.x: first long-term support (LTS) release, Cart Explorer, support for SAM "
"Encoder and no need to stay on the encoder window during connection "
"attempts. This was the last version to support Studio 4.33."
msgstr ""
"* 3.x: primera versión de soporte extendido (lts), explorador de Cart, "
"soporte para el codificador SAM y eliminación de la necesidad de permanecer "
"en la ventana del codificador durante los intentos de conexión. Esta fue la "
"última versión que dio soporte a Studio 4.33."

#: ..\python_docs\spladdoninternals.py:34
msgid "* 4.x: Library scan, support for SPL encoder and studio 5.10."
msgstr ""
"* 4.x: escaneo de biblioteca, soporte para el codificador de SPL y Studio "
"5.10."

#: ..\python_docs\spladdoninternals.py:35
msgid "* 5.x: Track Dial, dedicated configuration dialog."
msgstr "* 5.x: dial de pista, diálogo de configuración dedicado."

#: ..\python_docs\spladdoninternals.py:36
msgid ""
"* 6.x: Broadcast profiles, metadata streaming, column search and "
"announcement reordering."
msgstr ""
"* 6.x: perfiles de emisión, flujo de metadatos, búsqueda de columnas y "
"reordenado de verbalizaciones."

#: ..\python_docs\spladdoninternals.py:37
msgid ""
"* 7.x: second LTS release, add-on updates, time-based profile switching, "
"Track Columns Explorer and others. This is the last version to support "
"Studio 5.01. Renamed to 15.x in late 2016."
msgstr ""
"* 7.x: segunda versión lts, actualizaciones del complemento, cambio de "
"perfiles basado en tiempo, explorador de columnas de pista y otros. Esta es "
"la última versión que da soporte a Studio 5.01. Se renombró a 15.x ya "
"entrado el 2016."

#: ..\python_docs\spladdoninternals.py:38
msgid ""
"* 16.10 (formerly 8.0): Columns explorer for Track Tool, selective data "
"resets."
msgstr ""
"* 16.10 (también conocida como 8.0): explorador de columnas para la "
"herramienta de pista, restablecimientos selectivos de datos."

#: ..\python_docs\spladdoninternals.py:39
msgid ""
"* 17.04 (formerly 9.0: vertical column navigation, playlist snapshots, "
"support for Studio 5.20."
msgstr ""
"* 17.04 (conocida como 9.0): navegación vertical por columnas, instantáneas "
"de listas de reproducción, soporte para Studio 5.20."

#: ..\python_docs\spladdoninternals.py:40
msgid ""
"* 17.08 (10.0: listener request notification, column header announcement "
"suppression. This is the last major version, with subsequent versions using "
"continuous delivery."
msgstr ""
"* 17.08 (10.0): notificación de solicitud de oyente, supresión de la "
"verbalización de cabeceras de columna. Esta es la última versión principal, "
"con las siguientes versiones usando entrega continua."

#: ..\python_docs\spladdoninternals.py:41
msgid ""
"* 17.12: end of support for old Windows releases, add-on settings "
"reorganization, extension points."
msgstr ""
"* 17.12: fin de soporte para versiones antiguas de Windows, reorganización "
"de los ajustes del complemento, puntos de extensión."

#: ..\python_docs\spladdoninternals.py:42
msgid ""
"* 18.06: responding to recent NVDA features, playlist transcripts, wxPython "
"4 support, partial playlist snapshots, expanding the scope of the add-on."
msgstr ""
"* 18.06: respuesta ante nuevas características de NVDA, transcripción de "
"listas de reproducción, soporte para WXPython 4, instantáneas parciales de "
"la lista de reproducción, expansión del ámbito del complemento."

#: ..\python_docs\spladdoninternals.py:43
msgid ""
"* 18.09: third LTS release, add-on settings panels, checkable list, wxPython "
"4."
msgstr ""
"* 18.09: tercera versión LTS, paneles de configuración del complemento, "
"lista con casillas de verificación, WXPython 4."

#: ..\python_docs\spladdoninternals.py:44
msgid ""
"* 19.01: add-on update feature removed, compatibility flags with future NVDA "
"releases."
msgstr ""
"* 19.01: función de actualización del complemento eliminada, indicadores de "
"compatibilidad para versiones futuras de NVDA."

#: ..\python_docs\spladdoninternals.py:45
msgid "* 19.07: renaming the add-on, settings reload/reset."
msgstr ""
"* 19.07: se renombra el complemento, recarga / restablecimiento de "
"configuración."

#: ..\python_docs\spladdoninternals.py:46
msgid ""
"* 20.02: Python 3, restructured encoders support and new encoders, Creator's "
"Playlist Editor support."
msgstr ""
"* 20.02: Python 3, soporte reestructurado de codificadores y nuevos "
"codificadores, soporte del editor de listas de reproducción de Creator."

#: ..\python_docs\spladdoninternals.py:47
msgid ""
"* 20.06: removed Window-Eyes support, time-based broadcast profiles facility "
"removed, support for Remote VT client."
msgstr ""
"* 20.06: se eliminaron el soporte para Window Eyes y la función de perfiles "
"de emisión basados en tiempo, soporte para el cliente Remote VT."

#: ..\python_docs\spladdoninternals.py:48
msgid ""
"* 20.09: fourth LTS release, pilot features removed, connecting to "
"individual encoders in SPL encoders, background encoder monitor registry."
msgstr ""
"* 20.09: cuarta versión de soporte extendido, se eliminan las "
"características piloto, conexión individual a codificadores en los "
"codificadores SPL, registro de monitorización del codificador en segundo "
"plano."

#: ..\python_docs\spladdoninternals.py:49
msgid "* 21.01: track property announcement changes, more lint fixes."
msgstr ""
"* 21.01: cambios en el anuncio de la propiedad de la pista, más correcciones "
"de estilo."

#: ..\python_docs\spladdoninternals.py:50
msgid ""
"* 21.06: compatibility with newer NVDA releases, type annotations and more "
"robust source code. This is the last version with planned new features and "
"bug fixes from me."
msgstr ""
"* 21.06: compatibilidad con versiones recientes de NVDA, anotaciones de "
"tipos y código fuente más robusto. Esta es mi última versión planeada con "
"nuevas funciones y fallos corregidos."

#: ..\python_docs\spladdoninternals.py:51
msgid ""
"* 22.01: control types refactor, internal refinements to configuration "
"management, remove profile caching mechanism as SSD technology has matured. "
"This is the last release from me."
msgstr ""
"* 22.01: refactorización de controlTypes, refinamiento interno de gestión de "
"la configuración, se elimina el mecanismo de caché de perfiles al "
"encontrarse más madura la tecnología SSD. Esta es la última versión por mi "
"parte."

#: ..\python_docs\spladdoninternals.py:52
msgid ""
"Throughout this article, you'll get a chance to see how the add-on works, "
"design philosophy and how the add-on is being developed, with glimpses into "
"the past and future. My hope is that this add-on internals article would be "
"a valuable reference for users and developers - for users to see the inner "
"workings of this add-on, and for developers to use this add-on as an example "
"of how an add-on is planned, implemented, tested, released and maintained."
msgstr ""
"A lo largo de este artículo, tendrás una oportunidad para ver cómo funciona "
"el complemento, la filosofía de diseño y cómo se desarrolla el complemento, "
"con vistas al pasado y al futuro. Espero que este artículo de complementos "
"vistos por dentro sea una referencia valiosa para usuarios y desarrolladores "
"- para los usuarios, que vean los trabajos internos de este complemento, y "
"para los desarrolladores, que usen este complemento como un ejemplo a la "
"hora de planear, implementar, probar, publicar y mantener un complemento."

#: ..\python_docs\spladdoninternals.py:53
msgid ""
"To download the add-on, go to https://addons.nvda-project.org/addons/"
"StationPlaylist.en.html."
msgstr ""
"Para descargar el complemento, ve a la sección de complementos que se "
"encuentra en nuestra web."

#: ..\python_docs\spladdoninternals.py:54
msgid ""
"## Design, code layout, layer sets and importance of Studio API and Studio "
"window handle"
msgstr ""
"## Diseño, estructura del código, conjuntos de capas e importancia de la api "
"de Studio y el manejador de ventana de Studio"

#: ..\python_docs\spladdoninternals.py:55
msgid "### Overall design and source code layout"
msgstr "### Diseño general y del código fuente"

#: ..\python_docs\spladdoninternals.py:56
msgid ""
"StationPlaylist add-on for NVDA consists of seven app modules (including two "
"app module packages) and a global plugin. Because Studio and Creator come "
"with Track Tool for managing tracks, the add-on includes an app module for "
"Track Tool in addition to the main app module package for Studio, as well as "
"an app module for StationPlaylist Creator. A fourth app module for Voice "
"Track Recorder is present which is used for event tracking purposes. Remote "
"VT client is the fifth app module and is mainly used to support remote "
"playlist editor. The other two app modules deal with Streamer and SPL DSP "
"Engine, with SPL Engine being an app module package due to inclusion of "
"encoders support module which is also used by Streamer."
msgstr ""
"El complemento de NVDA para StationPlaylist consta de siete módulos de "
"aplicación (incluyendo dos de ellos en forma de paquete) y una extensión "
"global. Ya que Studio y Creator vienen con la herramienta de pista para "
"gestionar pistas, el complemento incluye un módulo de aplicación para la "
"herramienta de pista además del módulo de aplicación principal para Studio, "
"así como un módulo de aplicación para StationPlaylist Creator. Se encuentra "
"presente un cuarto módulo de aplicación para la grabadora de pistas de voz, "
"usado con propósitos de seguimiento de eventos. El cliente Remote VT es el "
"quinto módulo de aplicación, y se usa principalmente para dar soporte al "
"editor remoto de listas de reproducción. Los otros dos módulos de aplicación "
"tratan con el motor DSP de SPL y Streamer, siendo el módulo de aplicación "
"del motor SPL un paquete debido a la inclusión del módulo de soporte de "
"codificadores, que también utiliza Streamer."

#: ..\python_docs\spladdoninternals.py:57
msgid ""
"The overall design is that of a partnership between the main Studio app "
"module and the Studio Utilities (SPLUtils) global plugin. Studio app module "
"performs things expected from scripts such as responding to key presses, "
"announcing status information, configuration management and so forth, while "
"the global plugin is responsible for running Studio commands from anywhere, "
"and in older add-on releases, for encoder support (the add-on supports SAM, "
"SPL, and AltaCast encoders). In reality, the global plugin is subordinate to "
"the app module, as the app module controls overall functionality of the add-"
"on and because the global plugin requires Studio to be running to unlock "
"some features (here, unlock means using layer commands and parts of encoder "
"support)."
msgstr ""
"El diseño general es una relación entre el módulo de aplicación principal de "
"Studio y la extensión global de utilidades de Studio (SPLUtils). El módulo "
"de aplicación de Studio hace cosas que se esperan de los scripts, como "
"reaccionar a pulsaciones de teclado, anunciar información de estado, gestión "
"de configuración y todo eso, mientras que la extensión global es responsable "
"de ejecutar órdenes de Studio desde cualquier sitio y, en versiones "
"anteriores del complemento, del soporte de los codificadores (el complemento "
"soporta los codificadores SAM, SPL y AltaCast). En realidad, la extensión "
"global es subordinada del módulo de aplicación, ya que el módulo de "
"aplicación controla la funcionalidad general del complemento y la extensión "
"global necesita que Studio esté en funcionamiento para desbloquear algunas "
"funciones (aquí, desbloquear significa usar la capa de órdenes y partes del "
"soporte de codificadoresÇ)."

#: ..\python_docs\spladdoninternals.py:58
msgid ""
"When it comes to hierarchy of app modules, Studio app module package is "
"ranked highest. This is because Studio app module is the oldest part of the "
"add-on, and it provides base services and blueprints for other app modules. "
"For instance, Creator and Track Tool rely on configuration facility provided "
"by Studio app module package for Columns Explorer (explained later), and "
"Voice Track (VT) Recorder app module cannot function properly without Studio "
"app module running. Even though SPL Engine and Streamer are independent of "
"Studio app module, they still require Studio app module to function (this is "
"especially the case with SPL Engine, as Studio loads splengine.exe, the DSP "
"Engine executable)."
msgstr ""
"Si nos centramos en la jerarquía de los módulos de aplicación, el paquete "
"del módulo de aplicación de Studio se encuentra en lo más alto. Esto se debe "
"a que el módulo de aplicación de Studio constituye la parte más antigua del "
"complemento, y proporciona servicios básicos y utilidades para otros "
"módulos. Por ejemplo, Creator y la herramienta de pista se apoyan en las "
"funciones de configuración proporcionadas por el paquete de módulo de "
"aplicación de Studio para el explorador de columnas (explicado más tarde), y "
"el módulo de aplicación de la grabadora de pistas de voz (vt) no puede "
"funcionar adecuadamente si el módulo de aplicación de Studio no está en "
"ejecución. Incluso aunque el motor de SPL y Streamer son independientes del "
"módulo de aplicación de Studio, aún necesitan que el módulo de aplicación de "
"Studio funcione (este es especialmente el caso del motor de SPL, ya que "
"Studio carga splengine.exe, el ejecutable del motor DSP)."

#: ..\python_docs\spladdoninternals.py:59
msgid ""
"In short, all components of StationPlaylist add-on emphasize studio app "
"module - although many components are independent of Studio, they still "
"reference it for various reasons. Thus, Studio serves as the bridge that "
"connects various add-on features together."
msgstr ""
"En resumen, todos los módulos del complemento de StationPlaylist enfatizan "
"el módulo de aplicación de Studio - aunque muchos componentes son "
"independientes de Studio, aún hacen referencia a él por diversas razones. "
"Por tanto, Studio sirve como el puente que conecta diversas características "
"del complemento entre sí."

#: ..\python_docs\spladdoninternals.py:60
msgid "The source code consists of:"
msgstr "El código fuente consta de:"

#: ..\python_docs\spladdoninternals.py:61
msgid ""
"* appModules: This folder contains the main splstudio (app module) package "
"and the app modules for Track Tool, Creator, VT Recorder, Remote VT client, "
"SPL DSP Engine (package), and Streamer."
msgstr ""
"* appModules: esta carpeta contiene el paquete (módulo de aplicación) "
"principal splstudio y los módulos de aplicación para la herramienta de "
"pista, Creator, la grabadora de pistas de voz, el cliente Remote VT, el "
"motor DSP (paquete) y Streamer."

#: ..\python_docs\spladdoninternals.py:62
msgid ""
"* The SPL Studio package consists of various modules, which include __init__ "
"(main app module and track item classes), configuration manager and user "
"interfaces (splconfig and splconfui) and miscellaneous services (splmisc) as "
"well as support modules and various wave files used by the add-on."
msgstr ""
"* El paquete SPL Studio consta de varios módulos, en los que se incluyen "
"__init__ (módulo de aplicación principal y clases de elemento de pista), el "
"gestor de configuraciones y las interfaces de usuario (splconfig y "
"splconfui) y servicios misceláneos (splmisc), así como módulos de soporte y "
"diversos archivos wav usados por el complemento."

#: ..\python_docs\spladdoninternals.py:63
msgid ""
"* The SPL Engine package consists of main Engine module and encoder support "
"module."
msgstr ""
"* El paquete del motor de SPL consta del módulo del motor principal y el "
"módulo de soporte del codificador."

#: ..\python_docs\spladdoninternals.py:64
msgid ""
"* The main app module file is divided into sections. First, the overlay "
"classes for track items are defined, then comes the app module, further "
"divided into four sections: fundamental methods (constructor, events and "
"others), time commands (end of track, broadcaster time, etc.), other "
"commands (track Finder, cart explorer and others) and SPL Assistant layer. "
"This allows me to identify where a bug is coming from and to add features in "
"appropriate sections."
msgstr ""
"* El archivo del módulo de aplicación principal está dividido en secciones. "
"Primero, se definen las clases de superposición para elementos de pista, "
"después viene el módulo de aplicación, dividido en cuatro secciones: métodos "
"fundamentales (constructor, eventos y otros), órdenes de tiempo (fin de "
"pista, tiempo del locutor, etc.), otras órdenes (buscador de pista, "
"explorador Cart y otros) y la capa de SPL Assistant. Esto me permite "
"identificar de dónde viene un fallo y añadir características en las "
"secciones apropiadas."

#: ..\python_docs\spladdoninternals.py:65
msgid ""
"* globalPlugins: This folder contains SPLUtils module, consisting of main "
"global plugin code and SPL Controller layer."
msgstr ""
"* globalPlugins: esta carpeta contiene el paquete SPLUtils, que consta del "
"código de la extensión principal y la capa del controlador de SPL."

#: ..\python_docs\spladdoninternals.py:66
msgid ""
"Note: until 2019, encoder support was part of SPL Utils. In 2020, it is part "
"of SPL DSP Engine app module package."
msgstr ""
"Nota: hasta 2019, el soporte de codificadores era parte de las utilidades de "
"SPL. En 2020, es parte del paquete del módulo de aplicación del motor DSP de "
"SPL."

#: ..\python_docs\spladdoninternals.py:67
msgid "### Design philosophy"
msgstr "### Filosofía del diseño"

#: ..\python_docs\spladdoninternals.py:68
msgid ""
"When I set out to write the add-on in 2013, I put forth certain things the "
"add-on should adhere to, including:"
msgstr ""
"Cuando me puse a escribir el complemento en 2013, Puse en marcha ciertas "
"cosas que el complemento debe cumplir, incluyendo:"

#: ..\python_docs\spladdoninternals.py:69
msgid ""
"* Consistency: The add-on should have a consistent interface and command "
"structure. Interface includes various GUI's such as add-on configuration "
"dialog. For layer commands, I tried using native Studio command assignments."
msgstr ""
"* Consistencia: el complemento debería tener una interfaz y estructura de "
"órdenes consistente. La interfaz incluye varias GUI's como el diálogo de "
"configuración del complemento. Para las órdenes de capa, intenté usar la "
"asignación de órdenes nativa de Studio."

#: ..\python_docs\spladdoninternals.py:70
msgid ""
"* Extensibility: The add-on should be organized and written in such a way "
"that permits easy extensibility, hence the app module and the global plugin "
"were divided into submodules, with each of them being a specialist of some "
"kind (such as configuration management)."
msgstr ""
"* Extensibilidad: el complemento debería estar organizado y escrito de tal "
"manera que permita una fácil extensibilidad, y por esto el módulo de "
"aplicación y la extensión global se dividieron en submódulos, cada uno de "
"ellos especializado en una cosa concreta (como la gestión de la "
"configuración)."

#: ..\python_docs\spladdoninternals.py:71
msgid ""
"* Separation of concerns: Coupled with extensibility, this allowed me to "
"provide just needed commands at the right time, which resulted in two layer "
"command sets (explained below)."
msgstr ""
"* Separación de conceptos: junto con la extensibilidad, esto me permitió "
"proporcionar las órdenes necesarias en el momento adecuado, lo que resultó "
"en dos capas de conjuntos de órdenes (se explica más abajo)."

#: ..\python_docs\spladdoninternals.py:72
msgid ""
"* Easy to follow source code: Although some may say excessive documentation "
"is a noise, I believe it is important for a developer to understand how a "
"function or a module came about. Also, I have used and read user guides for "
"other screen reader scripts to better understand how a feature worked and "
"come up with some enhancements to a point where I found some major bugs with "
"JAWS scripts (one of them, which I hope Brian patched by now is microphone "
"alarm where the alarm would go off despite the fact that microphone was "
"turned off before alarm timeout has expired)."
msgstr ""
"* Código fuente fácil de seguir: aunque algunos puedan decir que la "
"documentación excesiva es ruido, creo que para un desarrollador es "
"importante entender cómo y por qué vino una función o módulo. También he "
"usado y leído guías de usuario de scripts para otros lectores de pantalla "
"para entender mejor cómo funcionaba una característica y hacerle algunas "
"mejoras en puntos donde encontraba fallos graves, como con los scripts para "
"JAWS (uno de ellos, que espero que Bryan haya parcheado por ahora, es la "
"alarma de micrófono, donde la alarma se apagaría a pesar del hecho que el "
"micrófono ya estaba apagado antes de que acabara la cuenta atrás de la "
"alarma)."

#: ..\python_docs\spladdoninternals.py:73
msgid ""
"* Unique feature labels: One way to stand out was to give features "
"interesting names. For instance, during add-on 3.0 development, I decided to "
"give cart learn mode a name that better reflects what the feature does: Cart "
"Explorer to explore cart assignments. Same could be set about NVDA's "
"implementation of enhanced arrow keys (called Track Dial, as the feature is "
"similar to flipping a dial on a remote control)."
msgstr ""
"* Etiquetas únicas de características: una manera de destacar el complemento "
"fue dar nombres interesantes a las características. Por ejemplo, durante el "
"desarrollo del complemento 3.0, decidí dar al modo de aprendizaje de cart un "
"nombre que reflejara mejor lo que hace esa función: explorador Cart para "
"explorar las asignaciones de Cart. Lo mismo podría hacerse con la "
"implementación de NVDA de las teclas de flecha mejoradas (llamada dial de "
"pista, ya que esta función es similar a girar una ruleta en un mando a "
"distancia)."

#: ..\python_docs\spladdoninternals.py:74
msgid ""
"* Extensive collaboration and feedback cycle between users and developers: I "
"believed that the real stars of the show were not the add-on code files, but "
"broadcasters who'll use various add-on features. Because of this, I worked "
"with users early on, and their continued feedback shapes future add-on "
"releases. This collaboration and feedback cycle also helped me (the add-on "
"author) understand how the add-on was used and to plan future features to "
"meet the needs of broadcasters who may use this add-on in various scenarios "
"(a good example is broadcast profiles, as you'll see in add-on configuration "
"section)."
msgstr ""
"* Extenso ciclo de colaboración y retroalimentación entre usuarios y "
"desarrolladores: yo creía que las auténticas estrellas del espectáculo no "
"eran los archivos de código del complemento, sino los locutores que usarían "
"diversas características del complemento. Por ello, trabajé con los usuarios "
"desde bien temprano, y sus comentarios continuos dan forma a las versiones "
"futuras del complemento. Este ciclo de colaboración y retroalimentación "
"también me ayudó a mí (el autor del complemento) a entender cómo se usaba el "
"complemento y a planear futuras características para satisfacer las "
"necesidades de los locutores que pueden usar este complemento en diversos "
"escenarios (un buen ejemplo son los perfiles de emisión, como verás en la "
"sección de configuración del complemento)."

#: ..\python_docs\spladdoninternals.py:75
msgid "### Why two layer sets?"
msgstr "### ¿Por qué dos capas de conjuntos?"

#: ..\python_docs\spladdoninternals.py:76
msgid ""
"When I first sat down to design the add-on, I knew I had to write both an "
"app module and a global plugin (to perform Studio commands from anywhere), "
"which led to defining two layer command sets for specific purposes:"
msgstr ""
"Cuando al principio me senté a diseñar el complemento, ya sabía que tendría "
"que escribir un módulo de aplicación y una extensión global (para ejecutar "
"órdenes de Studio desde cualquier sitio), lo que llevó a definir dos capas "
"de conjuntos de órdenes con propósitos específicos:"

#: ..\python_docs\spladdoninternals.py:77
msgid ""
"* SPL Assistant: This layer command set is available in the app module and "
"is intended to obtain status information and to manage app module features. "
"I called this Assistant because this layer serves as an assistant to a "
"broadcaster in reading various status information. More details can be found "
"later in this article."
msgstr ""
"* Asistente de SPL: esta capa de conjunto de órdenes está disponible en el "
"módulo de aplicación y está pensada para obtener información de estado y "
"para gestionar las características del módulo de aplicación. La llamé "
"asistente porque esta carpa sirve como el asistente de un locutor al leer "
"diversa información de estado. Se pueden encontrar más detalles más adelante "
"en este artículo."

#: ..\python_docs\spladdoninternals.py:78
msgid ""
"* SPL Controller: This layer is for the global plugin and performs Studio "
"commands from anywhere. I called this \"controller\" because it controls "
"various functions of Studio from other programs. More details will be "
"provided below."
msgstr ""
"* Controlador de SPL: esta capa es para la extensión global y ejecuta "
"órdenes de Studio desde cualquier parte. La llamé \"controlador\" porque "
"controla varias funciones de Studio desde otros programas. Más abajo se "
"darán más detalles."

#: ..\python_docs\spladdoninternals.py:79
msgid ""
"In the early days, I enforced this separation, but in add-on 6.0, it is "
"possible to invoke SPL Assistant layer by pressing the command used to "
"invoke SPL Controller. In add-on 7.0, it is possible for SPL Assistant to "
"emulate commands from other screen reader scripts, and the mechanics of it "
"is covered later in this article."
msgstr ""
"En los primeros días reforcé esta separación, pero en el complemento 6.0 es "
"posible invocar la capa del asistente de SPL pulsando la orden que se usa "
"para invocar al controlador de SPL. En el complemento 7.0, es posible para "
"el asistente de SPL emular órdenes de scripts para otros lectores de "
"pantalla, y los mecanismos que lo permiten se cubren más adelante en este "
"artículo."

#: ..\python_docs\spladdoninternals.py:80
msgid "### The \"magic\" behind layer commands"
msgstr "### La \"magia\" tras las órdenes de capa"

#: ..\python_docs\spladdoninternals.py:81
msgid ""
"In order for layer commands to work, I borrowed code from another add-on: "
"Toggle and ToggleX by Tyler Spivey. Toggle/ToggleX allows one to toggle "
"various formatting announcement settings via a layer command set. It works "
"like this:"
msgstr ""
"Para que las órdenes de capa funcionaran, tomé prestado código de otro "
"complemento: Toggle y ToggleX, de Tyler Spivey. Toggle / ToggleX permite "
"alternar varios ajustes de verbalización de formato a través de un conjunto "
"de capa de órdenes. Trabaja de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:82
msgid ""
"* Dynamic Command:script binding and removal: It is possible to bind "
"gestures dynamically via bindGesture/bindGestures method for an app module "
"or a global plugin (bindGesture binds a single command to a script, whereas "
"bindGestures binds commands to scripts from a gestures map or another "
"container). To remove gesture map dynamically, the main/layer gestures combo "
"was cleared, then the main gestures were bound."
msgstr ""
"* Orden dinámica: asociación y eliminación de script: es posible asociar "
"gestos dinámicamente a través del método bindGesture / bindGestures para un "
"módulo de aplicación o una extensión global (bindGesture asocia una única "
"orden a un script, mientras que bindGestures asocia órdenes a scripts desde "
"un mapa de gestos u otro contenedor). Para eliminar el mapa de gestos "
"dinámicamente, se limpiaba la combinación de gestos principales / de capa, y "
"después se asociaban los gestos principales."

#: ..\python_docs\spladdoninternals.py:83
msgid ""
"* Defining extra gesture maps in the app module/global plugin: Normally, an "
"app module or a global plugin that accepts keyboard input uses a single "
"gestures map (called __gestures; a map is another term for dictionaries or "
"associative array where there is a value tied to a key). But in order for "
"layers to work, a second gestures map was provided to store layer commands "
"(command and the bound script of the form \"command\":\"script\"). In recent "
"nVDA releases, script decorator is used for main commands while gestures map "
"is used for layer commands."
msgstr ""
"* Definición de mapas extra de gestos en el módulo de aplicación / extensión "
"global: normalmente, un módulo de aplicación o extensión global que acepta "
"entrada por teclado usa un mapa de gestos único (llamado __gestures; un mapa "
"es otro término para diccionarios o arrays asociativos donde hay un valor "
"asociado a una clave). Pero para que las capas funcionen, se ofrecía un "
"segundo mapa de gestos para almacenar las órdenes de capa (la orden y el "
"script asociado de la forma \"orden\":\"script\"). En versiones recientes de "
"NVDA, se usa el decorador script para las órdenes principales, mientras que "
"se usa un mapa de gestos para las órdenes de capa."

#: ..\python_docs\spladdoninternals.py:84
msgid ""
"* Wrapped functions: Tyler used \"wraps\" decorator from functools to wrap "
"how \"finally\" function is called from within the layer set (this was "
"needed to remove bindings for layer commands after they are done). Also, a "
"custom implementation of getScript function (app module/global plugin) was "
"used to return either the main script of the layer version depending on "
"context."
msgstr ""
"* Funciones envueltas: Tyler usaba el decorador \"wraps\" de functools para "
"encapsular cómo se llama a la función \"finalmente\" en el conjunto de capa "
"(esto era necesario para eliminar asociaciones de órdenes de capa después de "
"ejecutarse). Además, se usó una implementación personalizada de la función "
"getScript (módulo de aplicación / extensión global) para devolver el script "
"principal de la versión de la capa dependiendo del contexto."

#: ..\python_docs\spladdoninternals.py:85
msgid "A typical layer command execution is as follows:"
msgstr "La ejecución típica de las órdenes de capa es como sigue:"

#: ..\python_docs\spladdoninternals.py:86
msgid ""
"1. First, assign a command to a layer (entry) command (add-on 2.0 and later; "
"add-on 1.x used NVDA+Grave for SPL Controller and Control+NVDA+Grave for the "
"Assistant layer; removed in 2.0 to prevent conflicts with language-specific "
"gestures)."
msgstr ""
"1. Primero, se asigna una orden a una capa (entrada) orden (complemento 2.0 "
"y posterior; el complemento 1.x usaba NVDA+` para el controlador de SPL y "
"ctrl+NVDA+` para la capa del asistente; se eliminó en la 2.0 para prevenir "
"conflictos con gestos específicos del idioma)."

#: ..\python_docs\spladdoninternals.py:87
msgid ""
"2. You press the layer entry command. This causes the app module/global "
"plugin to perform the following:"
msgstr ""
"2. Pulsas la orden de entrada de la capa. Esto causa que el módulo de "
"aplicación o extensión global haga lo siguiente:"

#: ..\python_docs\spladdoninternals.py:88
msgid ""
"\t1. Layer conditions are checked. Until add-on 6.x, the app module wanted "
"to see if you are in the Playlist Viewer (relaxed in add-on 7.0), and for "
"the global plugin, checks if Studio is running."
msgstr ""
"\t1. Se comprueban las condiciones de capa. Hasta el complemento 6.x, el "
"módulo de aplicación quería ver si estabas en el visor de listas de "
"reproducción (se relajó en el complemento 7.0), y para la extensión global, "
"comprueba si Studio está en ejecución."

#: ..\python_docs\spladdoninternals.py:89
msgid ""
"\t2. Sets a flag telling NVDA that the Assistant/Controller layer is active."
msgstr ""
"\t2. Se establece un indicador para decirle a NVDA que la capa del "
"asistente / controlador está activa."

#: ..\python_docs\spladdoninternals.py:90
msgid ""
"\t3. Adds gestures for the layer set to the main gestures map via "
"bindGestures function. In case of screen reader emulation in SPL Assistant, "
"the appropriate gestures map is selected."
msgstr ""
"\t3. Se añaden los gestos del conjunto de la capa al mapa principal de "
"gestos a través de la función bindGestures. En el caso de la emulación de "
"lector de pantalla en el asistente de SPL, se selecciona el mapa apropiado "
"de gestos."

#: ..\python_docs\spladdoninternals.py:91
msgid ""
"3. You press a command in the layer set (such as A from Assistant to hear "
"automation status, or press A to turn automation on if using SPL Controller "
"layer). Depending on how the layer script is implemented, it either calls "
"Studio API (for SPL Controller layer and for some Assistant commands) or "
"simulates object navigation to fetch needed information (Assistant layer). "
"In the app module, for performance reasons, the object is cached. More "
"details on mechanics of this procedure in subsequent sections."
msgstr ""
"3. Pulsas una orden en el conjunto de la capa (como la A de asistente para "
"oír el estado de la automatización, o la A para activar la automatización si "
"se usa la capa del controlador de SPL). Dependiendo de cómo esté "
"implementado el script de capa, llama a la api de Studio (para la capa de "
"controlador de SPL y algunas órdenes del asistente) o bien simula navegación "
"de objetos para recuperar la información necesaria (capa del asistente). En "
"el módulo de aplicación, por razones de rendimiento, el objeto se mete en "
"caché. Hay más detalles de los mecanismos de este procedimiento en las "
"siguientes secciones."

#: ..\python_docs\spladdoninternals.py:92
msgid ""
"4. After the layer command is done, it calls \"finish\" function (app module/"
"global plugin) to perform clean up actions such as:"
msgstr ""
"4. Después de que se haya hecho la orden de capa, se llama a la función "
"\"finish\" (módulo de aplicación / extensión global) para realizar acciones "
"de limpieza tales como:"

#: ..\python_docs\spladdoninternals.py:93
msgid "\t* Clears layer flags."
msgstr "\t* Limpiar los indicadores de capa."

#: ..\python_docs\spladdoninternals.py:94
msgid ""
"\t* Removes the \"current\" gestures (main gestures and layer commands) and "
"reassigns it to the main gestures map (this is dynamic binding removal)."
msgstr ""
"\t* eliminar los gestos \"actuales\" (gestos principales y gestos de capa) y "
"reasignarlos al mapa principal de gestos (esto se llama eliminación dinámica "
"de asociaciones)."

#: ..\python_docs\spladdoninternals.py:95
msgid ""
"\t* Performs additional actions depending on context (for example, if Cart "
"Explorer was in use)."
msgstr ""
"\t* Realizar acciones adicionales dependiendo del contexto (por ejemplo, si "
"el explorador cart estaba en uso)."

#: ..\python_docs\spladdoninternals.py:96
msgid "### The importance of Studio window handle and Studio API"
msgstr ""
"### La importancia del manejador de ventana de Studio y la api de Studio"

#: ..\python_docs\spladdoninternals.py:97
msgid ""
"In order to use services offered by Studio, one has to use Studio API, which "
"in turn requires one to keep an eye on window handle to Studio (in Windows "
"API, a window handle (just called handle) is a reference to something, such "
"as a window, a file, connection routines and so on). This is important if "
"one wishes to perform Studio commands from other programs (Studio uses "
"messages to communicate with the outside program in question via user32."
"dll's SendMessage function)."
msgstr ""
"Para usar los servicios que ofrece Studio, se debe utilizar la api de "
"Studio, que básicamente necesita que tengamos vigilado el manejador de "
"ventana de Studio (en la api de Windows, un manejador de ventana "
"(simplemente llamado manejador) es una referencia a algo, como a una "
"ventana, un archivo, procedimientos de conexión y así sucesivamente). Es "
"importante si se desean ejecutar órdenes de Studio desde otros programas "
"(Studio usa mensajes para comunicarse con el programa externo en cuestión "
"mediante la función SendMessage de user32.dll)."

#: ..\python_docs\spladdoninternals.py:98
msgid ""
"Starting from add-on 7.0, one of the activities the app module performs at "
"startup (besides announcing the version of Studio you are using) is to look "
"for the handle to Studio's main window until it is found (this is done via a "
"thread which calls user32.dll's FindWindowW (FindWindowA until late 2018 as "
"explained below) function every second), and once found, the app module "
"caches this information for later use. A similar check is performed by SPL "
"Controller command, as without this, SPL Controller is useless (as noted "
"earlier). Because of the prominence of the Studio API and the window handle, "
"one of the first things I do whenver new versions of Studio is released is "
"to ask for the latest Studio API and modify the app module and/or global "
"plugin accordingly."
msgstr ""
"Desde el complemento 7.0, una de las actividades que realiza el módulo de "
"aplicación cuando se inicia (además de verbalizar la versión de Studio que "
"estás usando) es buscar el manejador de la ventana principal de Studio hasta "
"que lo encuentra (esto se hace mediante un hilo que llama a la función "
"FindWindowW (FindWindowA hasta finales de 2018 como se explica debajo) de "
"user32.dll cada segundo), y una vez que lo encuentra, el módulo de "
"aplicación guarda esta información para uso futuro. El controlador SPL "
"realiza una comprobación similar, ya que sin el manejador, el controlador de "
"SPL es inútil (como se ha explicado antes). Debido a la importancia de la "
"api de Studio y el manejador de ventana, una de las primeras cosas que hago "
"cada vez que se publica una nueva versión de Studio es pedir la última api "
"de Studio y modificar el módulo de aplicación y / o la extensión global "
"apropiadamente."

#: ..\python_docs\spladdoninternals.py:99
msgid "#### FindWindowA versus FindWindowW"
msgstr "#### FindWindowA frente a FindWindowW"

#: ..\python_docs\spladdoninternals.py:100
msgid ""
"In the old days of Windows (1990's), programs were not ready to support "
"Unicode when Windows itself did. To support programs that are not Unicode-"
"aware, Microsoft defined two versions of a given Windows API function. For "
"example, there were two versions of FindWindow function, the difference "
"being the final character as follows:"
msgstr ""
"En los viejos tiempos de Windows (años 90), los programas no estaban listos "
"para dar soporte a Unicode cuando el propio Windows lo hizo. Para dar "
"soporte a programas que no están preparados para Unicode, Microsoft definió "
"dos versiones de una función dada de la API de Windows. Por ejemplo, había "
"dos versiones de la función FindWindow, siendo la diferencia su carácter "
"final, como se explica a continuación:"

#: ..\python_docs\spladdoninternals.py:101
msgid "* A: ANSI version meant for legacy programs (e.g. FindWindowA)."
msgstr ""
"* A: versión ANSI hecha para programas antiguos (por ejemplo, FindWindowA)."

#: ..\python_docs\spladdoninternals.py:102
msgid "* W: Wide char (Unicode) character version (e.g. FindWindowW)."
msgstr ""
"* W: versión para caracteres Wide (Unicode) (por ejemplo, FindWindowW)."

#: ..\python_docs\spladdoninternals.py:103
msgid ""
"In reality, programs call FindWindow function, and the appropriate \"version"
"\" was chosen based on overall character representation macro as specified "
"by the program. For example, if the program was unicode-aware, when "
"FindWindow is called, Windows internally calls FindWindowW."
msgstr ""
"En realidad, los programas llaman a la función FindWindow, y se elige la "
"\"versión\" apropiada basada en la macro de representación de caracteres "
"general como la especifica el programa. Por ejemplo, si el programa "
"estuviese preparado para Unicode, al llamar a FindWindow, Windows llamaría "
"internamente a FindWindowW."

#: ..\python_docs\spladdoninternals.py:104
msgid ""
"Until 2018, Studio app module and other components of the add-on called "
"FindWindowA due to the fact that, in Python 2, a string is a read-only array "
"of ANSI characters. Python 3 (and if a string is prefixed with \"u\" in "
"Python 2) uses immutable array of Unicode characters for strings. "
"Internally, NVDA expects Unicode strings for the function that wraps "
"FindWindow function (located in winUser module), thus mimicking Python 3 "
"behavior. StationPlaylist add-on adopted FindWindowW behavior in late 2018, "
"but the wrapper provided by NVDA is not used due to incorrect error checking "
"behavior in NVDA (if window handle is 0 (NULL), success error is raised, "
"which goes against specifications from Windows API; no longer the case in "
"NVDA 2019.3/Python 3)."
msgstr ""
"Hasta el 2018, el módulo de aplicación de Studio y otros componentes del "
"complemento llamaban a FindWindowA debido al hecho de que, en Python 2, una "
"cadena es un array de sólo lectura de caracteres ANSI. Python 3 (y si se "
"crea una cadena en Python 2 prefijada con la \"u\") usa un array inmutable "
"de caracteres Unicode para las cadenas. Internamente, NVDA espera cadenas "
"Unicode para la función que envuelve a FindWindow (ubicada en el módulo "
"winUser), imitando por tanto al comportamiento en Python 3. El complemento "
"de StationPlaylist adoptó el comportamiento de FindWindowW a finales de "
"2018, pero no se usa la envoltura proporcionada por NVDA debido al "
"comportamiento incorrecto al comprobar errores en NVDA (si el manejador de "
"ventana es 0 (NULL), se lanza un código de error que indica éxito, que va en "
"contra de las especificaciones de la API de Windows; ya no se da el caso en "
"NVDA 2019.3 / Python 3)."

#: ..\python_docs\spladdoninternals.py:105
msgid "## Life of the SPL app module"
msgstr "## Vida del módulo de aplicación de SPL"

#: ..\python_docs\spladdoninternals.py:106
msgid ""
"Note: For the rest of this article, you'll see some portions of the source "
"code to let you better understand how something works (mostly pseudo code "
"will be provided). Also, certain things will require explaining how NVDA "
"Core (the screen reader itself) works (so you'll learn several things at "
"once)."
msgstr ""
"Nota: durante el resto de este artículo, verás algunas porciones del código "
"fuente para hacerte entender mejor cómo funciona algo (mayoritariamente se "
"proporcionará pseudocódigo). Además, para algunas cosas será necesario "
"explicar cómo funciona el núcleo de NVDA (el lector de pantalla en sí) (por "
"lo que aprenderás muchas cosas de una vez)."

#: ..\python_docs\spladdoninternals.py:107
msgid "### SPL Studio app module and friends: design and code overview"
msgstr ""
"### Módulo de aplicación de SPL Studio y amigos: descripción del diseño y "
"del código"

#: ..\python_docs\spladdoninternals.py:108
msgid ""
"As noted previously, the SPL Studio app module (splstudio/__init__.py) and "
"friends (other app modules) consists of several sections. These include "
"(from top to bottom):"
msgstr ""
"Como se ha indicado antes, el módulo de aplicación de SPL Studio (splstudio/"
"__init__.py) consta de varias secciones. Estas incluyen (de arriba a abajo):"

#: ..\python_docs\spladdoninternals.py:109
msgid ""
"* Imports: Many modules from Python packages and from NVDA screen reader are "
"imported here, including IAccessible controls support, configuration manager "
"and so on."
msgstr ""
"* Importaciones: aquí se importan muchos módulos de diversos paquetes Python "
"y del lector de pantalla NVDA, incluyendo soporte para controles de "
"IAccessible, gestor de configuración y así sucesivamente."

#: ..\python_docs\spladdoninternals.py:110
msgid ""
"* Layer command wrapper: I talked about how layer commands work in a "
"previous section, and the \"finally\" function at the top is the one that "
"makes this possible."
msgstr ""
"* Envoltura de orden de capa: ya dije en un capítulo anterior cómo "
"funcionaban las órdenes de capa, y la función \"finally\" al principio es la "
"que hace esto posible."

#: ..\python_docs\spladdoninternals.py:111
msgid ""
"* Few helper functions and checks: This includes a flag specifying minimum "
"version of Studio needed, the cached value for Studio window handle (SPLWin) "
"and place holders for threads such as microphone alarm timer (more on this "
"in threads section). This section also includes helper functions such as "
"\"messageSound\" (displays a message on a braille display and plays a wave "
"file) and other helper functions."
msgstr ""
"* Unas pocas comprobaciones y funciones auxiliares: aquí se incluye un "
"indicador que especifica la mínima versión de Studio requerida, el valor "
"almacenado para el manejador de ventana de Studio (SPLWin), y referencias "
"para hilos como el temporizador de alarma del micrófono (más sobre esto en "
"la sección de hilos). Esta sección también incluye funciones auxiliares como "
"\"messageSound\" (muestra un mensaje en una pantalla Braille y reproduce un "
"archivo wav) y otras funciones auxiliares."

#: ..\python_docs\spladdoninternals.py:112
msgid ""
"* Track item overlay classes: three classes are defined for various "
"purposes. The first is a base class that provides commands and services "
"across Studio and other apps, while other two classes provide support for "
"tracks found throughout Studio (one is a general track items class, the "
"other is specific to playlist viewer). We'll come back to these objects "
"later."
msgstr ""
"* Clases de superposición del elemento de pista: se definen tres clases con "
"diversos propósitos. La primera es una clase base que proporciona órdenes y "
"servicios a través de Studio y otras aplicaciones, mientras que las otras "
"dos clases proporcionan soporte para las pistas que se encuentran a lo largo "
"de Studio (una es una clase general de elementos de pista, la otra es "
"específica del visor de listas de reproducción). Volveremos a estos objetos "
"más tarde."

#: ..\python_docs\spladdoninternals.py:113
msgid ""
"* App module class: This is the core of not only the app module, but the "
"entire add-on package. The app module class (appModules.splstudio.AppModule) "
"is further divided into sections as described in add-on design chapter."
msgstr ""
"* Clase del módulo de aplicación: este es el núcleo no sólo del módulo de "
"aplicación, sino del paquete del complemento entero. La clase del módulo de "
"aplicación (appModules.splstudio.AppModule) está a su vez dividida en "
"secciones como se describe en el capítulo de diseño del complemento."

#: ..\python_docs\spladdoninternals.py:114
msgid ""
"For Studio's colleagues (Creator, Track Tool, Remote VT client), they "
"consist of sections listed above except layer command wrapper, and track "
"item classes are simplified. For VT Recorder, because it controls certain "
"internal behaviors of Studio app module when it starts, only the constructor "
"and terminate methods (see below) are provided. For Streamer and DSP Engine, "
"encoder specific workarounds are present."
msgstr ""
"Los compañeros de Studio (Creator, herramienta de pista, cliente Remote VT) "
"se explican en las secciones listadas arriba excepto la capa de envoltura de "
"órdenes, y se han simplificado las clases de elemento de pista. Ya que la "
"grabadora de pistas de voz controla ciertos aspectos internos del módulo de "
"aplicación de Studio al arrancar, sólo se proporcionan el constructor y el "
"método terminate (mira más abajo). Para Streamer y el motor DSP, se "
"encuentran presentes soluciones específicas del codificador."

#: ..\python_docs\spladdoninternals.py:115
msgid ""
"Let's now tour the lifecycle of the app module object in question: before "
"and during app module initialization, activities performed while the app "
"module is active, death and (until 2018) add-on updates."
msgstr ""
"Recorramos ahora el ciclo de vida del objeto del módulo de aplicación en "
"cuestión: antes y durante la inicialización del módulo de aplicación, "
"actividades realizadas mientras el módulo de aplicación está activo, muerte "
"y (hasta 2018) actualizaciones del complemento."

#: ..\python_docs\spladdoninternals.py:116
msgid ""
"Note: although standalone add-on update feature is gone, the mechanism "
"behind add-on update feature will be documented for sake of completeness."
msgstr ""
"Nota: aunque la función independiente de búsqueda de actualizaciones se ha "
"ido, el mecanismo detrás de la actualización de complementos se documentará "
"para dar completitud."

#: ..\python_docs\spladdoninternals.py:117
msgid "### Before birth: NVDA's app module import routines"
msgstr ""
"### Antes de nacer: procedimientos de importación del módulo de aplicación "
"de NVDA"

#: ..\python_docs\spladdoninternals.py:118
msgid ""
"Before we go any further, it is important for you to understand how NVDA "
"loads various app modules. This routine, available from source/"
"appModuleHandler.py (NVDA Core), can be summarized as follows:"
msgstr ""
"Antes de que profundicemos más, es importante que entiendas cómo carga NVDA "
"distintos módulos de aplicación. Este procedimiento, disponible en source/"
"appModuleHandler.py (núcleo de NVDA) puede resumirse de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:119
msgid ""
"1. If a new process (program) runs, NVDA will try to obtain the process ID "
"(PID) for the newly loaded process."
msgstr ""
"1. Si se ejecuta un nuevo proceso (programa), NVDA intentará obtener el "
"identificador de proceso (PID) para el proceso recién cargado."

#: ..\python_docs\spladdoninternals.py:120
msgid ""
"2. Next, NVDA will look for an app module matching the name of the "
"executable for the newly created process. It looks in various places, "
"including source/appModules, userConfigDirectory/appModules and addonname/"
"appModules, then resorting to the default app module if no app module with "
"the given name is found."
msgstr ""
"2. A continuación, NVDA buscará un módulo de aplicación que encaje con el "
"nombre del ejecutable del proceso recién creado. Mira en varios lugares, "
"entre ellos source/appModules, directorio de configuración de usuario/"
"appModules y complemento/appModules, luego vuelve al módulo de aplicación "
"por defecto si no encuentra ningún módulo de aplicación con el nombre "
"especificado."

#: ..\python_docs\spladdoninternals.py:121
msgid ""
"3. Next, NVDA will attempt to use Python's built-in __import__ function to "
"load the app module, raising errors if necessary. No errors means the app "
"module is ready for use."
msgstr ""
"3. Después, NVDA intentará usar la función __import__ integrada en Python "
"para cargar el módulo de aplicación, lanzando errores si es necesario. Si no "
"hay errores significa que el módulo de aplicación está listo para usarse."

#: ..\python_docs\spladdoninternals.py:122
msgid ""
"4. Once the newly loaded module is ready, NVDA will instantiate appModule."
"AppModule class (make it available). If a constructor (__init__ method) is "
"defined, Python (not NVDA) will call the app module constructor (more on "
"this below)."
msgstr ""
"4. Una vez esté listo el módulo recién cargado, NVDA instanciará la clase "
"appModule.AppModule (la pondrá disponible). Si se define un constructor "
"(método __init__), Python (y no NVDA) llamará al constructor del módulo de "
"aplicación (más sobre esto debajo)."

#: ..\python_docs\spladdoninternals.py:123
msgid ""
"In case the app module's AppModule class has a constructor defined, Python "
"will follow directions specified in the constructor. Just prior to "
"performing app module specific constructor routines, it is important to call "
"the constructor for the default app module first as in the following code:"
msgstr ""
"En caso de que la clase AppModule del módulo de aplicación tenga un "
"constructor definido, Python seguirá las órdenes especificadas en ese "
"constructor. Antes de hacer los procedimientos de inicialización específicos "
"del módulo de aplicación, es importante llamar primero al constructor del "
"módulo de aplicación por defecto como en el siguiente código:"

#: ..\python_docs\spladdoninternals.py:124
msgid "\tdef __init__(self, *args, **kwargs):"
msgstr "\tdef __init__(self, *args, **kwargs):"

#: ..\python_docs\spladdoninternals.py:125
msgid "\t\tsuper(AppModule, self).__init__(*args, **kwargs)"
msgstr "\t\tsuper(AppModule, self).__init__(*args, **kwargs)"

#: ..\python_docs\spladdoninternals.py:126
msgid ""
"This is a must because the default app module constructor performs important "
"activities, including:"
msgstr ""
"Esto es obligatorio porque el constructor del módulo de aplicación por "
"defecto realiza actividades importantes, incluyendo:"

#: ..\python_docs\spladdoninternals.py:127
msgid ""
"1. The default app module constructor will call another base constructor "
"(this time, it is baseObject.ScriptableObject, containing gestures support "
"among other important properties)."
msgstr ""
"1. El constructor del módulo de aplicación por defecto llamará a otro "
"constructor base (en esta ocasión, se trata de baseObject.ScriptableObject, "
"que contiene soporte de gestos entre otras propiedades importantes)."

#: ..\python_docs\spladdoninternals.py:128
msgid ""
"2. Initializes various properties, such as PID (process ID), app module name "
"(if defined), application name and the handle to the app in question via "
"kernel32.dll's OpenProcess function (XP/Server 2003 and Vista/Server 2008 "
"and later requires different arguments)."
msgstr ""
"2. Inicializa diversas propiedades, como PID (identificador de proceso), "
"nombre del módulo de aplicación (si está definido), nombre de la aplicación "
"y manejador hacia la aplicación en cuestión mediante la función OpenProcess "
"de kernel32.dll (XP/Server 2003 y Vista/Server 2008 y posterior necesitan "
"argumentos distintos)."

#: ..\python_docs\spladdoninternals.py:129
msgid ""
"3. Lastly, the constructor initializes process injection handle and helper "
"binding handle in case such routines are required."
msgstr ""
"3. Por último, el constructor inicializa el manejador de inyección de "
"proceso y el manejador de asociación auxiliar en caso de que se necesiten "
"estos procedimientos."

#: ..\python_docs\spladdoninternals.py:130
msgid "### Birth: app module construction"
msgstr "### Nacimiento: construcción del módulo de aplicación"

#: ..\python_docs\spladdoninternals.py:131
msgid ""
"Certain app module add-ons shipt with an app module with a constructor "
"define, and SPL Studio is one of them; in 2018, constructors were added to "
"Creator and Track Tool for various purposes, and Remote VT client ships with "
"a constructor similar to Creator app module. After calling the base "
"constructor as described above, SPL app module's constructor (__init__ "
"method that runs when the app module starts) does the following:"
msgstr ""
"Ciertos complementos con módulos de aplicación vienen con un módulo de "
"aplicación con un constructor definido, y SPL Studio es uno de ellos; en "
"2018, se añadieron constructores a Creator y a la herramienta de pista con "
"diversos propósitos, y el cliente Remote VT viene con un constructor similar "
"al del módulo de aplicación de Creator. Después de llamar al constructor "
"base como se describe arriba, el constructor del módulo de aplicación de SPL "
"(método __init__ que se ejecuta cuando se inicia el módulo de aplicación) "
"hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:132
msgid ""
"1. Checks whether a supported version of Studio is running, and if not, "
"raises RuntimeError exception, preventing you from using the app module "
"while an unsupported version of Studio is in use (as of add-on 17.04, you "
"need to use Studio 5.10 and later)."
msgstr ""
"1. Comprueba si se está ejecutando una versión soportada de Studio, y si no "
"es así, se lanza una excepción RuntimeError, impidiendo que uses el módulo "
"de aplicación mientras esté en uso una versión no soportada de Studio (a "
"partir del complemento 17.04, es necesario usar Studio 5.10 o posterior)."

#: ..\python_docs\spladdoninternals.py:133
msgid ""
"2. Unless silenced by `globalVars.appArgs.minimal` being True, NVDA "
"announces, \"Using SPL Studio version 5.01\" if Studio 5.01 is in use (of "
"course, NVDA will say 5.10 when Studio 5.10 is in use). This is done via ui."
"message function (part of NVDA Core) which lets you hear spoken messages or "
"read the message on a braille display. In reality, ui.message function calls "
"two functions serially (one after the other): speech.speakMessage (speaking "
"something via a synthesizer) and braille.handler.message (brailling messages "
"on a braille display if connected)."
msgstr ""
"2. A menos que se silencie poniendo `globalVars.appArgs.minimal` a True, "
"NVDA verbaliza \"Usando SPL Studio versión 5.01\" si Studio 5.01 está en uso "
"(por supuesto, NVDA dirá 5.10 cuando Studio 5.10 esté en uso). Esto se hace "
"mediante la función ui.message (parte del núcleo de NVDA), que te permite "
"oír mensajes hablados o leer el mensaje en una pantalla braille. En "
"realidad, la función ui.message llama en serie a dos funciones (una después "
"de la otra): speech.speakMessage (hablando algo mediante un sintetizador) y "
"braille.handler.message (mostrando mensajes en una pantalla braille si hay "
"alguna conectada)."

#: ..\python_docs\spladdoninternals.py:134
msgid ""
"3. Next, add-on settings and related subsystems are initialized by calling "
"splconfig.initialize(). For add-on 6.x and 7.x, the first four steps are "
"performed by the init (formerly initConfig) function itself, while in 8.0 it "
"is handled by SPLConfig ConfigHub class constructor. Add-on 17.10 changes "
"this significantly, and in 18.07 and later, some steps are skipped if "
"another Studio app is in use (see the next few sections). This is done as "
"follows:"
msgstr ""
"3. A continuación, se inicializan los ajustes del complemento y los "
"subsistemas relacionados llamando a splconfig.initialize(). Para los "
"complementos 6.x y 7.x, se hacen los cuatro primeros pasos en la misma "
"función init (conocida como initConfig), mientras que en el 8.0 se encarga "
"de esto el constructor de la clase ConfigHub de SPLConfig. El complemento "
"17.10 cambia esto de forma significativa, y en la versión 18.07 y "
"posteriores, se saltan algunos pasos si otra aplicación de Studio está en "
"uso (mira las siguientes secciones). Esto se hace de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:135
msgid ""
"\t1. For add-on 6.x and 7.x, loads a predefined configuration file named "
"userConfigPath/splstudio.ini. In add-on 6.0 and later, this is known as "
"\"normal profile). In add-on 6.x and 7.x, this is done by calling splconfig."
"unlockConfig() function that handles configuration validation via ConfigObj "
"and Validator, and in 8.0 and later, this is part of SPLConfig constructor. "
"In add-on 17.10 and later, this step will not take place if NVDA is told to "
"use an in-memory config, and in 18.07 and later, any SPL app module that "
"opens SPLConfig (splconfig.openConfig) will register its app name to "
"indicate which app is starting."
msgstr ""
"\t1. Para los complementos 6.x y 7.x, se carga un archivo de configuración "
"predefinido llamado rutaAjustesDeUsuario/splconfig.ini. En el complemento "
"6.0 y versiones posteriores, esto se conoce como \"perfil normal\". En los "
"complementos 6.x y 7.x, esto se hace llamando a la función splconfig."
"unlockConfig(), que se encarga de la validación de la configuración mediante "
"ConfigObj y Validator, y en el 8.0 y posteriores, esto es parte del "
"constructor de SPLConfig. En el complemento 17.10 y posteriores, este paso "
"no tendrá lugar si decimos a NVDA que utilice configuración en memoria, y en "
"la versión 18.07 y posteriores, cualquier módulo de aplicación de SPL que "
"abra SPLConfig (splconfig.openConfig) registrará el nombre de la aplicación "
"para indicar qué aplicación se está iniciando."

#: ..\python_docs\spladdoninternals.py:136
msgid ""
"\t2. For add-on 6.0 and later, loads broadcast profiles from addonDir/"
"profiles folder. These are .ini files and are processed just like the normal "
"profile except that global settings are pulled in from the normal profile. "
"In add-on 8.0, just like normal profile, this is done when constructing "
"SPLConfig object. In add-on 17.10 and later, if the add-on is told to use "
"normal profile only, this step will not occur."
msgstr ""
"\t2. Para el complemento 6.0 y posteriores, se cargan los perfiles de "
"emisión desde la carpeta rutaDelComplemento/profiles. Son archivos .ini y se "
"procesan como se hace con el perfil normal salvo porque los ajustes globales "
"se toman desde el perfil normal. En el complemento 8.0, al igual que con el "
"perfil normal, esto se hace al construir el objeto SPLConfig. En el "
"complemento 17.10 y posteriores, si decimos al complemento que use solamente "
"el perfil normal, no se hará este paso."

#: ..\python_docs\spladdoninternals.py:137
msgid ""
"\t3. Each profile is then appended to a record keeper container (splconfig."
"SPLConfigPool for 6.x and 7.x, splconfig.SPLConfig.profiles in 8.0 and "
"later). Then the active profile is set and splconfig.SPLConfig (user "
"configuration map) is set to the first profile in the configuration pool "
"(normal profile; for add-on 5.x and earlier or if only normal profile is to "
"be used (17.10 and later), there is (or will be) just one profile so append "
"step is skipped)."
msgstr ""
"\t3. A continuación, cada perfil se anexa a un contenedor encargado de los "
"registros (splconfig.SPLConfigPool para 6.x y 7.x, splconfig.SPLConfig."
"profiles en 8.0 y posteriores). Después se establece el perfil activo y "
"splconfig.SPLConfig (mapa de configuración del usuario) se establece al "
"primer perfil en el contenedor de configuración (perfil normal; para el "
"complemento 5.x y anteriores o si sólo va a usarse el perfil normal (17.10 y "
"posteriores), hay (o habrá) simplemente un perfil, por lo que el paso de "
"anexar se omite)."

#: ..\python_docs\spladdoninternals.py:138
msgid ""
"\t4. Between add-on 7.0 and 21.10 (enhanced in 17.10 and relaxed in 20.09), "
"unless in-memory config is requested, Normal profile dictionary (not others) "
"is cached. This is useful in keeping a record of settings loaded from disk "
"versus run-time configuration and is employed when comparing values when "
"saving profiles. See profile caching section in broadcast profiles for "
"details and reasons which is documented for historical reasons."
msgstr ""
"\t4. Entre los complementos 7.0 y 21.10 (mejorado en 17.10 y relajado en "
"20.09), a menos que se solicite la configuración en memoria, el diccionario "
"del perfil normal (y no otros) se guarda en caché. Esto es útil para "
"conservar un registro de ajustes cargados de disco contra la configuración "
"en tiempo de ejecución, y se emplea al comparar valores al guardar perfiles. "
"Mira la sección de guardado de perfiles en perfiles de emisión para más "
"detalles y razones, documentada por motivos históricos."

#: ..\python_docs\spladdoninternals.py:139
msgid ""
"\t5. Starting from add-on 18.08,. if NVDA supports it, SPLConfig will listen "
"to config save action so add-on settings can be saved when config save "
"command (Control+NVDA+C) is invoked. Add-on 19.03 added support for config "
"reload/reset action so add-on settings can be reloaded or reset to defaults "
"if Control+NVDA+R is pressed once or three times, respectively."
msgstr ""
"\t5. Comenzando con el complemento 18.08, si NVDA lo soporta, SPLConfig "
"escuchará la acción de guardar configuración para guardar los ajustes del "
"complemento cuando se invoque la orden para guardar la configuración (control"
"+NVDA+c). En el complemento 19.03 se añade soporte para la acción de "
"recarga / restablecimiento de la configuración, de tal forma que las "
"opciones del complemento se recargan o restablecen a valores por defecto si "
"se pulsa NVDA+CTRL+r una o tres veces, respectivamente."

#: ..\python_docs\spladdoninternals.py:140
msgid ""
"\t6. If an instant profile is defined (a cached instant profile name is "
"present), the instant profile variable is set accordingly."
msgstr ""
"\t6. Si se define un perfil instantáneo (hay presente un nombre de perfil "
"instantáneo en la caché) se establece de forma apropiada la variable de "
"perfil instantáneo."

#: ..\python_docs\spladdoninternals.py:141
msgid ""
"\t7. If errors were found, NVDA either displays an error dialog (5.x and "
"earlier) or a status dialog (6.0 and later) detailing the error in question "
"and what NVDA has done to faulty profiles. This can range from applying "
"default values to some settings to resetting everything to defaults (the "
"latter will occur if validator reports that all settings in the normal "
"profile are invalid or ConfigObj threw parse errors, commonly seen when file "
"content doesn't make sense)."
msgstr ""
"\t7. Si se encuentran errores, NVDA muestra un diálogo de error (5.x y "
"anteriores) o bien un diálogo de estado (6.0 y posteriores) detallando el "
"error en cuestión y lo que ha hecho NVDA a los perfiles fallidos. Esto puede "
"pasar por aplicar valores por defecto a algunos ajustes para restablecer los "
"ajustes por defecto (lo último ocurrirá si el validador informa de que todos "
"los ajustes en el perfil normal son inválidos o configObj lanzó errores de "
"interpretación, vistos comúnmente cuando el contenido del archivo no tiene "
"sentido)."

#: ..\python_docs\spladdoninternals.py:142
msgid ""
"\t8. Between add-on 7.0 and 18.12, add-on update facility is initialized "
"(splupdate.initialize). among other things, the initialization routine loads "
"update check metadata. In 2018, prior to being removed, update "
"initialization was moved to app module constructor. We'll meet add-on update "
"routines (housed in splstudio/splupdate.py) later in this article."
msgstr ""
"\t8. Entre los complementos 7.0 y 18.12, se inicializa la característica de "
"actualizaciones (splupdate.initialize). Entre otras cosas, el procedimiento "
"de inicialización carga los metadatos de búsqueda de actualizaciones. En "
"2018, la inicialización de las actualizaciones se hace como parte del "
"constructor del módulo de aplicación. Encontraremos los procedimientos de "
"actualización del complemento (alojados en splstudio/splupdate.py) más "
"adelante en este artículo."

#: ..\python_docs\spladdoninternals.py:143
msgid ""
"\t9. In add-on 8.0, track comments are loaded (if any). See track items "
"section for details."
msgstr ""
"\t9. En el complemento 8.0, se cargan los comentarios de pista (si los hay). "
"Mira la sección de elementos de pista para más detalles."

#: ..\python_docs\spladdoninternals.py:144
msgid ""
"\t10. Although not part of the init routine, starting from 17.12, various "
"modules register one or more functions for action notifications. See "
"extension points section for details."
msgstr ""
"\t10. Aunque no es parte del procedimiento de inicialización, empezando con "
"el complemento 17.12, diversos módulos registran una o más funciones para "
"notificaciones de acción. Mira la sección de puntos de extensión para más "
"detalles."

#: ..\python_docs\spladdoninternals.py:145
msgid ""
"4. Starting with NVDA 2015.3, it became possible for an app module to "
"request NVDA to monitor certain events for certain controls even if the app "
"is not being used. This is done by calling eventHandler.requestEvents "
"function with three arguments: process ID, window class for the control in "
"question and the event to be monitored. For earlier versions of NVDA "
"(checked via built-in hasattr function), this step is skipped, and "
"background status monitor flag is then set accordingly. We'll discuss event "
"handling throughout this article."
msgstr ""
"4. Empezando con NVDA 2015.3, es posible para un módulo de aplicación "
"pedirle a NVDA que monitorice ciertos eventos para ciertos controles incluso "
"si no se está usando la app. Esto se hace llamando a la función eventHandler."
"requestEvents con tres argumentos: identificador del proceso, clase de "
"ventana para el control en cuestión y el evento a monitorizar. Para "
"versiones más antiguas de NVDA (comprobadas mediante la función incorporada "
"hasattr), se salta este paso, y el indicador de monitorización del estado en "
"segundo plano se establece de forma apropiada. Hablaremos del procesamiento "
"de eventos a lo largo de este artículo."

#: ..\python_docs\spladdoninternals.py:146
msgid ""
"5. Next, GUI subsystem is initialized (NVDA uses wxPython). This routine "
"adds an entry in NVDA's preferences menu entitled \"SPL Studio Settings\", "
"the add-on configuration dialog."
msgstr ""
"5. Después, se inicializa el subsistema gráfico (NVDA usa WXPython). Este "
"procedimiento añade una entrada en el menú de preferencias de NVDA, titulada "
"\"Ajustes de SPL Studio\", el diálogo de configuración del complemento."

#: ..\python_docs\spladdoninternals.py:147
msgid ""
"6. As described above, the app module will look for the window handle for "
"the Studio app. In order to avoid this routine consuming resources and "
"making NVDA not responsive, this is done in a separate thread. The thread "
"performs the following:"
msgstr ""
"6. Como se ha descrito antes, el módulo de aplicación buscará el manejador "
"de ventana de la aplicación Studio. Para evitar que este procedimiento "
"consuma recursos y reduzca el rendimiento de NVDA, esto se hace en un hilo "
"separado. El hilo hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:148
msgid ""
"\t1. Studio window handle is searched via a loop. If Studio exits for "
"whatever reason, an event flag is raised by the app module, causing this "
"thread to exit."
msgstr ""
"\t1. Se busca el manejador de ventana de Studio con un bucle. Si Studio se "
"cierra por la razón que sea, el módulo de aplicación activa un indicador de "
"evento, causando que este hilo finalice."

#: ..\python_docs\spladdoninternals.py:149
msgid ""
"\t2. If the handle is found, its value is recorded in a flag found in base "
"services module (splbase)."
msgstr ""
"\t2. Si se encuentra el manejador, su valor se registra en un indicador "
"situado en el módulo de servicios básicos (splbase)."

#: ..\python_docs\spladdoninternals.py:150
msgid ""
"\t3. If the app module is told to announce status of metadata streaming and "
"connect to predefined URL's, NVDA will do it at this point provided that "
"Studio's playlist viewer (discussed later) is loaded. In order to announce "
"status messages as the last announcement after connecting to metadata "
"servers, Studio app module places ui.message in the event queue to be "
"handled by NVDA (queueHandler.queueFunction). More on internals of metadata "
"announcement and related components in the SPL Assistant chapter."
msgstr ""
"\t3. Si le decimos al módulo de aplicación que verbalice el estado del flujo "
"de metadatos y conexión a URLs predefinidas, NVDA hará todo eso en este "
"punto, asumiendo que el visor de listas de reproducción de Studio (explicado "
"más tarde) está cargado. Para verbalizar mensajes de estado en último lugar "
"después de conectar a los servidores de metadatos, el módulo de aplicación "
"de Studio sitúa ui.message en la cola de eventos para que NVDA la procese "
"(queueHandler.queueFunction). Hay más información sobre el interior del "
"anuncio de metadatos y sus componentes relacionados en el capítulo sobre el "
"asistente de SPL."

#: ..\python_docs\spladdoninternals.py:151
msgid ""
"7. Between add-on 7.0 and 18.12, if automatic update check is enabled, "
"update check timer is started."
msgstr ""
"7. Entre los complementos 7.0 y 18.12, si está activada la búsqueda "
"automática de actualizaciones, se inicia el temporizador asociado."

#: ..\python_docs\spladdoninternals.py:152
msgid "#### Changes introduced in 17.10 due to volatile configuration flags"
msgstr ""
"#### Cambios introducidos en 17.10 debido a indicadores de configuración "
"volátil"

#: ..\python_docs\spladdoninternals.py:153
msgid ""
"In add-on 17.10, several internal flags and associated command-line switches "
"are introduced to control how the add-on settings are loaded and treated. "
"Presence of these flags will significantly alter the way settings are loaded "
"and saved. These flags should be used when instructed by the add-on "
"developer, as they are used for troubleshooting or experimenting purposes."
msgstr ""
"En el complemento 17.10, se introducen varios indicadores internos y "
"argumentos de línea de órdenes asociados para controlar cómo se cargan y se "
"tratan los ajustes del complemento. La presencia de estos indicadores "
"alterará significativamente la forma en que se cargan y guardan los ajustes. "
"Estos indicadores deberían usarse cuando lo indique el desarrollador del "
"complemento, ya que su propósito es experimentar o solucionar problemas."

#: ..\python_docs\spladdoninternals.py:154
msgid "The flags are as follows:"
msgstr "Los indicadores son los siguientes:"

#: ..\python_docs\spladdoninternals.py:155
msgid ""
"1. Do not save changes to disk (configVolatile/--spl-configvolatile, removed "
"in 20.09): all profiles (including broadcast profiles) will be loaded from "
"disk but changes will not be saved. With this flag turned on, profile "
"caching will not occur if supported, including normal profile."
msgstr ""
"1. No guardar cambios a disco (configVolatile/--spl-configvolatile, "
"eliminado en la versión 20.09): todos los perfiles (incluyendo los perfiles "
"de emisión) se cargarán desde disco, pero sus cambios no se guardarán. Con "
"este indicador activado, la conservación de perfiles en caché no ocurrirá si "
"está soportada, incluso para el perfil normal."

#: ..\python_docs\spladdoninternals.py:156
msgid ""
"2. Load normal profile only (normalProfileOnly/--spl-normalprofileonly): "
"broadcast profiles will not be used i.e. cannot create and switch amongst "
"broadcast profiles. Combining this with NVDA setting to not have "
"configuration to disk on exit effectively makes normal profile a read-only "
"config store."
msgstr ""
"2. Cargar solamente el perfil normal (normalProfileOnly/--spl-"
"normalprofileonly): no se usarán perfiles de emisión, no se podrán crear "
"estos perfiles ni pasar de uno a otro. Combinando este indicador con la "
"opción de NVDA para no guardar la configuración al salir, el perfil normal "
"se convierte de forma efectiva en un almacén de configuración de sólo "
"lectura."

#: ..\python_docs\spladdoninternals.py:157
msgid ""
"3. Use in-memory config (configInMemory/--spl-configinmemory): only normal "
"profile will be used, but instead of loading settings from disk, an in-"
"memory version with default settings applied will be used (and no profile "
"caching if supported)."
msgstr ""
"3. Usar configuración en memoria (configInMemory/--spl-configinmemory): sólo "
"se usará el perfil normal, pero en lugar de cargar los ajustes desde disco, "
"se usará una versión en memoria con los ajustes por defecto aplicados (y sin "
"caché de perfiles si se soporta)."

#: ..\python_docs\spladdoninternals.py:158
msgid ""
"Using flags that specify the use of normal profile only will restrict "
"ability to create new broadcast profiles."
msgstr ""
"Usar indicadores que especifiquen la utilización solamente del perfil normal "
"restringirá la habilidad de crear nuevos perfiles de emisión."

#: ..\python_docs\spladdoninternals.py:159
msgid ""
"#### Changes introduced in 18.07 to handle add-on settings from apps other "
"than Studio"
msgstr ""
"#### Cambios introducidos en 18.07 para procesar opciones del complemento "
"desde aplicaciones distintas a Studio"

#: ..\python_docs\spladdoninternals.py:160
msgid ""
"Because Columns Explorer (see the corresponding section below) is used in "
"Studio, Creator and Track Tool, it became necessary to change how add-on "
"settings are loaded and managed outside of Studio. Instead of splconfig."
"initialize calling SPLConfig constructor directly, it will call splconfig."
"openConfig function that will call the constructor (if needed) and add the "
"app name to a list of active SPL components. If this is done with add-on "
"settings already loaded, no construction activity will take place."
msgstr ""
"Como el explorador de columnas se usa en Studio, Creator y la herramienta de "
"pista (lee la sección correspondiente a continuación), se hizo necesario "
"cambiar la forma de cargar y gestionar la configuración del complemento "
"fuera de Studio. En vez de llamar directamente al constructor de SPLConfig "
"en splconfig.initialize, se llama a la función splconfig.openConfig, que "
"llamará al constructor (si es necesario) y añadirá el nombre de la "
"aplicación a una lista de componentes de SPL. Si esto se hace con los "
"ajustes del complemento ya cargados, no tendrá lugar ninguna actividad de "
"construcción."

#: ..\python_docs\spladdoninternals.py:161
msgid ""
"In app modules for Creator and Track Tool, the constructor will call "
"splconfig.openConfig to perform the above activity. When the app module "
"terminates (see below), splconfig.closeConfig will be called to unregister "
"the component that is being terminated, and if no SPL components are active, "
"add-on settings will be gone from memory."
msgstr ""
"En los módulos de aplicación de Creator y la herramienta de pista, el "
"constructor llamará a splconfig.openConfig para realizar la actividad "
"explicada arriba. Cuando el módulo de aplicación finaliza (mira más abajo), "
"se llamará a splconfig.closeConfig para eliminar del registro el componente "
"que finaliza, y si no hay componentes de SPL activos, las opciones del "
"complemento se irán de la memoria."

#: ..\python_docs\spladdoninternals.py:162
msgid "### Life of the app module: events, commands and output"
msgstr "### Vida del módulo de aplicación: eventos, órdenes y salida"

#: ..\python_docs\spladdoninternals.py:163
msgid ""
"Once the Studio app module is ready, you can then move to Studio window and "
"perform activities such as:"
msgstr ""
"Una vez el módulo de Studio está listo, puedes moverte a la ventana de "
"Studio y realizar actividades como estas:"

#: ..\python_docs\spladdoninternals.py:164
msgid ""
"* Press commands, and NVDA will respond by either opening a dialog or "
"speaking what it did."
msgstr ""
"* Pulsar órdenes, y NVDA responderá abriendo un diálogo o bien diciendo lo "
"que ha hecho."

#: ..\python_docs\spladdoninternals.py:165
msgid ""
"* Announce status changes such as microphone status. The length and format "
"of these messages (and other add-on messages) are controlled by message "
"verbosity flag (in case verbosity is set to advanced, NVDA will shorten "
"these announcements, which comes from a messages pool). A special case is "
"announcing artist and title of the currently playing track automatically, "
"for which object navigation is employed. This is necessary due to a broken "
"option in Studio itself."
msgstr ""
"* Verbalizar cambios de estado, como estado del micrófono. La longitud y "
"formato de estos mensajes (y otros mensajes del complemento) están "
"controlados por el indicador de verbosidad de mensajes (en el caso de que la "
"verbosidad se establezca en avanzada, NVDA acortará estos anuncios, que "
"vienen de un contenedor de mensajes). Un caso especial es la verbalización "
"automática de título y artista de la pista que se está reproduciendo "
"actualmente, para el que se emplea navegación por objetos. Esto es necesario "
"por culpa de una opción rota en el propio Studio."

#: ..\python_docs\spladdoninternals.py:166
msgid "* Find tracks."
msgstr "* Buscar pistas."

#: ..\python_docs\spladdoninternals.py:167
msgid ""
"* Examine information in columns via Track Dial and/or Columns Explorer "
"(Track Dial was deprecated in 2017)."
msgstr ""
"* Examinar la información en columnas mediante el dial de pista y / o el "
"explorador de columnas (el dial de pista quedó obsoleto en 2017)."

#: ..\python_docs\spladdoninternals.py:168
msgid "* Listen to progress of a library scan in the background."
msgstr ""
"* Escuchar el progreso de escaneado de una biblioteca en segundo plano."

#: ..\python_docs\spladdoninternals.py:169
msgid "* Perform SPL Assistant gestures."
msgstr "* Realizar gestos del asistente de SPL."

#: ..\python_docs\spladdoninternals.py:170
msgid ""
"* For 6.0 and later, manage broadcast profiles (we'll talk about broadcast "
"profiles in configuration management section)."
msgstr ""
"* Para 6.0 y posteriores, gestionar perfiles de emisión (hablaremos de los "
"perfiles de emisión en la sección de gestión de la configuración)."

#: ..\python_docs\spladdoninternals.py:171
msgid ""
"* For 17.12 and later, respond to actions such as broadcast profile switches."
msgstr ""
"* Para 17.12 y posteriores, responder ante acciones como cambios de perfil "
"de emisión."

#: ..\python_docs\spladdoninternals.py:172
msgid "For Creator and Track Tool, it will let you review column data."
msgstr ""
"En Creator y la herramienta de pista, te permitirá revisar los datos de una "
"columna."

#: ..\python_docs\spladdoninternals.py:173
msgid "#### Extension points"
msgstr "#### Puntos de extensión"

#: ..\python_docs\spladdoninternals.py:174
msgid ""
"Introduced in NVDA 2017.4, an extension point is a notification system from "
"NVDA that tells modules and functions to perform tasks when something "
"happens. For example, the braille subsystem will load a different braille "
"display if different configuration profiles specify this change, or a speech "
"synthesizer can filter certain text from spoken messages before announcing "
"it to users."
msgstr ""
"Introducido en NVDA 2017.4, un punto de extensión es un sistema de "
"notificaciones de NVDA que dice a los módulos y funciones que realicen "
"tareas cuando algo ocurra. Por ejemplo, el subsistema braille cargará una "
"pantalla braille diferente si los perfiles de configuración especifican este "
"cambio, o un sintetizador de voz puede filtrar cierto texto de los mensajes "
"hablados antes de verbalizarlos a los usuarios."

#: ..\python_docs\spladdoninternals.py:175
msgid "There are three extension point types:"
msgstr "Hay tres tipos de puntos de extensión:"

#: ..\python_docs\spladdoninternals.py:176
msgid ""
"* Action: a function can wait for something to happen, such as change of "
"profiles, loading and saving settings and others, and act accordingly once "
"an action takes place."
msgstr ""
"* Acción: una función puede esperar a que ocurra algo, como un cambio de "
"perfiles, que se cargue o guarde la configuración y otros, y actuar en "
"consecuencia cuando una de estas acciones tiene lugar."

#: ..\python_docs\spladdoninternals.py:177
msgid ""
"* Decider: A data processor inside a script or a function can tell NVDA to "
"continue processing data, such as passing a keystroke to remote system."
msgstr ""
"* Decisión: un procesador de datos dentro de un script o una función puede "
"decirle a NVDA que continúe procesando datos, tales como enviar una "
"pulsación de teclas a un sistema remoto."

#: ..\python_docs\spladdoninternals.py:178
msgid ""
"* Filter: a speech processor can add, change, or remove texts before letting "
"synthesizers announce the would-be spoken text."
msgstr ""
"* Filtro: un procesador de voz puede añadir, cambiar o eliminar textos antes "
"de dejar que los sintetizadores verbalicen el texto que debería ser "
"verbalizado."

#: ..\python_docs\spladdoninternals.py:179
msgid ""
"In SPL add-on, actions are used to notify modules of some action such as "
"when Studio exits, broadcast profile switches and so on. There are two "
"actions defined (in splactions module):"
msgstr ""
"En el complemento de SPL, las acciones se usan para notificar a los módulos "
"de alguna acción, como cuando salimos de Studio, cambia el perfil de emisión "
"y así sucesivamente. Hay dos acciones definidas (en el módulo splactions):"

#: ..\python_docs\spladdoninternals.py:180
msgid ""
"* Broadcast profile switch: notifies microphone alarm thread and metadata "
"streaming configuration to switch streams or turn off the alarm (see below "
"for details)."
msgstr ""
"* Cambio de perfil de emisión: notifica al hilo de alarma del micrófono y a "
"la configuración del flujo de metadatos para que cambie los flujos o apague "
"la alarma (mira más abajo para más detalles)."

#: ..\python_docs\spladdoninternals.py:181
msgid ""
"* Studio exiting: tells add-on dialogs to close without saving settings."
msgstr ""
"* Saliendo de Studio: indica a los diálogos del complemento que se cierren "
"sin guardar los ajustes."

#: ..\python_docs\spladdoninternals.py:182
msgid "### Death: termination routines"
msgstr "### Muerte: procedimientos de finalización"

#: ..\python_docs\spladdoninternals.py:183
msgid ""
"While using the add-on, you can stop using it in various ways, including "
"exiting or restarting NVDA, turning off your computer or logging off or "
"closing Studio or other SPL app. Just like initialization routines, the "
"Studio app module has specific directions to follow when add-on is closed."
msgstr ""
"Mientras se usa el complemento de Studio, puedes dejar de usar este "
"complemento de varias maneras, que incluyen salir o reiniciar NVDA, apagar "
"tu ordenador o cerrar sesión, o cerrar Studio o una aplicación de SPL. Al "
"igual que pasa con los procedimientos de inicialización, el módulo de "
"aplicación de Studio tiene instrucciones que seguir cuando el complemento se "
"cierra."

#: ..\python_docs\spladdoninternals.py:184
msgid ""
"Here is a list of steps Studio app module performs when it is about to leave "
"this world:"
msgstr ""
"Aquí hay una lista de pasos que sigue el módulo de aplicación de Studio "
"cuando está a punto de abandonar este mundo:"

#: ..\python_docs\spladdoninternals.py:185
msgid ""
"1. The \"terminate\" method is called. Just like the startup (constructor) "
"routine, this method first calls the terminate method defined in the default "
"app module, which closes handles and performs other closing routines."
msgstr ""
"1. Se llama al método \"terminate\". Al igual que el procedimiento de "
"inicialización (constructor), este método primero llama al método terminate "
"definido en el módulo de aplicación por defecto, que cierra manejadores y "
"realiza otros procedimientos de cierre."

#: ..\python_docs\spladdoninternals.py:186
msgid ""
"2. Calls splconfig.terminate() function to save add-on settings and perform "
"shutdown routines for some features. This function goes through following "
"steps:"
msgstr ""
"2. Se llama a la función splconfig.terminate() para guardar los ajustes del "
"complemento y realizar tareas de apagado de algunas características. Esta "
"función sigue los siguientes pasos:"

#: ..\python_docs\spladdoninternals.py:187
msgid ""
"\t1. In add-on 7.0, if update check timer is running, the timer is told to "
"stop, and update metadata is copied back to normal profile. This step is "
"gone in 19.01."
msgstr ""
"\t1. En el complemento 7.0, si el temporizador de búsqueda de "
"actualizaciones está funcionando, recibe la orden de detenerse, y se copian "
"los metadatos de actualización de vuelta en el perfil normal. Este paso se "
"elimina en la versión 19.01."

#: ..\python_docs\spladdoninternals.py:188
msgid ""
"\t2. Starting with add-on 18.07, active SPL component is unregistered via "
"splconfig.closeConfig function. If there are other components running, the "
"below steps will not occur, otherwise add-on settings will be closed."
msgstr ""
"\t2. Empezando con el complemento 18.07, se elimina el componente activo del "
"registro mediante la función splconfig.closeConfig. Si hay otros componentes "
"en ejecución, los siguientes pasos no ocurrirán, y en cualquier otro caso "
"las opciones del complemento se cerrarán."

#: ..\python_docs\spladdoninternals.py:189
msgid ""
"\t3. Unless disabled through flags in 17.10, profiles are saved (beginning "
"with normal profile) to disk if and only if profile-specific settings were "
"changed (an online cache used for storing profile settings when they are "
"loaded is kept for this purpose). This step will not occur if an in-memory "
"version of normal profile is in use or other SPL components are active. The "
"online profile cache is gone in 21.10."
msgstr ""
"\t3. A menos que se desactive con indicadores en 17.10, se guardan los "
"perfiles (empezando con el perfil normal) en disco si y sólo si se cambian "
"ajustes específicos del perfil (con este propósito se conserva una caché en "
"línea usada para almacenar ajustes de los perfiles cuando estos se cargan). "
"Este paso no ocurrirá si está en uso una versión en memoria del perfil "
"normal o hay otros componentes de SPL activos. La caché de perfiles en línea "
"ya no está en 21.10."

#: ..\python_docs\spladdoninternals.py:190
msgid ""
"\t4. If there is an instant switch profile defined, this is recorded in the "
"normal profile, otherwise it is removed from the profile database."
msgstr ""
"\t4. Si hay un perfil de cambio instantáneo definido, este se registra en el "
"perfil normal, de cualquier otro modo se elimina de la base de datos de "
"perfiles."

#: ..\python_docs\spladdoninternals.py:191
msgid ""
"\t5. Once all profiles are saved, various flags, active profile and config "
"pool is cleared."
msgstr ""
"\t5. Una vez se guardan todos los perfiles, se limpian diversos indicadores, "
"el perfil activo y el contenedor de configuración."

#: ..\python_docs\spladdoninternals.py:192
msgid ""
"\t6. For add-on 5.x and earlier, there is only one broadcast profile to "
"worry about, and this profile is saved at this point."
msgstr ""
"\t6. Para el complemento 5.x y anteriores, hay sólo un perfil de emisión del "
"que preocuparse, y este perfil se guarda en este punto."

#: ..\python_docs\spladdoninternals.py:193
msgid ""
"\t7. These steps are part of splconfig.SPLConfig.save method in add-on 8.0 "
"and later."
msgstr ""
"\t7. Estos pasos son parte del método splconfig.SPLConfig.save en el "
"complemento 8.0 y posteriores."

#: ..\python_docs\spladdoninternals.py:194
msgid ""
"3. In 17.12 and later, NVDA notifies registered handlers for app terminate "
"action. As noted above, this will cause add-on dialogs to close without "
"saving settings."
msgstr ""
"3. En 17.12 y posteriores, NVDA notifica a los manejadores registrados la "
"acción de finalización de aplicación. Como se explica arriba, esto causará "
"que los diálogos del complemento se cierren sin guardar los ajustes."

#: ..\python_docs\spladdoninternals.py:195
msgid ""
"4. NVDA then attempts to remove StationPlaylist Add-on Settings entry from "
"NVDA's preferences menu, then various maps used by Studio app module (such "
"as Cart Explorer map) are cleared."
msgstr ""
"4. A continuación NVDA intenta eliminar la entrada de ajustes del "
"complemento de SPL del menú de preferencias de NVDA, después se limpian "
"diversos mapas usados por la aplicación Studio (como el mapa del explorador "
"cart)."

#: ..\python_docs\spladdoninternals.py:196
msgid ""
"5. An important task is cleaning up objects cache used by some SPL Assistant "
"commands, as cached information (specifically, objects) will point to "
"something else next time Studio starts (without restarting NVDA), which is "
"dangerous."
msgstr ""
"5. Una tarea importante es limpiar las cachés de objetos de la aplicación "
"usada por algunas órdenes del asistente de SPL, ya que la información en "
"caché (concretamente objetos) apuntará a un lugar distinto la próxima vez "
"que se inicie Studio (sin reiniciar NVDA), lo que supone un peligro."

#: ..\python_docs\spladdoninternals.py:197
msgid ""
"6. As the app module is laid to rest, the window handle value for Studio "
"window is cleared. This is a must, as the handle will be different next time "
"Studio runs. At this point, NVDA removes splstudio (Studio app module) from "
"list of app modules in use."
msgstr ""
"6. Como el módulo de aplicación se sienta a descansar, el valor del "
"manejador de ventana para la ventana de Studio se limpia. Esto es "
"obligatorio, ya que el manejador será diferente la próxima vez que se inicie "
"Studio. En este punto, NVDA elimina splstudio (el módulo de aplicación de "
"Studio) de la lista de módulos de aplicación en uso."

#: ..\python_docs\spladdoninternals.py:198
msgid "### Add-on updates: updating to latest and greatest version"
msgstr ""
"### Actualizaciones del complemento: actualizar a la última y más fantástica "
"versión"

#: ..\python_docs\spladdoninternals.py:199
msgid ""
"Note: this feature, dubbed \"standalone add-on update\", is gone in 19.01, "
"although the mechanism behind it is documented here for sake of "
"completeness. Standalone add-on update refers to using SPL Assistant to "
"check for updates from Studio."
msgstr ""
"Nota: esta función, reciemtemente llamada \"actualización independiente del "
"complemento\", se ha ido en la versión 19.01, aunque el mecanismo que hay "
"tras ella se documenta aquí para dar completitud. La actualización "
"independiente hace referencia a usar el asistente de SPL para buscar "
"actualizaciones desde Studio."

#: ..\python_docs\spladdoninternals.py:200
msgid ""
"In add-on 7.0 and later (until 18.12), it is possible to update to the "
"latest version of the add-on by using add-on update check facility. This is "
"done by connecting to a server where the update add-on files are stored."
msgstr ""
"En el complemento 7.0 y posteriores (hasta la versión 18.12), es posible "
"actualizar a la última versión del complemento usando la característica de "
"comprobación de actualizaciones del complemento. Esto se hace conectando a "
"un servidor donde se alojan los archivos de actualización del complemento."

#: ..\python_docs\spladdoninternals.py:201
msgid ""
"The SPL add-on uses a combination of urllib library and update channels "
"(explained later) to fetch the needed update metadata. The user can tell the "
"add-on to check for updates automatically or one can perform this check "
"manually."
msgstr ""
"El complemento SPL usa una combinación de la biblioteca urllib y canales de "
"actualización (explicados más tarde) para recuperar los metadatos necesarios "
"de actualización. El usuario puede decirle al complemento que busque "
"actualizaciones automáticamente o puede comprobarlas de forma manual."

#: ..\python_docs\spladdoninternals.py:202
msgid "The update check is performed as follows:"
msgstr "La búsqueda de actualizaciones se hace de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:203
msgid ""
"1. If the add-on is told to check for updates, the Studio app module "
"constructor will start a timer whose purpose is to call a function when it "
"is time to check for an update."
msgstr ""
"1. Si le decimos al complemento que busque actualizaciones, el constructor "
"del módulo de aplicación de Studio iniciará un temporizador cuyo propósito "
"es llamar a una función cuando sea hora de buscar una actualización."

#: ..\python_docs\spladdoninternals.py:204
msgid ""
"2. If automatic update check is enabled, the update manager (splconfig."
"updateInit) will determine when the update was checked last. This is done in "
"order to perform update checks every 24 hours."
msgstr ""
"2. Si está activada la búsqueda automática de actualizaciones, el gestor de "
"actualizaciones (splconfig.updateInit) determinará cuando fue la última vez "
"que se buscaron actualizaciones. Esto se hace para realizar búsquedas de "
"actualizaciones cada 24 horas."

#: ..\python_docs\spladdoninternals.py:205
msgid ""
"3. Once the timer kicks in (automatic update check is on), the update check "
"function (splupdate.updateChecker) will be called. This function uses two "
"parameters to determine if a status progress tone should be played and to "
"schedule the next update check."
msgstr ""
"3. Una vez el temporizador llega a su fin (con la búsqueda automática de "
"actualizaciones activada), se llamará a la función de búsqueda de "
"actualizaciones (splupdate.updateChecker). Esta función usa dos parámetros "
"para determinar si debería reproducirse un tono de estado de progreso y para "
"programar la próxima búsqueda de actualizaciones."

#: ..\python_docs\spladdoninternals.py:206
msgid ""
"4. The update check function first connects to the URL for the current "
"update channel (more on channels at the end of this article) and compares "
"the filename returned by the server. If the file names does not match, the "
"add-on will interpret this as presence of an update and will return a "
"dictionary containing current add-on version, new version (parsed as a "
"regular expression) and URL for the file, and if not, it returns nothing."
msgstr ""
"4. La función de búsqueda de actualizaciones primero se conecta a la URL del "
"canal de actualizaciones actual (más sobre canales al final de este "
"artículo) y compara el nombre de archivo devuelto por el servidor. Si los "
"nombres de archivo no encajan, el complemento interpretará esto como que hay "
"una actualización disponible y devolverá un diccionario que contiene la "
"versión actual del complemento, la nueva versión (extraída de una expresión "
"regular) y la URL del archivo, y si no, no devuelve nada."

#: ..\python_docs\spladdoninternals.py:207
msgid ""
"5. If a new version is available and if the user said \"yes\" to update "
"prompt, the update metadata (update timestamp) will be cached to be "
"retrieved by the app module later."
msgstr ""
"5. Si hay una nueva versión disponible y el usuario ha dicho \"Sí\" a la "
"pregunta de actualización, los metadatos de la actualización (sello de "
"actualización) se guardarán para que el módulo de aplicación los consulte "
"más tarde."

#: ..\python_docs\spladdoninternals.py:208
msgid ""
"6. This process repeats if automatic check is enabled (a timer will be set "
"to call this function again after 24 hours)."
msgstr ""
"6. Este proceso se repetirá si la búsqueda automática está activada (se "
"creará un temporizador para llamar otra vez a esta función en 24 horas)."

#: ..\python_docs\spladdoninternals.py:209
msgid ""
"In case of a manual update check (described in SPL Assistant layer section), "
"apart from not using a timer and stopping an update check timer temporarily "
"(if needed), it will go through steps 3 through 5 from above."
msgstr ""
"En el caso de una búsqueda manual de actualizaciones (descrita en la sección "
"de la capa del asistente de SPL), aparte de no usarse un temporizador y "
"detener el temporizador de búsqueda de actualizaciones automática "
"temporalmente (si es necesario), se harán los pasos del 3 al 5 explicados "
"arriba."

#: ..\python_docs\spladdoninternals.py:210
msgid "## Time announcements, alarms and adjusting basic settings"
msgstr "## Anuncios de tiempo, alarmas y modificación de ajustes básicos"

#: ..\python_docs\spladdoninternals.py:211
msgid ""
"Now that we know how Studio app module is born and dies, it is time for us "
"to look at what happens while Studio is in use, and we'll start with how the "
"add-on announces time, work with alarms and uses basic settings."
msgstr ""
"Ahora que sabemos cómo nace y muere el módulo de aplicación de Studio, es el "
"momento para que miremos qué pasa mientras Studio está en uso, y empezaremos "
"por ver cómo anuncia la hora este complemento, cómo trabaja con las alarmas "
"y usa ajustes básicos."

#: ..\python_docs\spladdoninternals.py:212
msgid "### Time announcement routines: a tale of four brothers"
msgstr ""
"### Procedimientos de anunciado de tiempo: un cuento de cuatro hermanos"

#: ..\python_docs\spladdoninternals.py:213
msgid ""
"SPL Studio app module for NVDA comes with four time announcement commands. "
"These are elapsed time, remaining time, broadcaster time and complete time "
"including seconds. The first two uses Studio API to obtain needed "
"information, while others use a combination of Python routines and Windows "
"API functions."
msgstr ""
"El módulo de aplicación de SPL Studio para NVDA viene con cuatro órdenes de "
"verbalización de tiempo. Estas son tiempo transcurrido, tiempo restante, "
"hora del locutor y hora completa incluyendo segundos. Los dos primeros usan "
"la api de Studio para obtener la información necesaria, mientras que los "
"otros usan una combinación de procedimientos Python y funciones de la api de "
"Windows."

#: ..\python_docs\spladdoninternals.py:214
msgid ""
"Three of these routines are assigned to commands (sometimes termed "
"gestures). These are:"
msgstr ""
"Tres de estos procedimientos tienen órdenes asignadas (a veces llamadas "
"gestos). Estas son:"

#: ..\python_docs\spladdoninternals.py:215
msgid "* Control+Alt+T: Remaining time"
msgstr "* Ctrl+alt+t: tiempo restante"

#: ..\python_docs\spladdoninternals.py:216
msgid "* Alt+Shift+T: Elapsed time"
msgstr "* Alt+shift+t: tiempo transcurrido"

#: ..\python_docs\spladdoninternals.py:217
msgid "* NVDA+Shift+F12: Broadcaster time"
msgstr "* NVDA+shift+f12: tiempo del locutor"

#: ..\python_docs\spladdoninternals.py:218
msgid ""
"One can then use Input Gestures dialog (part of NVDA screen reader) to "
"change them or assign a command to complete time routine."
msgstr ""
"Se puede usar el diálogo de gestos de entrada (parte del lector de pantalla "
"NVDA) para cambiarlas o asignar una orden a la función de hora completa."

#: ..\python_docs\spladdoninternals.py:219
msgid ""
"### A step sideways with studioAPI function: A central Studio API handler "
"and dispatcher"
msgstr ""
"### Un paso a un lado con la función StudioApi: un manejador y procesador "
"central de la api de Studio"

#: ..\python_docs\spladdoninternals.py:220
msgid ""
"Before going any further, it is important to mention a function that not "
"only is used by the first two time routines, but also comes in handy in SPL "
"Assistant and other methods. This function, called studioAPI (part of the "
"main app module and defined as a module-level function in splbase module), "
"sends messages to Studio window and retrieves the value returned. The "
"signature is:"
msgstr ""
"Antes de continuar, es importante mencionar una función que no sólo usan los "
"dos primeros procedimientos de tiempo, sino que también es útil en el "
"asistente de SPL y otros métodos. Esta función, llamada studioAPI (parte del "
"módulo de aplicación principal y definida como una función a nivel de "
"módulo), envía mensajes a la ventana de Studio y recupera el valor devuelto. "
"Su cabecera es:"

#: ..\python_docs\spladdoninternals.py:221
msgid "\tstudioAPI(arg, command)"
msgstr "\tstudioAPI(arg, command)"

#: ..\python_docs\spladdoninternals.py:222
msgid ""
"With the arguments being the message to be sent to studio window (arg and "
"command). At first glance, it may seem similar to user32's SendMessage "
"function (in fact, that's what the studioAPI function will call), but unlike "
"a typical SendMessage function routine, the Studio handle and message type "
"is automatically filled in, hence only argument (WParem) and command "
"(LParem) are needed."
msgstr ""
"Siendo los argumentos el mensaje que se envía a la ventana de Studio (arg y "
"command). A primera vista, puede parecer similar a la función SendMessage de "
"user32 (de hecho, es a la que llamará la función studioAPI), pero a "
"diferencia del procedimiento típico de la función SendMessage, el manejador "
"de Studio y el tipo de mensaje se rellenan automáticamente, por lo que sólo "
"el argumento (WParam) y la orden (LParam) son necesarios."

#: ..\python_docs\spladdoninternals.py:223
msgid ""
"In older versions of the add-on, studioAPI did more than return results. It "
"called a callback with or without an offset, as well as not return anything. "
"However, the only callback passed in was time announcer (next section), thus "
"in 2018, studioAPI function has been relegated to a thin wrapper around "
"SendMessage function with Studio window handle and message typed filled in."
msgstr ""
"En versiones más antiguas del complemento, studioAPI hacía más que devolver "
"resultados. Llamaba a una función de retorno con o sin desplazamiento, o no "
"devolvía nada. Sin embargo, la única función de retorno que se le pasaba era "
"la de verbalización de tiempo (próxima sección), y por lo tanto en 2018, la "
"función studioAPI ha sido relegada a una delgada envoltura alrededor de la "
"función SendMessage con el manejador de la ventana de Studio y el tipo de "
"mensaje rellenados."

#: ..\python_docs\spladdoninternals.py:224
msgid ""
"### First applications of studioAPI function: Announcing elapsed and "
"remaining times"
msgstr ""
"### Primeras aplicaciones de la función studioAPI: verbalización de tiempo "
"transcurrido y restante"

#: ..\python_docs\spladdoninternals.py:225
msgid ""
"When you press Control+Alt+T or Alt+Shift+T to hear remaining or elapsed "
"time, the script will first check if you are in the main Playlist Viewer, "
"and if so, will call studioAPI function with correct arguments and commands, "
"the result then being fed to announceTime function. In fact, the only "
"differences are argument that is used and the error message."
msgstr ""
"Cuando pulses ctrl+alt+t o alt+shift+t para escuchar el tiempo transcurrido "
"o el restante, el script primero comprobará si estás en el visor principal "
"de listas de reproducción, y si es así, llamará a la función studioAPI con "
"los argumentos correctos y órdenes, devolviendo el resultado a la función "
"announceTime. De hecho, las únicas diferencias son el argumento que se usa y "
"el mensaje de error."

#: ..\python_docs\spladdoninternals.py:226
msgid "### Broadcaster time: Simulating Studio's broadcaster clock"
msgstr "### Hora del locutor: simulando el reloj del locutor de Studio"

#: ..\python_docs\spladdoninternals.py:227
msgid ""
"When you listen to radio shows, you may hear messages such as, \"five "
"minutes to two\" or \"ten minutes past five\". This announcement is called "
"broadcaster time."
msgstr ""
"Cuando escuchas programas de radio, puedes oír mensajes como, \"Cinco "
"minutos para las dos\" o \"Son las cinco y diez\". Este anuncio se llama "
"hora del locutor."

#: ..\python_docs\spladdoninternals.py:228
msgid ""
"Studio does display broadcaster clock. However, because it is in the middle "
"of the screen, one has to use object navigation commands to locate it, and "
"this method was used in older add-on releases. This involved locating the "
"foreground window (api.getForegroundObject()) and navigating through a "
"preset direction to arrive at the clock object, and this is still used in "
"some places. However, this was prone to a critical problem: sometimes, the "
"object we're interested in changed positions (a good example was when "
"different builds of Studio 5.10 were released)."
msgstr ""
"Studio muestra el reloj del locutor. Sin embargo, como está en medio de la "
"pantalla, hay que usar órdenes de navegación de objetos para ubicarlo, y "
"esto se hacía en versiones antiguas del complemento. Esto implicaba ubicar "
"la ventana en primer plano (api.getForegroundObject()) y navegar en una "
"dirección prestablecida para llegar al objeto del reloj, y esto todavía se "
"usa en algunos lugares. Sin embargo, esto era propenso a un problema "
"crítico: en ocasiones, el objeto en el que estamos interesados cambiaba su "
"posición (un buen ejemplo era cuando se publicaban diferentes versiones de "
"Studio 5.10)."

#: ..\python_docs\spladdoninternals.py:229
msgid ""
"Recently, this method was abandoned in favor of using Python's time module "
"to obtain current time and convert it into a format that is familiar to "
"broadcasters, thus removing the need to use object navigation. When you "
"press NVDA+Shift+F12, NVDA first fetches local time (time.localtime), then "
"converts this into a format suitable for output. Along the way NVDA tries to "
"emulate how Studio displays broadcaster clock. Recently, a slight "
"modification was made so this process can be used to obtain time left to top "
"of the hour when NVDA+Shift+F12 is pressed twice, with the difference being "
"subtracting local time from top of the next hour. When processing is "
"complete for both cases, NVDA announces the output text."
msgstr ""
"Recientemente, este método se ha abandonado en favor del uso del módulo time "
"de Python para obtener la hora actual y convertirla a un formato que sea "
"familiar para los locutores, por lo tanto eliminando la necesidad de usar "
"navegación por objetos. Cuando pulsas NVDA+shift+f12, NVDA primero recupera "
"la hora local (time.localtime), después la convierte a un formato adecuado "
"para la salida. A lo largo del camino, NVDA intenta emular cómo muestra "
"Studio el reloj del locutor. Recientemente se ha hecho una ligera "
"modificación para que este proceso pueda usarse para obtener el tiempo "
"restante hasta la hora en punto cuando NVDA+shift+f12 se pulsa dos veces, "
"con la diferencia de que la hora local se extrae de la siguiente hora. "
"Cuando el proceso se completa para ambos casos, NVDA verbaliza el texto de "
"salida."

#: ..\python_docs\spladdoninternals.py:230
msgid "### Complete time: Windows API to the rescue"
msgstr "### Hora completa: la api de Windows al rescate"

#: ..\python_docs\spladdoninternals.py:231
msgid ""
"Here, complete time refers to time including seconds. Normally, when you "
"press NVDA+F12, NVDA excludes seconds when announcing time. All that is "
"needed to announce seconds is to change the format argument for kernel32."
"dll's GetTimeFormatEx (formerly GetTimeFormat) function. With this change, "
"NVDA can announce time including seconds, but in order to use it, you need "
"to assign a command to this feature (some app module commands are not "
"assigned by default)."
msgstr ""
"Aquí, hora completa se refiere a la hora incluyendo los segundos. "
"Normalmente, cuando pulsas NVDA+f12, NVDA excluye los segundos al verbalizar "
"la hora. Lo único que hace falta para verbalizar los segundos es cambiar el "
"argumento de formato en la función GetTimeFormatEx (antes GetTimeFormat) de "
"kernel32.dll. Con este cambio, NVDA puede verbalizar la hora incluyendo "
"segundos, pero para usarla, debes asignar una orden para esta función "
"(algunas órdenes del módulo de aplicación no vienen asignadas por defecto)."

#: ..\python_docs\spladdoninternals.py:232
msgid "### Setting alarms"
msgstr "### Establecimiento de alarmas"

#: ..\python_docs\spladdoninternals.py:233
msgid ""
"Studio app module comes with three alarms: song outro (ending), intro/ramp,  "
"and microphone active alarm. Because we need to talk about some important "
"things when talking about microphone alarm, we'll just tour the routine used "
"when setting up the intro and outro alarms."
msgstr ""
"El módulo de aplicación de Studio viene con tres alarmas: fin de canción "
"(desenlace), introducción y alarma de micrófono activo. Ya que tenemos que "
"hablar de cosas importantes al explicar la alarma del micrófono, "
"recorreremos el procedimiento usado al establecer las alarmas de "
"introducción y fin."

#: ..\python_docs\spladdoninternals.py:234
msgid ""
"Prior to 2020, separate dialogs were used to configure song outro and intro "
"alarm settings. In 2020, these have been combined into one command that "
"opens Alarms category in SPL add-on settings. The mechanism behind the "
"former method is documented for completeness."
msgstr ""
"Antes de 2020, se usaban diálogos independientes para configurar las "
"opciones de sonido de alarma de intro y salida. En 2020, se han combinado en "
"una orden que abre la categoría Alarmas en la configuración del complemento "
"de SPL. El mecanismo detrás del primer método se documenta por motivos de "
"completitud."

#: ..\python_docs\spladdoninternals.py:235
msgid ""
"The following two controls are used to configure song outro and intro "
"settings from Alarms settings (Alt+NVDA+1):"
msgstr ""
"Los siguientes dos controles se usan para configurar los ajustes de los "
"sonidos de introducción y salida en las opciones de la alarma (Alt+NVDA+1):"

#: ..\python_docs\spladdoninternals.py:236
msgid ""
"* Alarm setting: a spin box (a sping control) is used to adjust alarm "
"values. You can type the alarm value or use up or down arrow to change the "
"value. If an incorrect value is entered, the maximum value (59 for end of "
"track, 9 for song intro) will be used."
msgstr ""
"* Ajuste de alarma: un botón giratorio (un control giratorio) se usa para "
"ajustar los valores de la alarma. Puedes teclear el valor de la alarma o "
"usar flechas arriba y abajo para cambiarlo. Si se introduce un valor "
"incorrecto, se usará el valor máximo (59 para fin de pista, 9 para "
"introducción de canción)."

#: ..\python_docs\spladdoninternals.py:237
msgid "* Notification check box: This sets whether alarm will play or not."
msgstr ""
"* Casilla de verificación de notificación: establece si la alarma se "
"reproducirá o no."

#: ..\python_docs\spladdoninternals.py:238
msgid ""
"We'll learn how the alarm values are stored and retrieved in the "
"configuration management section, and you'll get to meet how intro and outro "
"alarms work in the next chapter."
msgstr ""
"Aprenderemos cómo se almacenan y recuperan los valores de la alarma en la "
"sección de gestión de configuración, y sabrás cómo funcionan las alarmas de "
"introducción y fin de pista en el próoximo capítulo."

#: ..\python_docs\spladdoninternals.py:239
msgid "#### Alarms Center"
msgstr "#### Centro de alarmas"

#: ..\python_docs\spladdoninternals.py:240
msgid ""
"Prior to introduction of Alarms category in SPL add-on settings, separate "
"dialogs were used to configure various alarm settings. In reality, it was "
"really one dialog class called Alarms Center that presented different "
"settings based on an internal flag."
msgstr ""
"Antes de la introducción de la categoría de alarmas en las opciones del "
"complemento SPL, se utilizaban diálogos separados para configurar diversas "
"opciones de la alarma. En realidad, se trataba de una única clase de "
"diálogo, llamada AlarmsCenter, que presentaba opciones diferentes en función "
"de un indicador interno."

#: ..\python_docs\spladdoninternals.py:241
msgid ""
"True to its name and function, Alarms Center not only housed end of track "
"and track intro alarms, it included microphone alarm controls, and all that "
"was needed to change its appearance was a single integer that specified "
"which portion of the dialog was shown. In case of Alarms Center dialog "
"presented from an older version of add-on settings (see a later chapter on "
"add-on configuration), all alarm controls were shown (level = 0), with "
"different levels controlling what controls were shown as follows:"
msgstr ""
"Debido a su nombre y función, el centro de alarmas no sólo alojaba las "
"alarmas de fin de pista e introducción de pista, incluía controles para la "
"alarma del micrófono, y todo lo que hacía falta para modificar su apariencia "
"era un único entero que especificaba qué partes del diálogo se mostraban. En "
"el caso del diálogo del centro de alarmas presentado desde una versión "
"antigua de las opciones del complemento (mira un capítulo posterior para más "
"información sobre la configuración del complemento), se mostraban todos los "
"controles de alarma (level=0), habiendo diferentes niveles que decidían que "
"controles se mostraban de la siguiente forma:"

#: ..\python_docs\spladdoninternals.py:242
msgid "* 0: Alarms Center, displays all controls."
msgstr "* 0: centro de alarmas, muestra todos los controles."

#: ..\python_docs\spladdoninternals.py:243
msgid "* 1: End of track alarm."
msgstr "* 1: alarma de fin de pista."

#: ..\python_docs\spladdoninternals.py:244
msgid "* 2: Track intro alarm."
msgstr "* 2: alarma de introducción de pista."

#: ..\python_docs\spladdoninternals.py:245
msgid "* 3: Microphone alarm controls."
msgstr "* 3: controles de la alarma del micrófono."

#: ..\python_docs\spladdoninternals.py:246
msgid ""
"Alarms Center was removed in 2020 in favor of standardizing around alarm "
"settings category."
msgstr ""
"El centro de alarmas se eliminó en 2020 en favor de una estandarización "
"alrededor de la categoría de opciones de alarma."

#: ..\python_docs\spladdoninternals.py:247
msgid "### Toggle settings"
msgstr "### Conmutar ajustes"

#: ..\python_docs\spladdoninternals.py:248
msgid ""
"StationPlaylist add-on comes with some toggle settings that affect the "
"operation of the app module. These include library scan announcement (Alt"
"+NVDA+R) and braille timer (Control+Shift+X). For each setting script, NVDA "
"will first check the current value, change the value and announce the new "
"value."
msgstr ""
"El complemento StationPlaylist viene con algunos ajustes conmutables que "
"afectan a la forma de operar del módulo de aplicación. Estos incluyen "
"anuncio de escaneo de biblioteca (alt+NVDA+r) y temporizador braille (ctrl"
"+shift+x). Para cada script de configuración, NVDA primero comprobará el "
"valor actual, cambiará el valor y anunciará el nuevo valor."

#: ..\python_docs\spladdoninternals.py:249
msgid ""
"## Event handling: announcing status changes, activating alarms and more"
msgstr ""
"## Procesamiento de eventos: verbalización de cambios de estado, activación "
"de alarmas y más"

#: ..\python_docs\spladdoninternals.py:250
msgid ""
"When you are producing a live show, it is important for your screen reader "
"to announce various status changes and happenings such as number of "
"listeners, outro notification, playback status, alerting you of listener "
"requests and so on. NVDA is an expert when it comes to handling status "
"changes, activating alarms and more. In this section, we'll learn the magic "
"behind this expertise: handling events."
msgstr ""
"Cuando produces un programa en vivo, es importante que tu lector de pantalla "
"verbalice diversos cambios de estado y sucesos como número de oyentes, "
"notificación de fin de pista, estado de la reproducción, alertas sobre "
"peticiones de oyentes y demás. NVDA es un experto cuando se trata de manejar "
"cambios de estado, activar alarmas y más. En esta sección, conoceremos la "
"magia que hay tras esta profesionalidad: el procesamiento de eventos."

#: ..\python_docs\spladdoninternals.py:251
msgid "### NVDA is event-driven"
msgstr "### NVDA está dirigido por eventos"

#: ..\python_docs\spladdoninternals.py:252
msgid ""
"Windows applications (especially those using Windows API) are event-driven "
"programs. Somewhere in the application is an event loop that responds to "
"various events, such as when a check box is clicked, computer is shutting "
"down and so on. NVDA, being a Windows screen reader, does use events for "
"various purposes, ranging from announcing new chat notification in Skype to "
"ignoring it completely."
msgstr ""
"Las aplicaciones de Windows (especialmente aquellas que usan la api de "
"Windows) son programas dirigidos por eventos. En algún lugar de la "
"aplicación hay un bucle que responde a diversos eventos, tales como cuando "
"se hace clic en una casilla de verificación, el ordenador se está apagando y "
"demás. NVDA, al ser un lector de pantalla, usa los eventos con diversos "
"propósitos, desde verbalizar una notificación de nuevo chat en Skype hasta "
"ignorarlo completamente."

#: ..\python_docs\spladdoninternals.py:253
msgid ""
"To handle various events, NVDA uses an event queue (queue handler) and an "
"event handler for event processing. When an event is fired by itself or from "
"other programs, NVDA first checks if the given event is worthy of its "
"attention. Then it performs actions associated with the event, such as "
"announcing changes to a control (name, value, etc.), playing beeps and "
"sounds (progress bar updates) and so on. For add-ons (mostly global plugins "
"and app modules), NVDA is eager to listen to certain events and let controls "
"fire events."
msgstr ""
"Para manejar distintos eventos, NVDA usa una cola de eventos (queueHandler) "
"y un manejador de eventos para procesarlos. Cuando un evento se dispara "
"desde NVDA o desde otros programas, NVDA primero comprueba si dicho evento "
"es digno de su atención. A continuación realiza acciones asociadas con el "
"evento, como verbalizar los cambios de un control (nombre, valor, etc.), "
"reproducir pitidos y sonidos (actualizaciones de una barra de progreso) y "
"así sucesivamente. Para los complementos (mayoritariamente extensiones "
"globales y módulos de aplicación), NVDA tiene ganas de escuchar ciertos "
"eventos y dejar que los controles los disparen."

#: ..\python_docs\spladdoninternals.py:254
msgid "Typically, an event handling routine is declared like this:"
msgstr ""
"Normalmente, un procedimiento para manejar un evento se declara de la "
"siguiente manera:"

#: ..\python_docs\spladdoninternals.py:255
msgid "\tevent_eventname(module, object in question, next handler)"
msgstr ""
"\tevent_nombredeevento(módulo, objeto en cuestión, siguiente manejador)"

#: ..\python_docs\spladdoninternals.py:256
msgid ""
"For example, for Studio app module, one event handler declared is gain focus "
"(you have moved to a different control), and is written as follows:"
msgstr ""
"Por ejemplo, para el módulo de aplicación de Studio, un manejador de eventos "
"declarado es gainFocus (te has movido a un control diferente), y está "
"escrito así:"

#: ..\python_docs\spladdoninternals.py:257
msgid "\tevent_gainFocus(self, obj, nextHandler)"
msgstr "\tevent_gainFocus(self, obj, nextHandler)"

#: ..\python_docs\spladdoninternals.py:258
msgid ""
"The routine is just like any other function (callable) except that the "
"routine called nextHandler function at the end to allow other controls to "
"respond to events."
msgstr ""
"El procedimiento es como cualquier otra función (llamable) salvo porque se "
"llama al procedimiento nextHandler al final para permitir a otros controles "
"responder a eventos."

#: ..\python_docs\spladdoninternals.py:259
msgid "### What does events have to do with Studio app module?"
msgstr ""
"### ¿Qué tienen que hacer los eventos con el módulo de aplicación de Studio?"

#: ..\python_docs\spladdoninternals.py:260
msgid ""
"Events and event handlers are crucial to the operation of the Studio app "
"module, described as \"heartbeat\" of the add-on. Events and their handlers "
"are used to perform bulk of the work required to allow the app module to "
"function. These include:"
msgstr ""
"Los eventos y los manejadores de eventos son cruciales en el funcionamiento "
"del módulo de aplicación de Studio, descrita como \"los latidos del corazón"
"\" del complemento. Los eventos y sus manejadores se usan para hacer la "
"mayoría del trabajo necesario para que el módulo de aplicación funcione. "
"Entre ellos se incluyen:"

#: ..\python_docs\spladdoninternals.py:261
msgid ""
"* Announcing status changes such as when microphone is turned on or off."
msgstr ""
"* Verbalización de cambios de estado tales como cuando el micrófono se "
"enciende o se apaga."

#: ..\python_docs\spladdoninternals.py:262
msgid "* Alarm notification, such as when end of intro is approaching."
msgstr ""
"* Notificación de alarma, como la que hay cuando se acerca el final de una "
"pista."

#: ..\python_docs\spladdoninternals.py:263
msgid ""
"* Activating certain announcement and background tasks such as activating "
"microphone alarm, announcing library scan progress and more."
msgstr ""
"* Activación de ciertas verbalizaciones y tareas en segundo plano como la "
"alarma del micrófono, el anunciado del progreso de escaneado de la "
"biblioteca y más."

#: ..\python_docs\spladdoninternals.py:264
msgid ""
"* Perform workarounds for issues such as focus problems when deleting a "
"track."
msgstr ""
"* Aplicar solución a algunos problemas como los que da el foco al eliminar "
"una pista."

#: ..\python_docs\spladdoninternals.py:265
msgid ""
"Of all the event handlers declared, the most important one is name change "
"event. It is declared as follows:"
msgstr ""
"De todos los manejadores de eventos declarados, el más importante es el "
"evento de cambio de nombre. Se declara de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:266
msgid "\tevent_nameChange(self, obj, nextHandler)"
msgstr "\tevent_nameChange(self, obj, nextHandler)"

#: ..\python_docs\spladdoninternals.py:267
msgid "When this event is fired by Studio, NVDA performs following operations:"
msgstr ""
"Cuando Studio dispara este evento, NVDA hace las siguientes operaciones:"

#: ..\python_docs\spladdoninternals.py:268
msgid "1. Various checks are performed. These include, but are not limited to:"
msgstr ""
"1. Se realizan diversas comprobaciones. Estas incluyen, pero no se limitan a:"

#: ..\python_docs\spladdoninternals.py:269
msgid "\t1. Make sure there is something to announce."
msgstr "\t1. Asegurarse de que hay algo que verbalizar."

#: ..\python_docs\spladdoninternals.py:270
msgid ""
"\t2. If using another app, NVDA will ensure that background monitor flag is "
"set (see the discussion on app module constructor in previous sections for "
"more details)."
msgstr ""
"\t2. Si se está usando otra aplicación, NVDA se asegurará de que el "
"indicador de monitorización en segundo plano esté establecido (mira la "
"exposición en el constructor del módulo de aplicación en artículos "
"anteriores para más detalles)."

#: ..\python_docs\spladdoninternals.py:271
msgid ""
"\t3. If the status to be announced is a common one such as listener count, "
"schedule and cart playback status, NVDA will check if it is permited to "
"announce them."
msgstr ""
"\t3. Si el estado a ser verbalizado es un estado común, como número de "
"oyentes, estado de la programación y reproducción del cart, NVDA comprobará "
"si tiene permitido verbalizarlo."

#: ..\python_docs\spladdoninternals.py:272
msgid ""
"2. Depending on the type of control (mostly window class name), NVDA "
"performs different operations (see below)."
msgstr ""
"2. Dependiendo del tipo de control (mayoritariamente nombre de la clase de "
"ventana), NVDA realiza distintas operaciones (mira más abajo)."

#: ..\python_docs\spladdoninternals.py:273
msgid ""
"3. Lastly, NVDA calls nextHandler() to let other controls respond to name "
"change event."
msgstr ""
"3. Finalmente, NVDA llama a nextHandler() para dejar que otros controles "
"respondan al evento de cambio de nombre."

#: ..\python_docs\spladdoninternals.py:274
msgid "### Status announcements versus alarm notification"
msgstr "### Anuncios de estado comparados con notificaciones de alarma"

#: ..\python_docs\spladdoninternals.py:275
msgid ""
"There are two groups of controls NVDA is interested in: status bar and "
"status text with window class name of TStatusBar and TStaticText, "
"respectively (Studio is a Delphi application). Depending on which control "
"fired the event, NVDA will respond differently."
msgstr ""
"Hay dos grupos de controles en los que NVDA está interesado: la barra de "
"estado y el texto de estado, con nombres de clase de ventana TStatusBar y "
"TStaticText, respectivamente (Studio es una aplicación Delphy). Dependiendo "
"del control que dispare el evento, NVDA reaccionará de forma diferente."

#: ..\python_docs\spladdoninternals.py:276
msgid "For status announcements (TStatusBar), NVDA:"
msgstr "Para anuncios de estado (TStatusBar), NVDA:"

#: ..\python_docs\spladdoninternals.py:277
msgid ""
"1. Checks IAccessible child ID (position of the control relative to the "
"parent control as exposed by MSAA (Microsoft Active Accessibility)/"
"IAccessible)."
msgstr ""
"1. Comprueba el ID del hijo de IAccessible (posición del control relativa al "
"control padre tal y como expone MSAA (Microsoft Active Accessibility) / "
"IAccessible)."

#: ..\python_docs\spladdoninternals.py:278
msgid ""
"2. If IAccessible child ID is 1, it either announces library scan progress "
"or playback status."
msgstr ""
"2. Si el identificador del hijo de IAccessible es 1, se verbaliza el "
"progreso del escaneo de la biblioteca o bien el estado de la reproducción."

#: ..\python_docs\spladdoninternals.py:279
msgid ""
"3. For other status bar objects (controls or windows), NVDA first checks if "
"it is a toggle change (ends with \"On\" or \"Off\"), and if so, it does the "
"following:"
msgstr ""
"3. Para otros objetos de la barra de estado (controles o ventanas), NVDA "
"primero comprueba si es un cambio de conmutación (acaba en \"on\" o \"off"
"\"), y si es así, hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:280
msgid ""
"\t1. If you set status announcement to words, NVDA announces toggle change "
"notification via speech."
msgstr ""
"\t1. Si estableces la verbalización de estado en palabras, NVDA verbaliza la "
"notificación de cambio de conmutación mediante voz."

#: ..\python_docs\spladdoninternals.py:281
msgid ""
"\t2. If status announcement is set to beeps, an appropriate wave file is "
"selected for playback via NVWave module (nvwave.playWaveFile; this is done "
"via messageSound function)."
msgstr ""
"\t2. Si la verbalización de estado se ha establecido en pitidos, se "
"selecciona un archivo wav adecuado y se reproduce mediante el módulo NVWave "
"(nvwave.playWaveFile; esto se hace mediante la función messageSound)."

#: ..\python_docs\spladdoninternals.py:282
msgid "\t3. Braille output is not affected - it'll announce toggle changes."
msgstr ""
"\t3. La salida braille no se ve afectada, se anunciarán los cambios de "
"conmutación."

#: ..\python_docs\spladdoninternals.py:283
msgid ""
"\t4. For cart edit mode or microphone toggle, extra steps are performed, (by "
"calling extraAction method with the status string as the argument) such as "
"activating microphone alarm or announcing that you are using Cart Explorer "
"(if this is the case). We'll come back to how this works in future "
"installments."
msgstr ""
"\t4. Para el modo de edición de cart o la conmutación del micrófono, se "
"realizan pasos extra, (llamando al método extraAction con la cadena de "
"estado como argumento), como activar la alarma del micrófono o indicar que "
"estás usando el explorador cart (si es el caso). Volveremos a explicar cómo "
"funciona esto en futuras entregas."

#: ..\python_docs\spladdoninternals.py:284
msgid ""
"4. For all other announcements, NVDA announces them. In case of schedule "
"announcement, to prevent itself from repeating the same message, NVDA checks "
"if a cached name is the same as the just changed name."
msgstr ""
"4. Para todos los demás anuncios, NVDA los verbaliza. En el caso del anuncio "
"de programación, para evitar que se repita el mismo mensaje, NVDA comprueba "
"si el nombre cambiado es igual que un nombre guardado que ya tenía."

#: ..\python_docs\spladdoninternals.py:285
msgid "For static text controls (mostly used for alarm notifications):"
msgstr ""
"Para controles de texto estático (mayormente usados para notificaciones de "
"alarma):"

#: ..\python_docs\spladdoninternals.py:286
msgid ""
"1. Checks whether NVDA is looking at remaining time for the intro or the "
"whole track."
msgstr ""
"1. Comprueba si NVDA está mirando el tiempo restante para la introducción o "
"para la pista entera."

#: ..\python_docs\spladdoninternals.py:287
msgid ""
"2. For both cases, NVDA checks if it can braille this (braille timer is not "
"off)."
msgstr ""
"2. En ambos casos, comprueba si NVDA puede emitirlo por braille (el "
"temporizador braille no está apagado)."

#: ..\python_docs\spladdoninternals.py:288
msgid ""
"3. If NVDA is told to play or announce alarms (for outro and intro), NVDA "
"plays appropriate tones (middle A (440 hertz) for outro, an octave above "
"middle C (512 hertz) for intro), or if told to do so, warns you that end of "
"track or intro is approaching (add-on 6.0 and later)."
msgstr ""
"3. Si NVDA está configurado para verbalizar o reproducir alarmas (para "
"introducción y fin), NVDA reproduce los tonos apropiados (la mitad de (440 "
"hz) para fin de pista, y una octava por encima de la mitad (512 hz) para la "
"introducción), o si se le pide hacerlo, te avisa de que el fin de pista o la "
"introducción está llegando (complemento 6.0 y posteriores)."

#: ..\python_docs\spladdoninternals.py:289
msgid ""
"The structure of event_nameChange function defined in the Studio app module "
"is such that it can be extended to handle name change event for other "
"controls (it is a tree structure, with the root being the event and two "
"subtrees, one for the status bar and another for static text). Just like "
"other add-ons that define event handling routines, name change event calls "
"nextHandler()."
msgstr ""
"La estructura de la función event_nameChange definida en el módulo de "
"aplicación de Studio está hecha de tal manera que puede extenderse para "
"manejar el evento de cambio de nombre para otros controles (es una "
"estructura en árbol, siendo la raíz el evento y dos subárboles, uno para la "
"barra de estado y otro para el texto estático). Al igual que en otros "
"complementos que definen procedimientos para manejar eventos, el evento de "
"cambio de nombre llama a nextHandler()."

#: ..\python_docs\spladdoninternals.py:290
msgid "### Other events defined in the Studio app module"
msgstr "### Otros eventos definidos en el módulo de aplicación de Studio"

#: ..\python_docs\spladdoninternals.py:291
msgid "There are five more events defined in the Studio app module. They are:"
msgstr ""
"Hay cinco eventos más definidos en el módulo de aplicación de Studio. Son "
"los siguientes:"

#: ..\python_docs\spladdoninternals.py:292
msgid ""
"* Gain focus: performs focus-related routines such as checking if you are in "
"Insert Tracks dialog in order to turn off background library scanning (more "
"on background library scan in a future installment)."
msgstr ""
"* gainFocus: realiza procedimientos relacionados con el foco, tales como "
"comprobar si estás en el diálogo de inserción de pistas para apagar el "
"escaneo en segundo plano de la biblioteca (más sobre el escaneo de la "
"biblioteca en segundo plano en una entrega futura)."

#: ..\python_docs\spladdoninternals.py:293
msgid ""
"* App module gain focus: Used to handle touchscreens (yes, Studio app module "
"has a dedicated SPL touch mode) such as assigning additional commands."
msgstr ""
"* gainFocus del módulo de aplicación: usado para procesar pantallas táctiles "
"(sí, el módulo de aplicación de Studio tiene un modo táctil dedicado para "
"SPL) que permite añadir órdenes adicionales."

#: ..\python_docs\spladdoninternals.py:294
msgid "* App module lose focus: opposite of the event above."
msgstr ""
"* loseFocus (pérdida de foco) del módulo de aplicación: el opuesto al evento "
"anterior."

#: ..\python_docs\spladdoninternals.py:295
msgid ""
"* Show: this event is specifically designed to respond to listener requests, "
"discussed below."
msgstr ""
"* Show (mostrar): este evento está diseñado específicamente para reaccionar "
"a peticiones de oyentes, de las que hablaremos más abajo."

#: ..\python_docs\spladdoninternals.py:296
msgid ""
"* Foreground: this is used to coordinate status bar content announcement "
"when Studio starts."
msgstr ""
"* Foreground (primer plano): se usa para coordinar el anuncio del contenido "
"de la barra de estado cuando se inicia Studio."

#: ..\python_docs\spladdoninternals.py:297
msgid "#### Listener requests"
msgstr "#### Peticiones de los oyentes"

#: ..\python_docs\spladdoninternals.py:298
msgid ""
"A seldom talked about component of StationPlaylist Studio is the ability to "
"host a website with a PHP script to allow listeners to request tracks to be "
"played by a broadcaster. When a request is made, Studio pops up a listener "
"request dialog that lists requested tracks."
msgstr ""
"Un componente raro del que se habla en StationPlaylist Studio es la "
"capacidad de alojar un sitio web con un script php para permitir a los "
"oyentes pedir pistas para que el locutor las reproduzca. Cuando se hace una "
"petición, Studio muestra un diálogo de petición del oyente que lista las "
"pistas solicitadas."

#: ..\python_docs\spladdoninternals.py:299
msgid ""
"Due to limitations of old NVDA releases, Studio app module did not have an "
"easy way to detect the appearance of this dialog and notify you of listener "
"requests. This is no longer the case, as NVDA allows show events to be "
"registered for background event tracking. However, because anything can fire "
"show events, tracking show events is not recommended. Knowing this, the "
"Studio app module keeps an eye on show events for one and only one window: "
"listener requests, represented by window class name of TRequests, with the "
"only job assigned for this event handler being playing a sound when requests "
"arrive provided that the requests pop-up option is set in Studio."
msgstr ""
"Debido a las limitaciones que había en antiguas versiones de NVDA, el módulo "
"de aplicación de Studio no lo tenía fácil para detectar la aparición de este "
"diálogo y notificarte las peticiones de los oyentes. Este ya no será más el "
"caso, ya que NVDA permite registrar eventos de mostrar para rastrearlos en "
"segundo plano. Sin embargo, ya que cualquier cosa puede disparar eventos de "
"mostrar, rastrearlos no se recomienda. Sabiendo esto, el módulo de "
"aplicación de Studio vigila los eventos de mostrar de una y sólo una "
"ventana: peticiones de los oyentes, representada por el nombre de clase de "
"ventana TRequests, siendo el único trabajo asignado para este manejador de "
"eventos reproducir un sonido cuando las peticiones llegan, asumiendo que la "
"opción de mostrar un globo cuando lleguen solicitudes esté activada en "
"Studio."

#: ..\python_docs\spladdoninternals.py:300
msgid ""
"So far, we have covered things that the app module performs wherever you are "
"in Studio. the next few sections will cover how the app module handles "
"specific situations, such as working with items in the playlist viewer, "
"finding tracks, library scans and so on."
msgstr ""
"Hasta ahora, hemos cubierto cosas que realiza el módulo de aplicación "
"independientemente de dónde estés en Studio. Las siguientes secciones "
"cubrirán cómo el módulo de aplicación maneja situaciones específicas tales "
"como trabajar con elementos en el visor de listas de reproducción, buscar "
"pistas, escanear la biblioteca y mucho más."

#: ..\python_docs\spladdoninternals.py:301
msgid "## Track items, overlay classes and Track Finder"
msgstr "## Elementos de pista, clases de superposición y buscador de pistas"

#: ..\python_docs\spladdoninternals.py:302
msgid ""
"While using the add-on, you may have noticed that you can perform certain "
"commands while focused on track items, and that the command to find tracks "
"is same as that of find command in web browsers. If you are curious about "
"these, then this section will let you see how it works. But first, we need "
"to go over some more facts about NVDA screen reader, this time we'll talk "
"about objects."
msgstr ""
"Al usar el complemento, te habrás dado cuenta de que puedes ejecutar ciertas "
"órdenes al tener el foco en los elementos de pista, y que la orden para "
"buscar pistas es la misma que la de buscar en navegadores web. Si tienes "
"curiosidad sobre todo esto, esta sección te permitirá ver cómo funciona. "
"Pero primero, debemos hablar de algunos hechos más sobre el lector de "
"pantalla NVDA, en esta ocasión hablaremos de objetos."

#: ..\python_docs\spladdoninternals.py:303
msgid "### Important facts about NVDA's use of objects"
msgstr ""
"### Consideraciones importantes sobre el uso que hace NVDA de los objetos"

#: ..\python_docs\spladdoninternals.py:304
msgid ""
"One of the questions I and other add-on authors and NVDA developers received "
"was, \"what exactly are objects and how are they used in NVDA?\" In "
"programming, an object is instance of the object definition coming to life "
"(this definition, called a \"class\", defines how certain things behave and "
"how information can be retrieved from this object by other parts of the "
"program; the programming paradigm that uses classes and related concepts is "
"termed \"object-oriented programming\"). For example, someone may say, "
"\"build me a phone book\", and a programmer will think about how phone book "
"entries are stored and come up with a \"phone book\" (an array of phone "
"entries), all done via objects."
msgstr ""
"Una de las preguntas que hemos recibido tanto yo como otros programadores de "
"complementos y desarrolladores de NVDA es, \"¿Qué son exactamente los "
"objetos y cómo se usan en NVDA?\". En programación, un objeto es una "
"instancia de la definición del objeto en tiempo de ejecución (esta "
"definición, que se conoce como \"clase\", define cómo se comportan ciertas "
"cosas y cómo recuperan la información de este objeto otras partes del "
"programa; el paradigma de programación que usa clases y otros conceptos se "
"llama \"programación orientada a objetos\"). Por ejemplo, alguien puede "
"decir \"Constrúyeme una guía telefónica\", y un programador pensará cómo se "
"almacenan las entradas de una guía de teléfonos y entregará una \"guía "
"telefónica\" (un array de entradas de teléfono), toda ella hecha con objetos."

#: ..\python_docs\spladdoninternals.py:305
msgid ""
"In graphical user interfaces (GUI's), an object is a more technical term for "
"controls (sometimes called widgets). This includes windows, form fields, "
"links, documents and so on. A control (object) can convey information such "
"as state of the control, location, color and so on (the control contains "
"both visible and internal attributes that can be used by other programs)."
msgstr ""
"En las interfaces gráficas de usuario (GUIs), un objeto es un término más "
"técnico para los controles (a veces llamados widgets). Esto incluye "
"ventanas, campos de formulario, enlaces, documentos y demás. Un control "
"(objeto) puede contener información como estado del control, ubicación, "
"color y demás (el control contiene atributos visibles e internos que otros "
"programas pueden usar)."

#: ..\python_docs\spladdoninternals.py:306
msgid ""
"In NVDA world, all screen elements (controls) are objects. As such, when "
"dealing with objects, NVDA uses accessibility API's to obtain needed "
"information. To provide a consistent user experience, differences between "
"accessibility API's (IAccessible, UI Automation, Java Access Bridge and so "
"on) are abstracted and provides a mechanism to announce same information "
"across controls implemented using different frameworks. For example, when a "
"check box is checked, NVDA will say \"checked\"\" - NVDA will know if you "
"checked this box because the underlying accessibility API informs NVDA of "
"this change, and the same information is spoken regardless of whether it is "
"dealing with IAccessible, UIA and so on."
msgstr ""
"En el mundo de NVDA, todos los elementos de la pantalla (controles) son "
"objetos. Por tanto, al trabajar con objetos, NVDA usa las apis de "
"accesibilidad para obtener la información necesaria. Para proporcionar una "
"experiencia de usuario consistente, se abstraen las diferencias entre las "
"distintas apis de accesibilidad (IAccessible, UI Automation, Java Access "
"Bridge y otras), y se ofrece un mecanismo para verbalizar la misma "
"información a través de controles implementados en distintos marcos de "
"trabajo. Por ejemplo, cuando se marca una casilla de verificación, NVDA dice "
"\"marcado\" - NVDA sabrá que has marcado esta casilla porque la api de "
"accesibilidad subyacente informa a NVDA de este cambio, y la misma "
"información se verbaliza sin importar que esté tratando con IAccessible, UIA "
"o cualquier otro."

#: ..\python_docs\spladdoninternals.py:307
msgid ""
"Currently, NVDA can work with IAccessible, User Interface Automation (UIA), "
"Java Access Bridge (JAB) and others (WAI ARIA is supported). Support modules "
"for these API's lives in source/NVDAObjects directory of the NVDA Core "
"source code."
msgstr ""
"Actualmente, NVDA puede trabajar con IAccessible, User Interface Automation "
"(UIA), Java Access Bridge (JAB) y otras (se soporta WAI Aria). Los módulos "
"de soporte para estas apis se encuentran en el directorio source/NVDAObjects "
"del código fuente principal de NVDA."

#: ..\python_docs\spladdoninternals.py:308
msgid "### Overlay classes: Customizing built-in objects"
msgstr "### Clases superpuestas: personalización de objetos incorporados"

#: ..\python_docs\spladdoninternals.py:309
msgid ""
"If NVDA was limited to using its own object handlers, we would be limited to "
"information that is correctly exposed by accessibility API's (no app modules "
"at all). But why is that NVDA can announce extra information for some "
"controls and comes with various app modules for different applications? This "
"is done through overlay classes - custom objects and their handlers built on "
"top of API classes (built-in objects)."
msgstr ""
"Si NVDA estuviera limitado a usar sus propios manejadores de objetos, "
"estaríamos limitados a la información que exponen correctamente las apis de "
"accesibilidad (no habría módulos de aplicación). ¿Pero por qué NVDA puede "
"verbalizar información extra de algunos controles y viene con diversos "
"módulos de aplicación para diferentes aplicaciones? Esto se hace mediante "
"clases de superposición - objetos personalizados y sus manejadores "
"construidos sobre clases de la api (objetos incorporados)."

#: ..\python_docs\spladdoninternals.py:310
msgid ""
"In essence, overlay classes are subclasses of stable API classes (subclasses "
"are specialist classes deriving (inheriting) from one or more parent "
"classes). This allows custom (overlay) objects to provide extra properties, "
"ranging from control-specific commands to removing certain properties. For "
"example, here's how NVDA's way of announcing toast notifications (Windows 8."
"x and 10) works:"
msgstr ""
"En esencia, las clases de superposición son subclases de clases estables de "
"la api (las subclases son clases especializadas que derivan (heredan) de una "
"o más clases padre). Esto permite a los objetos personalizados "
"(superpuestos) proporcionar propiedades extra, desde órdenes específicas "
"para un control a eliminación de ciertas propiedades. Por ejemplo, así es "
"como funciona NVDA al verbalizar las notificaciones emergentes (Windows 8.x "
"y 10):"

#: ..\python_docs\spladdoninternals.py:311
msgid ""
"1. Toasts are notifications from apps, and they are UIA objects (NVDAObjects."
"UIA.Toast)."
msgstr ""
"1. Las notificaciones emergentes vienen de las aplicaciones, y son objetos "
"UIA (NVDAObjects.UIA.Toast)."

#: ..\python_docs\spladdoninternals.py:312
msgid ""
"2. When events fired by toasts are received by NVDA, it'll check to make "
"sure it is dealing with toast notifications."
msgstr ""
"2. Cuando NVDA recibe los eventos disparados por las notificaciones "
"emergentes, este se asegurará de que está trabajando exactamente con este "
"tipo de notificaciones."

#: ..\python_docs\spladdoninternals.py:313
msgid ""
"3. When NVDA is dealing with toasts, it'll perform what it is told to do by "
"toast objects (announce toasts provided by \"report help balloons\" is "
"checked from Object Presentation dialog)."
msgstr ""
"3. Cuando NVDA trate con notificaciones emergentes, hará lo que le hayan "
"dicho que haga los objetos de notificación emergente (verbalizar las "
"notificaciones sólo si está marcada la casilla \"Anunciar globos de ayuda\" "
"en el diálogo Presentación de objetos)."

#: ..\python_docs\spladdoninternals.py:314
msgid "### Why do objects and overlay classes matter in Studio app module?"
msgstr ""
"### ¿Por qué son importantes los objetos y las clases de superposición en el "
"módulo de aplicación de Studio?"

#: ..\python_docs\spladdoninternals.py:315
msgid ""
"Some readers might ask this question after reading the above section on "
"overlay classes. I had to introduce overlay classes because they are "
"important in Studio app module: track items in playlist Viewer are overlay "
"classes. In fact, there are at least three of them: an abstract base class "
"representing track items for studio and other apps (appModules.splstudio."
"SPLTrackItem), a generic representation of Studio track item (appModules."
"splstudio.SPLStudioTrackItem), and a playlist viewer (main window) track "
"item (appModules.splstudio.StudioPlaylistViewerItem; in case of playlist "
"viewer item class, it derives its power from track item class for Studio, "
"which in turn is powered by abstract SPL track item powered by IAccessible)."
msgstr ""
"Algunos lectores podrían hacerse esta pregunta después de leer la sección de "
"arriba sobre las clases de superposición. Tenía que introducir las clases de "
"superposición porque son importantes en el módulo de aplicación de Studio: "
"los elementos de pista en el visor de listas de reproducción son clases de "
"superposición. De hecho, hay al menos tres de ellas: una clase base "
"abstracta que representa elementos de pista para Studio y otras aplicaciones "
"(appModules.splstudio.SPLTrackItem), una representación genérica de un "
"elemento de pista de Studio (appModules.splstudio.SPLStudioTrackItem), y un "
"elemento de pista del visor de listas de reproducción (ventana principal) "
"(appModules.splstudio.StudioPlaylistViewerItem; en el caso de la clase de "
"elemento de pista del visor de listas de reproducción, su poder deriva de la "
"clase de elemento de pista de Studio, que a su vez hereda del elemento de "
"pista abstracto de SPL proporcionado por IAccessible)."

#: ..\python_docs\spladdoninternals.py:316
msgid ""
"These classes were born when I started working on Studio 5.10 support in "
"2014. Because Studio 5.10 uses a different way of showing track properties, "
"I had to come up with a way to take care of them. Adding to the urgency was "
"the fact that Studio 5.10 uses check marks to indicate whether a track is "
"selected for playback (Studio 5.0x and earlier uses check boxes), and when "
"check marks are checked in Studio 5.10, NVDA would not announce newly "
"checked state, fixed by defining a routine to be used when SPACE is pressed "
"(via an overlay class). In addition, initial version of Track Finder (see "
"below) was sensitive to object description changes, I modified it to account "
"for differences between Studio versions."
msgstr ""
"Estas clases nacieron cuando empecé a trabajar en el soporte para Studio "
"5.10 en 2014. Ya que Studio 5.10 usa una manera diferente para mostrar "
"propiedades de la pista, tuve que trabajar en una manera de procesarlas. A "
"la urgencia se añadía el hecho de que Studio 5.10 usa marcas de verificación "
"para indicar si una pista está seleccionada para reproducción (Studio 5.0x y "
"anteriores usan casillas de verificación), y cuando estas marcas de "
"verificación se marcan en Studio 5.10, NVDA no anuncia el nuevo estado de "
"verificación, esto se arregló creando un procedimiento usado al pulsar "
"espacio (mediante una clase de superposición). Además, la primera versión "
"del buscador de pistas (mira más abajo) era sensible a cambios de "
"descripción de los objetos, la modifiqué para que tuviera en cuenta las "
"diferencias entre versiones de Studio."

#: ..\python_docs\spladdoninternals.py:317
msgid ""
"Then in 2015, when I was designing Track Dial (next section), I thought "
"about scope of this feature. I thought, \"if I let this be invoked from "
"everywhere, it could lead to issues such as errors and attempting to use "
"Track Dial from somewhere other than track items\". Then I thought, "
"\"perhaps I should limit this feature to main playlist viewer at the cost of "
"making sure I identify track items correctly\". Given that I had experience "
"with overlay classes and since there was already an overlay class for Studio "
"5.10 track items, I decided to go with the latter option, which led to "
"defining a new overlay class for Studio 5.0x track items and letting 5.10 "
"track items inherit from this new class."
msgstr ""
"Después, en 2015, cuando estaba diseñando el dial de pista (siguiente "
"sección), pensé en el ámbito de esta característica. Pensé, \"Si dejo que se "
"invoque desde cualquier parte, podría crear problemas como errores e "
"intentos de usar el dial de pista desde un lugar distinto a los elementos de "
"pista\". Después pensé, \"Tal vez debería limitar esta característica al "
"visor de listas de reproducción principal con el coste de identificar los "
"elementos de pista correctamente\". Dado que tenía experiencia con clases de "
"superposición y ya que había una clase de superposición para los elementos "
"de pista de Studio 5.10, decidí seguir adelante con la última opción, que "
"desembocó en la definición de una nueva clase de superposición para los "
"elementos de pista de Studio 5.0x y dejando que la clase de los elementos de "
"pista de Studio 5.10 heredara de esta nueva clase."

#: ..\python_docs\spladdoninternals.py:318
msgid ""
"In 2018, as support for Columns Explorer was being worked on for Creator and "
"Track Tool, I decided to overhaul the entire track item class hierarchy. "
"Since track items would use same column navigation routines, it was decided "
"to split SPL 5.0x track item class into two classes: the old track item "
"class, and a new abstract class providing basic services for Studio, Creator "
"and Track Tool track items. Also, in order to support column reordering, "
"SysListView32 class was employed, as it provides a handy routine to retrieve "
"column content for the correct column when columns were rearranged on screen."
msgstr ""
"En 2018, mientras se estaba trabajando en el soporte del explorador de "
"columnas para Creator y la herramienta de pista, decidí revisar la jerarquía "
"completa de clases de elemento de pista. Ya que los elementos de pista "
"usaban los mismos procedimientos de navegación por columnas, decidí dividir "
"la clase de elemento de pista de SPL 5.0x en dos clases: la vieja clase de "
"elemento de pista, y una nueva clase abstracta que proporciona servicios "
"básicos para los elementos de pista de Studio, Creator y la herramienta de "
"pista. Además, para dar soporte al reordenado de columnas, se empleó la "
"clase SysListView32, ya que proporciona un procedimiento útil para recuperar "
"el contenido de una columna en la columna correcta cuando estas se reordenan "
"en pantalla."

#: ..\python_docs\spladdoninternals.py:319
msgid ""
"In 2020, SPL track item overlay classes were reworked. Because base SPL "
"track item class was meant to serve as a blueprint, it became an abstract "
"base class in 2019. What was formerly Studio 5.10 track item class became a "
"specialist class for playlist viewer items, and old Studio 5.0x item class "
"was revived to represent track items found in other parts of Studio such as "
"Insert Tracks dialog. At the same time, column navigation services provided "
"by the SPL track item base class was eliminated in favor of using facilities "
"provided by SysListView32 list item class to provide consistency with NVDA "
"itself and to add column navigation commands for Creator's playlist editor "
"and Remote VT client (prior to this, SPL track item base provided customized "
"column navigation commands). Later, track name and description routines were "
"revised to use SysListView32 routines (see the section on custom column "
"announcement order), which resolved a long-standing problem where track "
"information would not be announced unless \"report object descriptions\" "
"setting was enabled from NVDA."
msgstr ""
"En 2020, se reconstruyeron las clases de superposición del elemento de pista "
"de SPL. Ya que la clase base del elemento de pista fue concebida para actuar "
"como plantilla, se convirtió en una clase abstracta en 2019. Lo que primero "
"era la clase de elemento de pista de Studio 5.10 se convirtió en una clase "
"especializada para los elementos del visor de listas de reproducción, y la "
"antigua clase para elementos de Studio 5.0x revivió para representar "
"elementos de pista disponibles en otras partes de Studio, como en el diálogo "
"Insertar pistas. Al mismo tiempo, los servicios de navegación por columnas "
"proporcionados por la clase base de elemento de pista de SPL se eliminaron "
"en favor de las funciones proporcionadas por la clase del elemento de lista "
"SysListView32 para proporcionar consistencia con el propio NVDA y añadir "
"órdenes de navegación por columnas en el editor de listas de reproducción de "
"Creator y el cliente Remote VT (antes, la clase base de elemento de pista de "
"SPL proporcionaba órdenes de navegación por columnas personalizada). "
"Posteriormente, se revisaron los procedimientos de nombre de pista y "
"descripción para usar procedimientos de SysListView32 (consulta la sección "
"sobre el anuncio de columnas en orden personalizado), lo que que resolvió un "
"problema de larga duración por el que no se anunciaba la información de la "
"pista a menos que se activase la opción \"Anunciar descripciones de objeto\" "
"en NVDA."

#: ..\python_docs\spladdoninternals.py:320
msgid "### Track items overview"
msgstr "### Descripción de los elementos de pista"

#: ..\python_docs\spladdoninternals.py:321
msgid ""
"Each track item in Studio (including playlist viewer), and in extension, "
"tracks found in Creator, Track Tool, and Remote VT client, consists of a row "
"of columns (6 for Studio 5.0x and earlier, 18 for playlist viewer in Studio "
"5.10 and later, may vary on other track lists). As far as NVDA is concerned, "
"it is an overlay class that provides a number of services, including:"
msgstr ""
"Cada elemento de pista de Studio (incluyendo el visor de listas de "
"reproducción) y, en extensión, las pistas que se encuentran en Creator, la "
"herramienta de pista y el cliente Remote VT, consta de una fila de columnas "
"(6 para Studio 5.0x y anteriores, 18 para el visor de lista de reproducción "
"de Studio 5.10 y posteriores, puede variar en otras listas de pistas). Tal y "
"como está concebido NVDA, es una clase de superposición que proporciona un "
"número de servicios, incluyendo:"

#: ..\python_docs\spladdoninternals.py:322
msgid ""
"* Routines for navigating and announcing various columns (most were "
"eliminated in favor of using SysListView32 list item routines directly in "
"2020)."
msgstr ""
"* Procedimientos para anunciar y navegar por diversas columnas (la mayoría "
"se eliminaron en favor del uso de los procedimientos de la clase "
"SysListView32 directamente en 2020)."

#: ..\python_docs\spladdoninternals.py:323
msgid ""
"* Announcing columns in specific order (see the next chapter on importance "
"of column navigation)."
msgstr ""
"* Verbalizar las columnas en un orden específico (mira el próximo capítulo "
"para conocer la importancia de la navegación por columnas)."

#: ..\python_docs\spladdoninternals.py:324
msgid ""
"* For Studio, obtaining track comments if defined (see track comments "
"section below)."
msgstr ""
"* En Studio, Obtener comentarios de pista si están definidos (mira la "
"sección de comentarios de pista más abajo)."

#: ..\python_docs\spladdoninternals.py:325
msgid ""
"* For studio 5.10 and later, a routine to handle when check marks are "
"checked (when you check a track by pressing SPACE, NVDA will announce the "
"newly checked state and will update the braille display accordingly)."
msgstr ""
"* En Studio 5.10 y posteriores, un procedimiento para procesar la marcación "
"de las marcas de verificación (cuando marques una pista pulsando espacio, "
"NVDA verbalizará el nuevo estado de verificación y actualizará la pantalla "
"braille apropiadamente)."

#: ..\python_docs\spladdoninternals.py:326
msgid ""
"We'll come back to track items when talking about columns later. For now, "
"let's move onto two related features in Studio app module that works with "
"track items: Track Finder and track comments. There is a second feature that "
"deals with Track Finder, and we'll meet this feature in the next section."
msgstr ""
"Volveremos a los elementos de pista cuando hablemos de columnas en el "
"próximo artículo. Por ahora, movámonos a dos características relacionadas en "
"el módulo de aplicación de Studio que funcionan con los elementos de pista: "
"buscador de pistas y comentarios de pista. Hay una segunda característica "
"que trata con el buscador de pistas, la encontraremos en la siguiente "
"sección."

#: ..\python_docs\spladdoninternals.py:327
msgid "### Track Finder: Locating tracks given a search string"
msgstr ""
"### Buscador de pistas: ubicación de pistas dada una cadena de búsqueda"

#: ..\python_docs\spladdoninternals.py:328
msgid ""
"Track Finder allows you to search for tracks with the given artist or song "
"title. This is done by performing a \"linear search\" - examining one track "
"item to the next until the search term is found. This feature was partly "
"inspired by similar features in other screen readers and NVDA's own find "
"facility (cursorManager.FindDialog and its friends)."
msgstr ""
"El buscador de pistas permite buscar pistas dado su autor o el título de la "
"canción. Esto se hace mediante una \"búsqueda lineal\" - examinando un "
"elemento de pista y el siguiente hasta que se encuentra el término de "
"búsqueda. Esta característica está inspirada en parte por características "
"similares en otros lectores de pantalla y la propia función de búsqueda de "
"NVDA (cursorManager.FindDialog y sus amigos)."

#: ..\python_docs\spladdoninternals.py:329
msgid ""
"Track finder is not limited to searching for artist or title: a variation of "
"this dialog (called Column Search) allows you to search for text in specific "
"columns such as duration, file name and so on. Another variation of this "
"dialog, called Time Range Finder (which is a separate dialog of its own "
"(splmisc.SPLTimeRangeDialog) but modeled after Track Finder) uses Studio API "
"to locate tracks with duration between minimum and maximum specified by a "
"user."
msgstr ""
"El buscador de pistas no está limitado a buscar por artista o título: una "
"variante de este diálogo (llamada búsqueda por columnas) permite buscar "
"texto en columnas específicas como duración, nombre de archivo y demás. Otra "
"variante de este diálogo, llamada buscador de rango de tiempo (que es un "
"diálogo separado del otro (splmisc.SPLTimeRangeDialog) pero modelado después "
"del buscador de pista) usa la api de Studio para ubicar pistas con duración "
"entre el mínimo y el máximo especificados por el usuario."

#: ..\python_docs\spladdoninternals.py:330
msgid ""
"In reality, Track Finder and Column Search are a single dialog (splmisc."
"SPLFindDialog) that presents two dialogs (does this sound familiar?). For "
"now, we'll talk about how the original Track Finder (add-on 2.x to 5.x) "
"works (stay tuned for the next section to learn more about Column Search and "
"the complete refactoring of track finder and its applications)."
msgstr ""
"En realidad, el buscador de pistas y el buscador por columnas son un único "
"diálogo (splmisc.SPLFindDialog) que presenta dos diálogos (¿Te suena de "
"algo?). Por ahora, hablaremos de cómo el buscador de pistas original "
"(complementos del 2.x al 5.x) funciona (estáte atento a la próxima sección "
"para aprender más sobre la búsqueda de columnas y la refactorización "
"completa del buscador de pistas y sus aplicaciones)."

#: ..\python_docs\spladdoninternals.py:331
msgid "#### Original track Finder: commands, routines and controls"
msgstr "#### Buscador de pistas original: órdenes, procedimientos y controles"

#: ..\python_docs\spladdoninternals.py:332
msgid ""
"To use Track Finder, press Control+NVDA+F (wait, I saw this command before). "
"For anyone who are accustomed to NVDA's browse mode, this command would be "
"familiar: find text in webpages. This command performs activities similar to "
"alarm dialogs (see sections above): after conditions are checked (making "
"sure you are in playlist viewer and you have added at least one track) and "
"setting required flags, NVDA opens Track Finder dialog where you can enter a "
"search term and press ENTER. NVDA will call track finder function "
"(trackFinder) to locate the track with the given search term, and depending "
"on search results, NVDA will move focus to the track or open a dialog saying "
"results were not found."
msgstr ""
"Para usar el buscador de pistas, pulsa ctrl+NVDA+f (espera, yo ya he visto "
"antes esta orden). Para cualquiera que esté acostumbrado al modo exploración "
"de NVDA, esta orden debería ser familiar: buscar texto en páginas web. Esta "
"orden realiza actividades similares a los diálogos de alarma (mira los "
"artículos anteriores): después de comprobar las condiciones (asegurándose de "
"que estás en el visor de lista de reproducción y que has añadido al menos "
"una pista) y establecer los indicadores necesarios, NVDA abre el diálogo del "
"buscador de pistas, donde puedes introducir un término de búsqueda y pulsar "
"intro. NVDA llamará a la función del buscador de pistas (trackFinder) para "
"encontrar la pista con el término de búsqueda dado, y dependiendo de los "
"resultados de búsqueda, NVDA moverá el foco a la pista o abrirá un diálogo "
"diciendo que no se encontraron resultados."

#: ..\python_docs\spladdoninternals.py:333
msgid ""
"Two other commands are used as part of Track Finder: Find next and previous, "
"assigned to NVDA+F3 and NVDA+Shift+F3, respectively (they also come from "
"browse mode). When these commands are invoked, it'll check if you have "
"searched for a term before, and if not, it'll open Track Finder dialog. If "
"you have searched for a term before, NVDA will perform linear search with "
"search direction specified (trackFinder method in the app module takes "
"various parameters, and one of them is search direction)."
msgstr ""
"Otras dos órdenes se usan como parte del buscador de pistas: buscar "
"siguiente y anterior, asignadas to NVDA+f3 y NVDA+shift+f3, respectivamente "
"(también vienen del modo exploración). Cuando se invocan estas órdenes, se "
"comprueba si has introducido previamente un término de búsqueda, y si no es "
"así, se abrirá el diálogo del buscador de pistas. Si previamente ya has "
"buscado un término, NVDA hará una búsqueda lineal en la dirección de "
"búsqueda especificada (el método trackFinder en el módulo de aplicación "
"acepta varios parámetros, y uno de ellos es la dirección de búsqueda)."

#: ..\python_docs\spladdoninternals.py:334
msgid "#### Track Finder 1.0 versus 2.0"
msgstr "#### Comparación del buscador de pistas 1.0 y el 2.0"

#: ..\python_docs\spladdoninternals.py:335
msgid ""
"In add-on version 2.0 to 5.x, when told to find tracks, NVDA will look for "
"search term in track descriptions (in case you are searching for artist in "
"Studio 5.0x, NVDA will also check the name of the check box, as this holds "
"artist name). Although this was simple to implement, it had some issues:"
msgstr ""
"En las versiones del complemento 2.0 a 5.x, al pedirle que busque pistas, "
"NVDA buscará el término de búsqueda en las descripciones de pista (en caso "
"de que estés buscando por artista en Studio 5.0x, NVDA también comprobará el "
"nombre de la casilla de verificación, ya que contiene el nombre del "
"artista). Aunque esto fue fácil de implementar, tenía varios problemas:"

#: ..\python_docs\spladdoninternals.py:336
msgid ""
"1. Because of track item changes in Studio 5.10, I had to spend some time "
"adjusting the track finder formula."
msgstr ""
"1. A causa de los cambios del elemento de pista en Studio 5.10, tuve que "
"dedicar algún tiempo a ajustar la fórmula del buscador de pistas."

#: ..\python_docs\spladdoninternals.py:337
msgid ""
"2. When finding a track in a playlist with hundreds of tracks loaded, "
"finding a track at the end of the playlist took several seconds, and this "
"wasn't acceptable to users."
msgstr ""
"2. Al buscar una pista en una lista de reproducción con cientos de pistas "
"cargadas, encontrar una pista al final de la lista llevaba varios segundos, "
"y esto no era aceptable para los usuarios."

#: ..\python_docs\spladdoninternals.py:338
msgid ""
"In add-on 6.0, thanks to column search, Track Finder's performance was "
"improved. Also, track finder was split into two functions: trackFinder still "
"manages moving focus or showing the error dialog, while the linear search "
"now lives in a private function. This design allows track finder routine to "
"be used by more than one feature (in this case, place marker feature uses "
"this, as you'll see in the next section."
msgstr ""
"En el complemento 6.0, gracias a la búsqueda por columnas, el rendimiento "
"del buscador de pistas mejoró. Además, el buscador se dividió en dos "
"funciones: trackFinder todavía gestiona el movimiento del foco o muestra el "
"diálogo de error, mientras que la búsqueda lineal ahora reside en una "
"función privada. Este diseño permite que el procedimiento de búsqueda de "
"pistas pueda ser usado por más de una característica (en este caso, el "
"marcador de posiciones lo usa, como verás en la próxima sección)."

#: ..\python_docs\spladdoninternals.py:339
msgid ""
"For both versions, the signature of trackFinder method (linear search "
"routine in 1.0, search results manager in 2.0) in the Studio app module is:"
msgstr ""
"En ambas versiones, la cabecera del método trackFinder (procedimiento de "
"búsqueda lineal en 1.0, gestor de resultados de búsqueda en 2.0) en el "
"módulo de aplicación de Studio es:"

#: ..\python_docs\spladdoninternals.py:340
msgid "\ttrackFinder(self, text, obj, directionForward=True, column=None)"
msgstr "\ttrackFinder(self, text, obj, directionForward=True, column=None)"

#: ..\python_docs\spladdoninternals.py:341
msgid ""
"Text is the search term, obj is where the search should begin, direction "
"specifies search direction and column is used if Column Search is used "
"(searching for text in specific columns). In Track Finder 2.0 (add-on 6.0), "
"add an \"s\" to column keyword, and since 2021, columns argument expects a "
"list of column position integers."
msgstr ""
"Text es el término de búsqueda, obj indica dónde debería comenzar la "
"búsqueda, direction especifica la dirección de búsqueda y column se usa si "
"se emplea la búsqueda por columnas (buscar texto en columnas específicas). "
"En el buscador de pistas 2.0 (complemento 6.0), se añade una \"s\" a la "
"palabra clave column, y desde 2021, el argumento de columnas espera una "
"lista de enteros de posición de columna."

#: ..\python_docs\spladdoninternals.py:342
msgid ""
"## Method resolution  order and importance of column navigation in track "
"items, Track Tool and other features"
msgstr ""
"## Orden de resolución de métodos e importancia de la navegación por "
"columnas en los elementos de pista, la herramienta de pista y otras "
"características"

#: ..\python_docs\spladdoninternals.py:343
msgid ""
"In the previous section, you saw how overlay classes work, as well as how "
"track items in Studio are defined and used. We'll continue our tour of track "
"items by looking at column navigation feature and how it is used in various "
"places. But before we get into that, we need to talk about how NVDA knows "
"how certain commands apply in specific situations via method resolution "
"order."
msgstr ""
"En la sección anterior vimos cómo funcionaban las clases de superposición, y "
"cómo se definen y usan los elementos de pista en Studio. Vamos a continuar "
"con nuestro recorrido por los elementos de pista mirando la característica "
"de navegación por columnas y viendo cómo se usa en diversos lugares. Pero "
"antes de eso, debemos hablar sobre cómo sabe NVDA cómo aplicar ciertas "
"órdenes en situaciones específicas mediante el orden de resolución de "
"métodos."

#: ..\python_docs\spladdoninternals.py:344
msgid ""
"### Method resolution order: locating commands and defining command scope"
msgstr ""
"### Orden de resolución de métodos: ubicación de órdenes y definición de su "
"ámbito"

#: ..\python_docs\spladdoninternals.py:345
msgid ""
"If multiple classes (objects) are defined, especially if inheritance is "
"involved, it becomes hard to determine which method is which and where "
"various methods are defined. This becomes complicated when two or more "
"classes inherit from a single parent, or multiple inheritance is in use "
"(Python supports both scenarios)."
msgstr ""
"Si se definen múltiples clases (objetos), especialmente si la herencia está "
"implicada, es duro determinar qué método es cuál y dónde se definen diversos "
"métodos. Esto se hace más complicado cuando dos o más clases heredan del "
"mismo padre, o se emplea herencia múltiple (Python soporta ambos escenarios)."

#: ..\python_docs\spladdoninternals.py:346
msgid ""
"One way Python solves this is through Method Resolution Order (MRO). Simply "
"put, when a method is to be used, it first looks at whether this method is "
"defined in the object it is dealing with, and if not, will consult the "
"parent of this object."
msgstr ""
"Una forma que tiene Python de resolver esto es a través del orden de "
"resolución de métodos (ORM). Resumiendo, cuando tiene que usarse un método, "
"primero se mira si el método está definido en el objeto con el que estamos "
"tratando, y si no, se consultará al padre de este objeto."

#: ..\python_docs\spladdoninternals.py:347
msgid ""
"For example, suppose we have a list box that defines a scroll method, and a "
"custom list box widget inherits from this list box (in effect, custom list "
"box is a list box). To make matters slightly complicated, let's say the "
"scroll method is not defined (not really defined) in the custom list box. "
"Then when the user scrolls through the custom list box, Python will see that "
"the custom list box does not have the scroll method, so it'll look at the "
"parent (original list box) and use its scroll method (in this case, yes, "
"Python will use the parent's scroll method)."
msgstr ""
"Por ejemplo, supongamos que tenemos un cuadro de lista que define un método "
"scroll, y un widget de cuadro de lista personalizado que hereda de este "
"cuadro de lista (en efecto, el cuadro de lista personalizado es un cuadro de "
"lista). Para complicar un poco más las cosas, digamos que el método scroll "
"no está definido (no está realmente definido) en el cuadro de lista "
"personalizado. Cuando el usuario se desplace por el cuadro de lista "
"personalizado, Python verá que el cuadro de lista personalizado no tiene el "
"método scroll, por lo que mirará en el padre (cuadro de lista original) y "
"empleará su método scroll (en este caso sí, Python usará el método scroll "
"del padre)."

#: ..\python_docs\spladdoninternals.py:348
msgid ""
"In terms of NVDA, method resolution order comes in handy when dealing with "
"overlay classes. This has wide ranging consequences, including ability to "
"limit where certain commands can be used to not defining a command (setting "
"the script bound to gesture to None), effectively forcing NVDA to look up a "
"given gesture from the base class (parent). If NVDA cannot locate the "
"command in question, it'll pass this to Windows, which then sends the "
"command to the active program."
msgstr ""
"En términos de NVDA, el orden de resolución de métodos es útil al tratar con "
"clases de superposición. Esto tiene un extenso rango de consecuencias, "
"incluyendo la habilidad de limitar dónde se pueden emplear ciertas órdenes o "
"no definir una orden (configurando el script para que esté asociado al gesto "
"None), forzando a NVDA de forma efectiva a que busque un gesto en una clase "
"base (padre). Si NVDA no puede hallar la orden en cuestión, la pasará a "
"Windows, que a continuación envía la orden al programa activo."

#: ..\python_docs\spladdoninternals.py:349
msgid "### Finishing the puzzle: MRO and Studio's track items"
msgstr "### Terminando el puzle: MRO y los elementos de pista de Studio"

#: ..\python_docs\spladdoninternals.py:350
msgid ""
"As described in the previous section, Studio app module defines three "
"classes for track items: abstract base class for tracks found in Studio and "
"other apps, a class representing track items found throughout Studio, and "
"another for representing playlist viewer track items. In reality, all that "
"matters is the first two, with the playlist viewer item class providing "
"custom routines on top of the Studio track item class. In case of MRO, "
"playlist viewer item class will be consulted if playlist viewer is in use, "
"otherwise main Studio track item class will be consulted, which in turn will "
"consult SPL track item base class. Other apps such as Track Tool and Remote "
"VT client have their own MRO, ultimately consulting SPL track item base "
"class defined in Studio app module."
msgstr ""
"Como se describía en la sección anterior, el módulo de aplicación de Studio "
"define tres clases para los elementos de pista: una clase base abstracta "
"para pistas encontradas en Studio y otras aplicaciones, una clase "
"representando elementos de pista que se encuentran a lo largo de Studio, y "
"otra que representa elementos de pista del visor de listas de reproducción. "
"En realidad, todo lo que importa está en las dos primeras, y la clase para "
"el visor de listas de reproducción proporciona procedimientos personalizados "
"sobre la clase de elemento de pista de Studio. En caso de MRO, se consultará "
"al módulo del visor de listas de reproducción si este está en uso, y en "
"cualquier otro caso NVDA consultará al elemento principal de pista de "
"Studio, lo que a efectos prácticos es consultar la clase base de elemento de "
"pista de SPL. Otras aplicaciones, como la herramienta de pista o el cliente "
"Remote VT, tienen su propio MRO, que desemboca también en una consulta a la "
"clase base de elemento de pista de SPL definida en el módulo de aplicación "
"de Studio."

#: ..\python_docs\spladdoninternals.py:351
msgid ""
"The most important job of appModules.splstudio.SPLTrackItem class is "
"announcing column data. Prior to 2020, it also housed column navigation "
"commands and routines such as next and previous column, handler for Track "
"Dial (historical), and a dedicated routine to announce column information "
"given column number and optional header. In 2020, only Columns Explorer "
"remains."
msgstr ""
"El trabajo más importante de la clase appModules.splstudio.SPLTrackItem es "
"anunciar datos de columnas. Antes de 2020, alojaba también procedimientos y "
"órdenes de navegación por columnas tales como columna siguiente o anterior, "
"el manejador del dial de pista (histórico), y un procedimiento dedicado para "
"anunciar la información de una columna dados su número y una cabecera "
"opcional. En 2020, sólo permanece el explorador de columnas."

#: ..\python_docs\spladdoninternals.py:352
msgid ""
"On top of the base SPL track item class is general Studio track item class, "
"which does nothing, as it is meant to represent tracks in places such as "
"Insert Tracks dialog. However the class that represents playlist viewer "
"items (appModules.splstudio.StudioPlaylistViewerItem) adds routines and "
"scripts for use from playlist viewer. These include:"
msgstr ""
"Por encima de la clase base de elemento de pista de SPL se encuentra la "
"clase general de elemento de pista de Studio, que no hace nada, ya que está "
"diseñada para representar pistas en lugares como el diálogo para insertar "
"pistas. Sin embargo, la clase que representa los elementos del visor de "
"lista de reproducción (appModules.splstudio.StudioPlaylistViewerItem) añade "
"procedimientos y scripts para usar desde el visor de lista de reproducción. "
"Entre ellos se incluyen:"

#: ..\python_docs\spladdoninternals.py:353
msgid ""
"* reportFocus: This is called when reporting track items to you "
"(broadcaster). It's main job is to see if custom column order is defined "
"(see below) and builds needed pieces if column order is specified. Later in "
"2020, column order handling was moved to track name getter."
msgstr ""
"* reportFocus: se llama a esta función al informarte a ti (locutor) sobre "
"los elementos de pista. Su función principal es ver si se ha definido un "
"orden personalizado para las columnas (mira más abajo) y construir las "
"piezas necesarias si se especifica un orden de columnas. Posteriormente en "
"2020, el manejo del orden de columnas se movió al getter del nombre de pista."

#: ..\python_docs\spladdoninternals.py:354
msgid ""
"* Track comments: Routines related to working with comments for traks (see "
"the previous section for details)."
msgstr ""
"* Comentarios de pista: procedimientos relacionados con el trabajo con "
"comentarios de pista (mira la sección anterior para más detalles)."

#: ..\python_docs\spladdoninternals.py:355
msgid "* Announcing toggle state of tracks when Space is pressed."
msgstr ""
"* Anunciar el estado de conmutación de las pistas al pulsar la barra "
"espaciadora."

#: ..\python_docs\spladdoninternals.py:356
msgid ""
"* Toggling column announcement inclusion and order between screen order and "
"custom order (see column announcement order section for details)."
msgstr ""
"* Conmutar la inclusión y el orden de los anuncios de columna entre orden en "
"pantalla y orden personalizado (consulta la secci´ón sobre el orden de "
"anuncio de las columnas para más detalles)."

#: ..\python_docs\spladdoninternals.py:357
msgid "### Birth of Track Dial: from hesitation to possibilities"
msgstr "### Nacimiento del dial de pista: de la duda a las posibilidades"

#: ..\python_docs\spladdoninternals.py:358
msgid ""
"Note: Information on Track Dial is kept for reference purposes. Track Dial "
"was deprecated in 2017 with the release of add-on 17.04."
msgstr ""
"Nota: la información sobre el dial de pista se conserva con propósitos de "
"referencia y consulta. El dial de pista quedó obsoleto en 2017 con la "
"publicación del complemento 17.04."

#: ..\python_docs\spladdoninternals.py:359
msgid ""
"As I was writing the add-on, one of the top suggestions I received was "
"ability to use enhanced arrow keys feature to review columns. This feature "
"allows broadcasters using screen reader scripts to use arrow keys to review "
"column information such as artist, duration and so on. As of time of this "
"writing, all three screen reader scripts support this feature."
msgstr ""
"Según estaba programando el complemento, una de las sugerencias que más "
"recibía era la capacidad de usar la característica de flechas mejoradas para "
"revisar columnas. Esta característica permite a los locutores que usan "
"scripts para lectores de pantalla usar las flechas para revisar información "
"de columnas como artista, duración y demás. En el momento en que escribo "
"esto, los tres scripts para lectores de pantalla soportan esta "
"característica."

#: ..\python_docs\spladdoninternals.py:360
msgid ""
"At first, I told broadcasters that this wasn't possible. My impression back "
"then (summer 2014) was that I had to manipulate track description text (obj."
"description) to enable this possibility. But seeing how other screen readers "
"implement this convinced me that it might be possible to implement this for "
"NVDA users, thus I started researching this in fall 2014."
msgstr ""
"Al principio, dije a los locutores que esto no era posible. Mi impresión por "
"entonces (verano de 2014) era que tendría que manipular el texto de la "
"descripción de pista (obj.description) para activar esta posibilidad. Pero "
"viendo cómo implementaban esto otros lectores de pantalla, me convencí de "
"que podría ser posible implementarlo para usuarios de NVDA, y por tanto "
"comencé a investigar sobre ello a finales de 2014."

#: ..\python_docs\spladdoninternals.py:361
msgid ""
"I started by looking for patterns in description text that could be used to "
"give users an impression that column navigation was active (when it was "
"not). I studied how Python handles regular expressions and manipulated "
"substrings (str.find and slicing) with no satisfactory results. Then in "
"2015, while working on improving support for Studio's own stream encoder, I "
"noticed that the encoder entries were SysListView32 objects (NVDAObjects."
"IAccessible.SysListView32). Careful study of this object, especially a "
"method to retrieve column content, gave me an idea as to how to bring Track "
"Dial to life."
msgstr ""
"Comencé buscando patrones en el texto de la descripción que pudieran ser "
"usados para dar a los usuarios la impresión de que la navegación por "
"columnas estaba activa (cuando no lo estaba). Estudié cómo trabajaba Python "
"con las expresiones regulares y cómo manipulaba subcadenas (str.find y "
"división) sin resultados satisfactorios. Después, en 2015, mientras "
"trabajaba para mejorar el soporte para el codificador propio de Studio, me "
"di cuenta de que las entradas del codificador eran objetos SysListView32 "
"(NVDAObjects.IAccessible.SysListView32). Estudié cuidadosamente este objeto, "
"especialmente un método para recuperar el contenido de una columna, y esto "
"me dio una idea sobre cómo traer el dial de pista a la vida."

#: ..\python_docs\spladdoninternals.py:362
msgid "### The magic behind Track Dial: SysListView32 controls"
msgstr "### La magia tras el dial de pista: los controles SysListView32"

#: ..\python_docs\spladdoninternals.py:363
msgid ""
"SysListView32 controls are lists with items organized into columns. For "
"example, certain apps use these controls to arrange entries into columns, "
"such as in certain table-based apps, and in case of studio, displaying "
"various status about encoders."
msgstr ""
"Los controles SysListView32 son listas con elementos organizados en "
"columnas. Por ejemplo, ciertas aplicaciones usan estos controles para "
"ordenar entradas en columnas, tales como ciertas aplicaciones basadas en "
"tablas, y en el caso de Studio, mostrar diversos estados de los "
"codificadores."

#: ..\python_docs\spladdoninternals.py:364
msgid ""
"When these controls are encountered, NVDA allows you to use table navigation "
"commands (Control+Alt+arrows) to navigate between columns, provided that "
"there are child objects (columns) exposed by the accessibility API "
"implementation in use. Table navigation commands are supplied by another "
"class (behaviors.RowWithFakeNavigation; the behaviors mix-in includes things "
"NVDA should perform in various scenarios, including terminal input and "
"output, editable text handling (via a dedicated module) and so on). This is "
"all possible thanks to a method in SysListView32 class (NVDA Core) that "
"allows one to retrieve column text, and this became the engine for Track "
"Dial, Columns Explorer and other column navigation facilities in this add-on "
"(I say \"add-on\" because column navigation is used by both Studio and Track "
"Tool). This was further solidified in 2018 and later when all track item "
"classes (including Creator track items and SAM encoder entries) were "
"repowered by SysListView32.ListItem class."
msgstr ""
"Cuando se encuentran estos controles, NVDA permite usar órdenes de "
"navegación de tablas (ctrl+alt+flechas) para navegar entre columnas, "
"asumiendo que hay objetos hijo (columnas) expuestos por la implementación de "
"la api de accesibilidad en uso. Las órdenes de navegación de tabla vienen "
"ofrecidas por otra clase (behaviors.RowWithFakeNavigation; el paquete "
"behaviors incluye cosas que NVDA debería hacer en diversos escenarios, "
"incluyendo entrada y salida de una terminal, procesamiento de texto editable "
"(mediante un módulo dedicado) y demás). Todo esto es posible gracias a un "
"método en la clase SysListView32 (núcleo de NVDA) que permite recuperar el "
"texto de una columna, y este se convirtió en el motor para el dial de pista, "
"el explorador de columnas, y otras características de navegación por "
"columnas en el complemento (digo \"complemento\" porque tanto Studio como la "
"herramienta de pista usan la navegación por columnas). Esto se solidificó "
"más en 2018 y más tarde, cuando todas las clases de elementos de pista "
"(incluyendo los elementos de pista de Creator y las entradas del codificador "
"SAM) fueron potenciadas por la clase SysListView32.ListItem."

#: ..\python_docs\spladdoninternals.py:365
msgid ""
"Until 2018, the column text retrieval routine (which lives in SysListView32 "
"and a copy lives in splstudio.splmisc module) was as follows:"
msgstr ""
"Hasta el 2018, El procedimiento de recuperación del texto de la columna (que "
"reside en SysListView32 y cuya copia reside en el módulo splstudio.splmisc) "
"era el siguiente:"

#: ..\python_docs\spladdoninternals.py:366
msgid ""
"1. Features requiring text from a specific column will call a private "
"function in splstudio.splmisc module, which will take the current object and "
"the column index as parameters."
msgstr ""
"1. Las características que necesiten texto de una columna específica "
"llamarán a una función privada en el módulo splstudio.splmisc, que recibirá "
"el objeto y el índice de columna como parámetros."

#: ..\python_docs\spladdoninternals.py:367
msgid ""
"2. The column retriever first looks up the handle for the process where the "
"control lives, then creates a place holder for the buffer to hold the column "
"content."
msgstr ""
"2. El recuperador de columnas primero obtiene el manejador del proceso donde "
"reside el control, luego crea un marcador de posición para el buffer que "
"capturará el contenido de la columna."

#: ..\python_docs\spladdoninternals.py:368
msgid ""
"3. Next, it looks at the size of the underlying sysListView32 control "
"(ctypes.sizeof) and asks Windows to allocate storage for an internal "
"SysListView32 control via kernel32.dll's VirtualAllocEx. This is needed to "
"store the resulting column text. Same is done for another place holder to "
"store the actual column text by calling VirtualAllocEx."
msgstr ""
"3. A continuación, mira el tamaño del control SysListView32 subyacente "
"(ctypes.sizeof) y pide a Windows que reserve almacenamiento para un control "
"SysListView32 interno mediante la función VirtualAllocEx de kernel32.dll. "
"Esto es necesario para almacenar el texto de la columna resultante. Lo mismo "
"se hace con otro marcador de posición para almacenar el texto real de la "
"columna llamando a VirtualAllocEx."

#: ..\python_docs\spladdoninternals.py:369
msgid ""
"4. The retriever then creates an internal SysListView32 control used as a "
"place holder to store column text, then asks Windows to tell the process "
"where the column text lives to reveal the column text for the specified "
"column (first calls WriteProcessMemory, sens a message via user32.dll's "
"SendMessage to retrieve text length, then uses ReadProcessMemory to retrieve "
"the actual column text if there is something to read). Once the column text "
"is revealed, the retriever stores the text inside the text buffer (ctypes."
"create_unicode_buffer, allocated to store the resulting text)."
msgstr ""
"4. El recuperador crea a continuación un control interno SysListView32 usado "
"como marcador de posición para almacenar el texto de la columna, después le "
"pide a Windows que le diga al proceso donde reside el texto de la columna "
"que revele el texto de columna de la columna especificada (primero se llama "
"a WriteProcessMemory, se envía un mensaje mediante la función SendMessage de "
"user32.dll para recuperar la longitud del texto, luego se usa "
"ReadProcessMemory para recuperar el texto real de la columna si hay algo que "
"leer). Una vez se ha revelado el texto de la columna, el recuperador "
"almacena el valor dentro del buffer de texto (ctypes.create_unicode_buffer, "
"reservado para almacenar el texto resultante)."

#: ..\python_docs\spladdoninternals.py:370
msgid ""
"5. Lastly, the retriever frees resources (VirtualFreeEx) and returns the "
"just retrieved column text, which can be used by routines requesting this."
msgstr ""
"5. Por último, el recuperador libera recursos (VirtualFreeEx) y devuelve el "
"texto de la columna recién recuperado, que puede ser usado por los "
"procedimientos que lo habían solicitado."

#: ..\python_docs\spladdoninternals.py:371
msgid ""
"In 2018, this was simplified by use of SysListView32 routines directly. In "
"2020, almost the entire table navigation routines are performed by the base "
"SysListView32 item class (the only exception being row navigation in "
"playlist viewer)."
msgstr ""
"En 2018, esto se simplificó usando directamente los procedimientos de "
"SysListView32. En 2020, la clase base de elemento SysListView32 realiza casi "
"todos los procedimientos de navegación por tablas (siendo la única excepción "
"la navegación por filas en el visor de listas de reproducción)."

#: ..\python_docs\spladdoninternals.py:372
msgid ""
"### Column retrieval and navigation routines: from hesitation to a "
"cornerstone"
msgstr ""
"### Recuperación de columnas y procedimientos de navegación: de la duda a la "
"piedra angular"

#: ..\python_docs\spladdoninternals.py:373
msgid ""
"Column content retrieval routine has become one of the cornerstones of this "
"add-on. In addition to Track Dial, ten other routines rely on it: Column "
"Search, track place marker, column announcement order, Track Columns "
"Explorer, vertical column navigation, playlist snapshots, playlist "
"transcripts, Creator and Track Tool app modules, playlist editor found in "
"Creator and Remote VT client, and when working with SAM encoder entries. "
"Let's find out how seven of these work in more detail (playlist snapshots "
"and transcripts are described under SPL Assistant section, as they deserve "
"sections of their own)."
msgstr ""
"El procedimiento de recuperación del contenido de las columnas ha llegado a "
"ser una de las piedras angulares de este complemento. Además del dial de "
"pista, otros diez procedimientos lo usan: búsqueda por columnas, marcador de "
"posición de pista, verbalización del orden de columnas, explorador de "
"columnas de pista, navegación vertical por columnas, instantáneas de listas "
"de reproducción, transcripción de listas de reproducción, los módulos de "
"aplicación de la herramienta de pista y de Creator, el editor de listas de "
"reproducción que se encuentra en Creator y en el cliente Remote VT, y las "
"entradas del codificador SAM. Veamos cómo funcionan siete de ellos con más "
"detalle (las instantáneas de lista de reproducción y la transcripción de "
"listas se describen en la sección del asistente de SPL, aunque se merecen "
"secciones propias)."

#: ..\python_docs\spladdoninternals.py:374
msgid "#### Track Dial: Navigating columns in track items"
msgstr "#### Dial de pista: navegación por columnas en elementos de pista"

#: ..\python_docs\spladdoninternals.py:375
msgid "Note: no longer applicable since 17.04, included here for completeness."
msgstr ""
"Nota: ya no es aplicable desde la versión 17.04, se incluye aquí por "
"completitud."

#: ..\python_docs\spladdoninternals.py:376
msgid ""
"The column retriever routine is just one of the activities performed during "
"Track Dial, and to see the beauty of this feature, assign a command to "
"toggle Track Dial (you need to focus on the track item before opening Input "
"Gestures dialog, as Track Dial is used by track items alone). Once you "
"assign a command to toggle Track Dial and toggle this on, Studio will set a "
"flag indicating that Track Dial is on, which causes left and right arrow "
"keys to be assigned to column navigation commands (this flag is stored as "
"part of the add-on configuration database). If you tell NVDA to play beeps "
"for status announcements (see previous chapter), NVDA will play a high beep. "
"Once you are done with Track Dial, press the just assigned command to turn "
"off Track Dial, at which point left and right arrow keys return to their "
"original functions, a low beep will be heard (if told to do so) and Track "
"Dial flag will be cleared."
msgstr ""
"El procedimiento de recuperación de columna es una de las actividades "
"realizadas durante el dial de pista, y para ver la belleza de esta "
"característica, asigna una orden para conmutar el dial de pista (debes poner "
"el foco en el elemento de pista antes de abrir el diálogo de gestos de "
"entrada, ya que el dial de pista sólo es usado por los elementos de pista). "
"Una vez asignes la orden para conmutar el dial de pista y lo actives, Studio "
"establecerá un indicador indicando que el dial de pista está activo, lo que "
"causa que las flechas izquierda y derecha se asignen a órdenes de navegación "
"de columna (este indicador se almacena como parte de la base de datos de "
"configuración del complemento). Si configuras NVDA para que reproduzca "
"pitidos para anunciar los cambios de estado (mira el capítulo anterior), "
"NVDA reproducirá un pitido agudo. Una vez acabes con el dial de pista, pulsa "
"la orden asignada para apagarlo. En este punto las flechas izquierda y "
"derecha volverán a ejercer sus funciones originales, se oirá un pitido grave "
"(si se configura NVDA para ello) y se eliminará el indicador del dial de "
"pista."

#: ..\python_docs\spladdoninternals.py:377
msgid ""
"When navigating columns, NVDA will check if you are at the edge of the track "
"row, and if so, it will play a beep and repeat the last column text. If not, "
"NVDA will look at the column you wish to navigate to (stored in the app "
"module), then it'll call the column text retriever to retrieve the column "
"text."
msgstr ""
"Al navegar por columnas, NVDA comprobará si te encuentras en el borde de la "
"fila de la pista, y si es así, reproducirá un pitido y repetirá el texto de "
"la última columna. Si no, NVDA mirará la columna a la que quieres navegar "
"(almacenada en el módulo de aplicación), después llamará al recuperador de "
"texto de columna para recuperar el texto de esa columna."

#: ..\python_docs\spladdoninternals.py:378
msgid ""
"To handle differences between Studio 5.0x and 5.1x, each track item class "
"informs NVDA as to how leftmost column should be handled. For Studio 5.0x, "
"leftmost column is artist field (obj.name will be checked), while track "
"checked status is \"shown\" in Studio 5.10 (obj.name will be announced)."
msgstr ""
"Para procesar las diferencias entre Studio 5.0x y 5.1x, cada clase de "
"elemento de pista informa a NVDA cómo debería procesarse la columna que hay "
"a la izquierda del todo. En Studio 5.0x, la columna más a la izquierda es el "
"campo artista (se comprobará obj.name), mientras que el estado de "
"verificación de la pista es el que se \"muestra\" en Studio 5.10 (se "
"verbalizará obj.name)."

#: ..\python_docs\spladdoninternals.py:379
msgid "#### Custom column announcement order: What to announce and how"
msgstr ""
"#### Orden personalizado de verbalización de columnas: qué anunciar y cómo"

#: ..\python_docs\spladdoninternals.py:380
msgid ""
"Track Dial routine also allowed another top request to come to life: column "
"announcement order. This allows you (broadcaster) to hear columns in "
"specific order and to exclude certain columns from being announced."
msgstr ""
"El procedimiento del dial de pista también permitió dar vida a otra "
"solicitud: orden de verbalización de columnas. Esto te permite (locutor) oír "
"las columnas en un orden específico y excluir ciertas columnas para que no "
"sean verbalizadas."

#: ..\python_docs\spladdoninternals.py:381
msgid ""
"Until 2020, custom column announcement order handler resided in reportFocus "
"method in the main track item class. In late 2020, this was split into a "
"custom track name getter, as track name announcement was revised to use "
"SysListView32 routines directly (prior to this, track item class relied on "
"default IAccessible implementation)."
msgstr ""
"Hasta 2020, el manejador del orden personalizado del anuncio de columnas "
"residía en el método reportFocus de la clase principal del elemento de "
"pista. A finales de 2020, se dividió en un método getter personalizado del "
"nombre de pista, ya que se revisó el anuncio de pista para usar directamente "
"los procedimientos de SysListView32 (antes de esto, la clase del elemento de "
"pista se apoyaba en la implementación predeterminada de IAccessible)."

#: ..\python_docs\spladdoninternals.py:382
msgid ""
"In order to use this, you must tell NVDA to not use screen order (add-on "
"settings dialog's column announcement panel, or in 21.01 and later, press "
"NVDA+V while focused on playlist viewer item to toggle this). Then from the "
"same settings panel (column announcement), check the columns you wish to "
"hear and/or use the columns list to set column announcement order. The "
"column announcement order is a list box with two buttons: move up and down."
msgstr ""
"Para usarlo, hay que indicar a NVDA que no utilice el orden en pantalla "
"(diálogo de ajustes del complemento, panel de anuncio de columnas, o "
"simplemente NVDA+v teniendo el foco en un elemento del visualizador de lista "
"de reproducción para conmutarlo en la versión 21.01 o posterior). A "
"continuación, en el mismo panel de opciones (anuncio de columnas), marca las "
"columnas que quieras oír y usa la lista de columnas para configurar el orden "
"de verbalización. El orden de verbalización de columnas es un cuadro de "
"lista con dos botones: mover arriba y abajo."

#: ..\python_docs\spladdoninternals.py:383
msgid ""
"Once column order and included columns are defined, NVDA will use this "
"information to build track property text. Prior to 2021, this was track "
"description, later shifting to building track name text. This is done by "
"repeatedly calling the column retriever routine for columns you wish to "
"hear, then using the column order you defined to build parts of the property "
"text (a combination of a list and str.join is used)."
msgstr ""
"Una vez se definen las columnas incluidas y el orden de las mismas, NVDA "
"usará esta información para construir el texto de descripción del elemento "
"de pista. Antes de 2021, esta era la descripción de la pista, cambiando "
"después a la construcción del texto de nombre de la pista. Esto se hace "
"llamando repetidamente al procedimiento recuperador de columna en las "
"columnas que quieres oír, y usando después el orden de columnas que "
"definiste para construir partes del texto de la descripción (se usa una "
"combinación de lista y str.join)."

#: ..\python_docs\spladdoninternals.py:384
msgid ""
"For example, if NVDA is told to announce title and artist (in that specific "
"order), NVDA will first locate title, then will add artist information. This "
"is then presented as, \"Title: some title, Artist: some artist\"."
msgstr ""
"Por ejemplo, si hacemos que NVDA anuncie el título y el artista (en ese "
"orden específico), NVDA primero ubicará el título, luego añadirá la "
"información del artista. Esto después se presentará como \"Título: algún "
"título, artista: algún artista\"."

#: ..\python_docs\spladdoninternals.py:385
msgid ""
"It is also possible to suppress announcement of column headers. Until 2020, "
"add-on settings shipped with a dedicated checkbox to toggle header "
"announcement. From 2021 onwards, NVDA's table row/column header setting is "
"used to set column header announcement for Studio track columns."
msgstr ""
"También es posible suprimir el anuncio de las cabeceras de columna. Hasta "
"2020, las opciones del complemento venían con una casilla de verificación "
"dedicada a conmutar el anuncio de cabeceras. Desde 2021 en adelante, se usa "
"la opción de NVDA de cabeceras de fila y columna para configurar el anuncio "
"de cabeceras de columna en las columnas de pista de Studio."

#: ..\python_docs\spladdoninternals.py:386
msgid "##### Track name versus description?"
msgstr "##### ¿Nombre de pista versus descripción?"

#: ..\python_docs\spladdoninternals.py:387
msgid ""
"Until 2020, because Studio's track item class relied mostly on default "
"IAccessible implementation, track description recorded trakc properties. For "
"this reason, whenever custom column order or inclusion were defined, "
"reportFocus method would construct a custom track description text based on "
"the custom column order. This changed in add-on 20.11 when SysListView32 "
"routines took a greater role in defining track items, and since NVDA builds "
"custom text for item names based on column information, Studio's track item "
"class will also construct custom item name based on custom column order and "
"inclusion if defined. Because of this, from late 2020, column builder was "
"split into a different method, namely a custom item name getter which is the "
"method used by NVDA to retrieve name text for a control."
msgstr ""
"Hasta 2020, y ya que la clase de elemento de pista de Studio se apoyaba en "
"la implementación predeterminada de IAccessible, la descripción de la pista "
"registraba las propiedades de la misma. Por esta razón, siempre que se "
"definía un orden o inclusión personalizados de columnas, el método "
"reportFocus construía un texto de descripción de pista personalizado basado "
"en el orden de columnas personalizado. Esto cambió en el complemento 20.11, "
"cuando los procedimientos de SysListView32 adquirieron un rol más importante "
"en la definición de elementos de pista, y ya que NVDA construye texto "
"personalizado para los nombres de elementos basándose en la información de "
"las columnas, la clase de elemento de pista de Studio también construirá "
"nombres de elementos personalizados basándose en el orden personalizado de "
"columnas e inclusión, si se han definido. A causa de esto, desde finales de "
"2020, el constructor de columnas está dividido en un método diferente, un "
"getter personalizado del nombre del elemento que se usa para que NVDA "
"recupere el texto del nombre de un control."

#: ..\python_docs\spladdoninternals.py:388
msgid "#### Track Columns Explorer: Retrieve information from specific columns"
msgstr ""
"#### Explorador de columnas de pista: recuperar información de columnas "
"específicas"

#: ..\python_docs\spladdoninternals.py:389
msgid ""
"In add-on 7.0, it became possible to let NVDA announce information from "
"specific columns. This is done by letting NVDA assign SPL Assistant, 1 "
"through 0 (6 for Studio 5.0x) to a function to obtain information from "
"specific column (slot); add-on 8.0 changed these commands to use Control+NVDA"
"+number row, and SPL Assistant, number row commands were removed in 2020. "
"This is called Track Columns Explorer (usually termed Coloumns Explorer)."
msgstr ""
"En el complemento 7.0, apareció la posibilidad de hacer que NVDA verbalice "
"información de columnas específicas. Esto se hace dejando a NVDA que asigne "
"al asistente de SPL, del 1 al 0 (6 para Studio 5.0x) una función para "
"obtener información de una columna específica (slot); el complemento 8.0 "
"cambia estas órdenes para usar ctrl+NVDA+fila de números, y se eliminó "
"Asistente de SPL, órdenes de la fila numérica en 2020. Esto se llama "
"explorador de columnas de pista (generalmente conocido como explorador de "
"columnas)."

#: ..\python_docs\spladdoninternals.py:390
msgid ""
"In addition to using column retriever routine in Track Dial, Columns "
"Explorer needs to know Studio version in use, as Studio 5.1x shows columns "
"not found in Studio 5.0x (this is checked when entering SPL Assistant as "
"discussed later). In addition, since not all track items expose more than "
"ten columns or column slots cannot be configured for some items (notably "
"Creator's Playlist Editor), Columns Explorer needs to know how many columns "
"can be retrieved and take action if no column slot can be defined."
msgstr ""
"Además de usar el procedimiento de recuperación de columna en el dial de "
"pista, el explorador de columnas necesita saber la versión de Studio en uso, "
"ya que Studio 5.1x muestra columnas que no están en Studio 5.0x (esto se "
"comprueba al entrar en el asistente de SPL, como se expondrá más tarde). "
"Además, como no todos los elementos de pista exponen más de diez columnas o "
"no se pueden configurar los slots de columna en algunos elementos "
"(perceptible en el editor de listas de reproducción de Creator), el "
"explorador de columnas necesita saber cuántas columnas se pueden recuperar y "
"tomar medidas si no se puede definir un slot de columna."

#: ..\python_docs\spladdoninternals.py:391
msgid ""
"Once column slots are defined (for items allowing configuring column slots, "
"which are Studio's Playlist Viewer, Track Tool, and Creator's main tracks "
"list, Columns Explorer performs the following:"
msgstr ""
"Una vez se definen los slots de columna (en elementos que lo permitan, que "
"son el visor de listas de reproducción de Studio, la herramienta de pista y "
"la lista principal de pistas de Creator), el explorador de columnas hace lo "
"siguiente:"

#: ..\python_docs\spladdoninternals.py:392
msgid ""
"1. Checks if you are indeed focused on a track item, and if not, it'll say "
"\"not a track\". With the removal of SPL Assistant, number row commands in "
"2020, this is no longer checked as track items themselves will define "
"Columns Explorer commands."
msgstr ""
"1. Comprueba si el foco se encuentra en un elemento de pista y, si no, dirá "
"\"No es una pista\". Con la eliminación de las órdenes Asistente de SPL, "
"fila numérica en 2020, esto ya no se comprueba, ya que los propios elementos "
"de pista definirán por sí mismos órdenes del explorador de columnas."

#: ..\python_docs\spladdoninternals.py:393
msgid ""
"2. Consults a list of column slots and locates corresponding column index "
"for the slot in question."
msgstr ""
"2. Consulta una lista de slots de columna y ubica el índice de columna "
"correspondiente del slot en cuestión."

#: ..\python_docs\spladdoninternals.py:394
msgid ""
"3. Uses column retriever routine to announce column header and content for "
"the selected column slot."
msgstr ""
"3. Usa el procedimiento de recuperación de columna para verbalizar la "
"cabecera de la columna y el contenido de la columna del slot seleccionado."

#: ..\python_docs\spladdoninternals.py:395
msgid "##### Optimization bonus: I've rearranged columns in studio 5.10..."
msgstr ""
"##### Bonus de optimización: he reordenado las columnas en Studio 5.10..."

#: ..\python_docs\spladdoninternals.py:396
msgid ""
"Due to a different control data structure in use, one can rearrange columns "
"in Studio 5.10 and later. But how does NVDA know exactly which column is "
"which? This is thanks to the fact that internal column position doesn't "
"change. When you rearrange columns, you are changing the way columns are "
"presented on screen. When column retriever function (described above) is "
"invoked, Studio returns column content for a column index regardless of "
"where this column is located on screen. Not only this makes Columns Explorer "
"simpler to implement, it allows Track Dial to track (after manual "
"intervention) column presentation changes on screen."
msgstr ""
"Debido a que hay una estructura de control de datos diferente en uso, se "
"pueden reordenar columnas en Studio 5.10 y posteriores. ¿Pero cómo sabe NVDA "
"exactamente qué columna es cuál? Lo hace gracias al hecho de que la posición "
"interna de las columnas no cambia. Cuando reordenas columnas, estás "
"cambiando la forma en que estas se presentan en pantalla. Cuando se invoca a "
"la función de recuperación de columna (descrita arriba), Studio devuelve el "
"contenido de la columna dado un índice sin importar dónde se encuentra esa "
"columna en pantalla. Esto no sólo hace que la implementación del explorador "
"de columnas sea más simple, sino que permite al dial de pista rastrear "
"(después de una intervención manual) los cambios de presentación de las "
"columnas en pantalla."

#: ..\python_docs\spladdoninternals.py:397
msgid "##### What about items where column slots cannot be configured?"
msgstr ""
"##### ¿Qué pasa con los elementos donde no se pueden configurar slots de "
"columna?"

#: ..\python_docs\spladdoninternals.py:398
msgid ""
"For items other than Studio's Playlist Viewer, Track Tool, and Creator's "
"main tracks list, Columns Explorer slots cannot be configured (hence absence "
"of \"exploreColumns\" property, notably in Creator's Playlist Editor in add-"
"on 20.02). If so, Columns Explorer will resort to displaying data for "
"columns shown in display order (as it appears on screen). As a bonus, if a "
"track item does not show more than ten columns, Columns Explorer will "
"announce an error message if current column position is out of bounds "
"(beyond column count for the track item). These were done in order to "
"support Playlist Editor properly as track items in there only shows eight "
"columns."
msgstr ""
"Para elementos distintos al visor de listas de reproducción de Studio, la "
"herramienta de pista y la lista principal de pistas de Creator, los slots "
"del explorador de columnas no pueden configurarse (de ahí la ausencia de la "
"propiedad \"exploreColumns\", perceptible en el editor de listas de "
"reproducción de Creator en el complemento 20.02). Si es así, el explorador "
"de columnas las reordenará para mostrar sus datos en el orden que se "
"muestran (como se ven en pantalla). Como extra, si un elemento de pista no "
"muestra más de diez columnas, el explorador de columnas anunciará un mensaje "
"de error si la posición de la columna actual se sale de los límites (más "
"allá de la cantidad de columnas del elemento de pista). Estos se hicieron "
"para dar soporte al editor de listas de reproducción adecuadamente, ya que "
"sus elementos de pista sólo muestran ocho columnas."

#: ..\python_docs\spladdoninternals.py:399
msgid "#### Column Search: Finding text in specific columns"
msgstr "#### Búsqueda por columnas: encontrar texto en columnas específicas"

#: ..\python_docs\spladdoninternals.py:400
msgid ""
"In the previous section, I mentioned that a single dialog performs double "
"duty when talking about Track Finder. We'll now tour the other side of the "
"coin: Column Search."
msgstr ""
"En la sección anterior, mencioné que un único diálogo hace una doble función "
"cuando hablamos del buscador de pistas. Ahora recorreremos el otro lado de "
"la moneda: la búsqueda por columnas."

#: ..\python_docs\spladdoninternals.py:401
msgid ""
"Column Search dialog adds a second control to Track Finder: a list of "
"columns. Once text is entered to be searched in a column, NVDA will use "
"trackFinder routine (discussed earlier) to locate text in specific columns "
"(I mentioned that trackFinder routine takes column(s) as the argument, and "
"this is where this argument comes in handy). In fact, both regular Track "
"Finder and Column Search uses the above column retriever routine to locate "
"column text (the private linear search function introduced in Track Finder "
"2.0 locates text from specified columns, and for regular track finder, "
"artist and title columns are examined). Just like the regular Track Finder, "
"once search is done, it'll either move you to a track item or present an "
"error dialog."
msgstr ""
"El diálogo de búsqueda por columnas añade un segundo control al buscador de "
"pistas: una lista de columnas. Una vez se introduce el texto a buscar en una "
"columna, NVDA usará el procedimiento trackFinder (expuesto antes) para "
"ubicar texto en columnas específicas (he mencionado que el procedimiento "
"trackFinder recibe la(s) columnas(s) como un argumento, y aquí es donde el "
"argumento resulta útil). De hecho, tanto el buscador de pistas normal como "
"la búsqueda por columnas usan el procedimiento de recuperación de columnas "
"de arriba para ubicar el texto de la columna (la función privada de búsqueda "
"lineal introducida en el buscador de pistas 2.0 localiza texto de columnas "
"específicas, y en el buscador de pistas normal, se examinan las columnas "
"artista y título). Al igual que con el buscador de pistas normal, una vez se "
"ha hecho la búsqueda, se moverá el foco a un elemento de pista o bien se "
"presentará un diálogo de error."

#: ..\python_docs\spladdoninternals.py:402
msgid ""
"So what causes one dialog to present both Track Finder and Column Search "
"dialog? It's all thanks to the arguments passed into the find dialog "
"constructor. The signature is:"
msgstr ""
"Entonces, ¿qué causa que un diálogo presente tanto el buscador de pistas "
"como el buscador por columnas? Esto se hace gracias a los argumentos pasados "
"al constructor del diálogo de búsqueda. La cabecera es:"

#: ..\python_docs\spladdoninternals.py:403
msgid "\tsplmisc.SPLFindDialog(parent, obj, text, title, columnSearch=False)"
msgstr "\tsplmisc.SPLFindDialog(parent, obj, text, title, columnSearch=False)"

#: ..\python_docs\spladdoninternals.py:404
msgid ""
"The last argument (columnSearch) determines which version of the dialog to "
"present. The object (obj) is needed to tell NVDA where to begin the search "
"and to call the track finder routine defined in the object's app module."
msgstr ""
"El último argumento (columnSearch) determina la versión del diálogo que se "
"debe presentar. El objeto (obj) es necesario para decirle a NVDA dónde "
"empezar la búsqueda y para llamar al procedimiento del buscador de pistas "
"definido en su módulo de aplicación."

#: ..\python_docs\spladdoninternals.py:405
msgid ""
"#### Track Place Marker: A variation of column search for finding filenames"
msgstr ""
"#### Marcador de pista: una variante de la búsqueda por columnas para "
"encontrar nombres de archivo"

#: ..\python_docs\spladdoninternals.py:406
msgid ""
"Another feature that uses column routines is track place marker. You would "
"drop a place marker at the current track (SPL Assistant, Control+K), move "
"around the playlist, then move to the track with the marker set on it (SPL "
"Assistant, K)."
msgstr ""
"Otra característica que usa los procedimientos de columna es el marcador de "
"pista. Tú pondrías un marcador en la pista actual (asistente de SPL, ctrl"
"+k), te moverías por la lista de reproducción, y después te moverías a la "
"pista que tiene el marcador (asistente de SPL, k)."

#: ..\python_docs\spladdoninternals.py:407
msgid ""
"Once you drop a place marker, Studio app module will record the filename of "
"the currently focused track, and when you wish to move to the marked track, "
"NVDA will use column search routine to locate it. Unlike a typical column "
"search, NVDA will call the private linear search routine directly and will "
"select the column where filename is stored (in effect, you are asking NVDA "
"to do a column search after choosing filename as the data you are looking "
"for)."
msgstr ""
"Una vez sitúes un marcador, el módulo de aplicación de Studio registrará el "
"nombre del archivo de la pista que tenga actualmente el foco, y cuando "
"quieras moverte a la pista marcada, NVDA usará el procedimiento de búsqueda "
"en columnas para encontrarla. Al contrario que pasa con las búsquedas por "
"columna típicas, NVDA llamará a la función privada de búsqueda lineal "
"directamente y seleccionará la columna donde se encuentre el nombre del "
"archivo (en efecto, le estás diciendo a NVDA que haga una búsqueda por "
"columnas después de elegir nombre de archivo como dato a buscar)."

#: ..\python_docs\spladdoninternals.py:408
msgid "#### Vertical column navigation: just announce the column I want"
msgstr ""
"#### Navegación vertical por columnas: verbalizar sólo la columna que quiero"

#: ..\python_docs\spladdoninternals.py:409
msgid ""
"Ever since implementing Track Dial, some broadcasters requested adding "
"support for moving through tracks vertically (as in reading specific columns "
"just like moving to a different row in a table). This also resolved an issue "
"where pressing Control+Alt+up/down arrow keys caused the monitor to flip "
"upside down. This is achieved by asking SPLTrackItem.reportFocus to announce "
"just the column the user wants when Control+Alt+up/down arrow is pressed, "
"all controlled by a hidden class variable. This feature not only works for "
"vertical column navigation - it is also used when a broadcaster requests "
"only one column be announced, and the column to be announced can be "
"customized (not to be confused with column announcement order routine "
"discussed above)."
msgstr ""
"Desde que se implementó el dial de pista, algunos locutores solicitaron "
"añadir soporte para moverse verticalmente por las pistas (como leer columnas "
"específicas pero moviéndose a una fila diferente como en una tabla). Esto "
"también resolvió un problema por el que al pulsar las teclas ctrl+alt"
"+flechas arriba y abajo causaba que el monitor diera vueltas. Esto se hace "
"pidiéndole a SPLTrackItem.reportFocus que verbalice la columna que el "
"usuario quiere al pulsar ctrl+alt+flechas arriba y abajo, todo controlado "
"por una variable de clase oculta. Esta característica no sólo funciona con "
"la navegación vertical de columnas - también se usa cuando un locutor "
"solicita que sólo se anuncie una columna, y la columna a ser verbalizada "
"puede personalizarse (no hay que confundirse con el procedimiento de orden "
"de verbalización de columnas expuesto arriba)."

#: ..\python_docs\spladdoninternals.py:410
msgid ""
"Vertical column navigation was simplified in 2020 by using routines found in "
"SysListView32 list item class directly. Prior to 2020, custom vertical "
"navigation routines were used, and for places other than playlist viewer, "
"vertical column navigation was impossible. In 2020, vertical column "
"navigation routines from SysListView32 are used, which also introduced "
"vertical navigation to places such as Track Tool."
msgstr ""
"La navegación vertical por columnas se simplificó en 2020 utilizando "
"procedimientos localizados en la clase de elemento de lista SysListView32 "
"directamente. Antes de 2020 se usaban procedimientos personalizados para la "
"navegación vertical por columnas, y en lugares distintos al visor de listas "
"de reproducción la navegación vertical por columnas era imposible. En 2020, "
"se usan los procedimientos de navegación vertical por columnas de "
"SysListView32, lo que hizo posible que la navegación vertical por columnas "
"llegara a lugares como la herramienta de pista."

#: ..\python_docs\spladdoninternals.py:411
msgid "#### Track Tool and Creator: one routine, multiple app modules"
msgstr ""
"#### Herramienta de pista y Creator: un procedimiento, múltiples módulos de "
"aplicación"

#: ..\python_docs\spladdoninternals.py:412
msgid ""
"Column retriever routine is not only employed by Studio app module, but is "
"also used in Track Tool and Creator app modules (part of the add-on). These "
"app modules (specifically, track item classes) uses column retriever for "
"reviewing column data via table navigation commands and announcing column "
"information (Control+NVDA+1  through 0, now termed Columns Explorer for "
"Track Tool/SPL Creator)."
msgstr ""
"El procedimiento de recuperación de columnas no sólo se emplea en el módulo "
"de aplicación de Studio, sino que también se usa en los módulos de "
"aplicación de la herramienta de pista y de Creator (parte de este "
"complemento). Estos módulos de aplicación (específicamente, las clases de "
"elemento de pista) usan el recuperador de columnas para revisar los datos de "
"columna mediante órdenes de navegación por tablas y anunciar la información "
"de columna (ctrl+NVDA+números del 1 al 0, ahora llamado explorador de "
"columnas en la herramienta de pista y en SPL Creator)."

#: ..\python_docs\spladdoninternals.py:413
msgid "#### Playlist editor: column navigation keeps expanding"
msgstr ""
"#### Editor de listas de reproducción: la navegación por columnas continúa "
"expandiéndose"

#: ..\python_docs\spladdoninternals.py:414
msgid ""
"Creator comes with Playlist Editor, a tool to manage locally generated "
"playlists. Remote VT client also comes with a dedicated playlist editor but "
"is designed to edit playlists stored remotely. Track items shown on the "
"playlist editor window are indeed SPL track items, and as such they support "
"column navigation. Because they only come with up to 8 columns, there is no "
"need to provide custom Columns Explorer feature for these items. Other than "
"that, it supports other column announcement and navigation features found in "
"other track items."
msgstr ""
"Creator viene con el editor de listas de reproducción, una herramienta para "
"gestionar listas de reproducción generadas localmente. Remote VT también "
"viene con un editor de listas de reproducción dedicado, pero está diseñado "
"para editar listas de reproducción almacenadas en remoto. Los elementos de "
"pista mostrados en la ventana del editor de listas de reproducción son "
"elementos de pista de SPL, y por tanto soportan la navegación por columnas. "
"Ya que sólo vienen con hasta 8 columnas, no hay necesidad de proporcionar la "
"función personalizada de explorador de columnas en estos elementos. Aparte "
"de eso, soporta otras características de anuncio y navegación por columnas "
"disponibles en los demás elementos de pista."

#: ..\python_docs\spladdoninternals.py:415
#: ..\python_docs\spladdoninternals.py:502
msgid "### Few remarks"
msgstr "### Unas pocas notas"

#: ..\python_docs\spladdoninternals.py:416
msgid ""
"Of all the features in the StationPlaylist add-on, column navigation is one "
"of my favorites (besides Cart Explorer and encoder support and others). I "
"enjoyed working with this routine and learned a few things about Windows "
"API, as well as open possibilities not previously explorered before, such as "
"Track Tool and Column Search. I hope that you'll find column navigation "
"commands to be useful in your broadcasts."
msgstr ""
"De todas las características del complemento de StationPlaylist, la "
"navegación por columnas es una de mis favoritas (además del explorador cart, "
"y el soporte para el codificador, y otras). Disfruté trabajando con este "
"procedimiento y aprendí unas pocas cosas sobre la api de Windows, así como "
"abrí posibilidades que no se habían explorado antes, como la herramienta de "
"pista o la búsqueda por columnas. Espero que encuentres útiles las órdenes "
"de navegación por columnas en tus emisiones."

#: ..\python_docs\spladdoninternals.py:417
msgid ""
"I would like to take this time to answer a question posed by some users and "
"developers: Can NVDA be ported to other operating systems? No. The above "
"column retriever routine is a prime example why this cannot be done easily: "
"different operating systems use different API's, and porting NonVisual "
"Desktop Access to other operating systems will involve significant "
"architectural changes to use the new API's. In case of ReactOS, this isn't "
"possible, as there are no stable foundation from which NVDA screen reader "
"can exercise its full rights: accessibility API's are needed, stable driver "
"development framework is needed, ability to run a program as a service must "
"be ready and so on. Add to the fact that we have several add-ons relying on "
"Windows API (including this add-on) and you'll see the huge work involved in "
"an attempt to port NVDA to other operating systems."
msgstr ""
"Me gustaría aprovechar para responder una pregunta realizada por algunos "
"usuarios y desarrolladores: ¿puede llevarse NVDA a otros sistemas "
"operativos? No. El procedimiento de recuperación de columnas de arriba es un "
"buen ejemplo de por qué no puede hacerse esto fácilmente: los diferentes "
"sistemas operativos usan apis distintas, y llevar NVDA a otros sistemas "
"operativos implicaría cambios significativos de la arquitectura para usar "
"las nuevas apis. En el caso de ReactOS, no es posible, ya que no hay una "
"base estable sobre la que NVDA pueda ejercer completamente todos sus "
"derechos: hacen falta apis de accesibilidad, hace falta un marco de trabajo "
"estable para el desarrollo de controladores, debe estar lista la capacidad "
"de ejecutar un programa como servicio y muchas otras cosas. A eso añadimos "
"el hecho de que tenemos varios complementos que se apoyan en la api de "
"Windows (incluyendo este). Te imaginarás el enorme trabajo que implica "
"intentar llevar NVDA a otros sistemas operativos."

#: ..\python_docs\spladdoninternals.py:418
msgid "## Microphone alarm and library scan: threads, threads and more threads"
msgstr ""
"## Alarma del micrófono y escaneo de biblioteca: hilos, hilos y más hilos"

#: ..\python_docs\spladdoninternals.py:419
msgid ""
"Of all the work done on this add-on, one of them stands out the most: "
"background tasks. I spent many hours and months perfecting this concept, "
"read documentation on this feature and learned a lot through this "
"experience. Today, this work is used in various parts of the Studio app "
"module and beyond, and we'll take a look at two most important results of "
"this work: library scan and microphone alarm."
msgstr ""
"De todos los trabajos hechos en este complemento, uno de ellos destaca sobre "
"los demás: las tareas en segundo plano. Invertí muchas horas y meses "
"perfeccionando este concepto, leí documentación sobre esta característica y "
"aprendí un montón a través de esta experiencia. Hoy, se emplea este trabajo "
"en diversas partes del módulo de aplicación de Studio y más allá, y "
"echaremos un vistazo a dos resultados de los más importantes de este "
"trabajo: el escaneo de biblioteca y la alarma del micrófono."

#: ..\python_docs\spladdoninternals.py:420
msgid "### Brief feature overview"
msgstr "### Breve descripción de las características"

#: ..\python_docs\spladdoninternals.py:421
msgid ""
"When you are producing a live show, you may forget that your microphone is "
"active. The microphone alarm feature lets NVDA notify you if microphone has "
"been active for a while. This happens even if you are using another program."
msgstr ""
"Cuando estás haciendo un programa en directo, puedes olvidarte de que el "
"micrófono está activo. La característica de alarma de micrófono hace que "
"NVDA pueda notificarte si el micrófono ha estado activado durante un rato. "
"Esto sucede incluso si estás utilizando otro programa."

#: ..\python_docs\spladdoninternals.py:422
msgid ""
"Library scan comes in handy when you want to see the progress of a "
"background library scan. Typically, you would initiate library scans from "
"Insert Tracks dialog (press Control+Shift+R). NVDA will then tell you how "
"the scan is going, and if you close Insert Tracks dialog, NVDA will continue "
"to monitor library scans in the background."
msgstr ""
"El escaneo de biblioteca viene bien cuando quieres ver el progreso de un "
"escaneo de biblioteca en segundo plano. Normalmente, iniciarías los escaneos "
"de biblioteca desde el diálogo de inserción de pistas (pulsa ctrl+shift+r). "
"NVDA te dirá entonces cómo va el escaneo, y si cierras el diálogo de "
"inserción de pistas, NVDA continuará monitorizando el escaneo de la "
"biblioteca en segundo plano."

#: ..\python_docs\spladdoninternals.py:423
msgid ""
"But there's more to it than a simple description when it comes to looking at "
"internals of these features. As you'll see, these features use a concept "
"that is gaining traction: running multiple tasks at once, or at least try to "
"emulate it. We'll visit this concept first before returning to our regularly "
"scheduled program of describing the internals of the two features above."
msgstr ""
"Pero hay mucho más que una simple descripción cuando llega el momento de "
"mirar en el interior de estas características. Como verás, estas funciones "
"usan un concepto que está ganando fuerza: ejecutar múltiples tareas a la "
"vez, o al menos intentar emularlo. Visitaremos este concepto primero antes "
"de volver a nuestro programa original de describir el interior de las dos "
"características de arriba."

#: ..\python_docs\spladdoninternals.py:424
msgid ""
"### Recent trends in computing: more and more processors in a single computer"
msgstr ""
"### Tendencias recientes en computación: más y más procesadores en un único "
"ordenador"

#: ..\python_docs\spladdoninternals.py:425
msgid ""
"Years ago, people thought a single core CPU was enough to run multiple "
"programs. This involved the processor spending small fraction of a second "
"devoted to each program. Nowadays, it has become common to see desktops, "
"laptops, smartphones and other small devices using at least two cores "
"(termed multi-core; two cores is dubbed \"dual core\"). As of 2020, many "
"computers use processors with four cores (dubbed \"quad core\"), while "
"enthusiasts prefer more cores (it is common nowadays to see PC's and servers "
"boasting upwards of ten cores or more)."
msgstr ""
"Hace años, la gente pensaba que una CPU de un único núcleo era suficiente "
"para ejecutar múltiples programas. Esto implicaba que el procesador invertía "
"una pequeña fracción de segundo exclusivamente a cada programa. Hoy en día, "
"es común ver ordenadores de sobremesa, portátiles, smartphones y otros "
"pequeños dispositivos que tienen al menos dos núcleos (llamados multi-core; "
"con dos núcleos se llama \"dual core\"). En 2020, muchos ordenadores "
"disponen de procesadores con cuatro núcleos (llamados \"quad core\"), "
"mientras que los entusiastas prefieren más núcleos (es común hoy en día ver "
"ordenadores y servidores que tienen diez núcleos o más)."

#: ..\python_docs\spladdoninternals.py:426
msgid ""
"Despite the fact that many computers come equipped with multi-core "
"processors, not all programs take advantage of this. Python interpreter is "
"one of those programs, and since NVDA is a Python-based screen reader and "
"due to its operational architecture, many of its operations cannot take "
"advantage of multiple processors. Fortunately, Python provides a way to "
"simulate this - run certain tasks in the background, and this is utilized by "
"NVDA and some of its add-ons as you'll see in this section on library scan "
"and microphone alarm."
msgstr ""
"A pesar del hecho de que muchos ordenadores vienen equipados con "
"procesadores de múltiples núcleos, no todos los programas aprovechan las "
"ventajas de esto. El intérprete Python es uno de esos programas, y ya que "
"NVDA es un lector de pantalla basado en Python y debido a su arquitectura "
"operativa, muchas operaciones no pueden aprovechar la ventaja de tener "
"múltiples procesadores. Por suerte, Python proporciona una manera de simular "
"esto - ejecutar ciertas tareas en segundo plano, que tanto NVDA como algunos "
"complementos utilizan como podrás comprobar en este artículo sobre el "
"escaneo de la biblioteca y la alarma del micrófono."

#: ..\python_docs\spladdoninternals.py:427
msgid "### A gentle introduction to threads: multiple tasks at once"
msgstr "### Una introducción suave a los hilos: varias tareas a la vez"

#: ..\python_docs\spladdoninternals.py:428
msgid ""
"During normal business hours, a program will run from beginning to end with "
"some interuptions (keyboard input, switching to a different part of the "
"program and so on). However, there are times when the program will need to "
"work with many things simultaneously, such as calculating distance between "
"many points, adding multiple numbers at once, comparing many pairs of "
"strings and so on. Fortunately, a mechanism called threads allow a program "
"to do multiple things simultaneously."
msgstr ""
"Durante las horas laborables, un programa se ejecutará de principio a fin "
"con algunas interrupciones (entrada por teclado, cambiar a una zona "
"diferente del programa y demás). Sin embargo, hay veces en las que el "
"programa necesitará trabajar con muchas cosas simultáneamente, como calcular "
"la distancia entre muchos puntos, sumar varios números a la vez, comparar "
"muchos pares de cadenas y demás. Por suerte, un mecanismo llamado hilos "
"permite que un programa haga muchas cosas simultáneamente."

#: ..\python_docs\spladdoninternals.py:429
msgid ""
"A thread is a procedure independent of other tasks. If one thread is busy "
"with something, other threads can work on other tasks. The best analogy is "
"multiple bank tellers in a bank: customers can talk to different tellers, "
"with one teller working on updating customer records for a customer while "
"another customer discusses fraudulent credit card charges with a different "
"teller."
msgstr ""
"Un hilo es un procedimiento independiente de otras tareas. Si un hilo está "
"ocupado con algo, otros hilos pueden trabajar en otras tareas. La mejor "
"analogía es varios banqueros en un banco: los clientes pueden hablar con "
"diferentes banqueros, con un banquero actualizando los registros de un "
"cliente mientras otro cliente discute sobre cargos en la tarjeta de crédito "
"fraudulentos con otro banquero."

#: ..\python_docs\spladdoninternals.py:430
msgid ""
"A thread can be involved with parts of a task, devoted to a single task or "
"multiple tasks. For example, an antivirus program could have multiple "
"threads (workers) working independently of each other. One worker can "
"display the overall progress of a scan, while other threads can scan "
"multiple drives at once, with each thread devoted to scanning files and "
"folders on separate drives. In NVDA world, multiple workers are involved to "
"perform various tasks, including making sure NVDA is responsive, handling "
"browse mode in different web browsers and so on."
msgstr ""
"Un hilo puede implicarse en partes de una tarea, dedicarse a una tarea única "
"o varias tareas. Por ejemplo, un programa antivirus podría tener varios "
"hilos (trabajadores) trabajando independientemente unos de otros. Un "
"trabajador puede mostrar el progreso general de un análisis, mientras que "
"otros hilos pueden analizar varias unidades a la vez, donde cada hilo se "
"dedica a analizar exclusivamente los archivos y carpetas de una unidad. En "
"el mundo de NVDA, varios trabajadores están implicados en llevar a cabo "
"diversas tareas, incluyendo asegurarse de que NVDA está adaptado, procesar "
"el modo exploración en distintos navegadores web y demás."

#: ..\python_docs\spladdoninternals.py:431
msgid "### Threads: a more geeky introduction"
msgstr "### Hilos: una introducción más jeek"

#: ..\python_docs\spladdoninternals.py:432
msgid ""
"A thread (sometimes termed \"thread of execution) is an independent path of "
"execution. A single process (app) can have as many threads as it desires "
"(minimum is one for the main thread). Each thread can be asked to perform "
"certain operations with other threads in parallel, which can range from a "
"single, repetitive task (part of a function) to being responsible for an "
"entire module or a significant part of the program. In case of antivirus "
"example above, each scanner thread is responsible for scanning an entire "
"drive, with each of them reporting its progress to a manager thread which "
"displays overall progress of a virus scan."
msgstr ""
"Un hilo (a veces llamado \"hilo de ejecución\") es un camino independiente "
"de ejecución. Un único proceso (aplicación) puede tener tantos hilos como "
"desee (el mínimo es uno para el hilo principal). Se puede pedir a cada hilo "
"que haga ciertas operaciones con otros hilos en paralelo, que pueden variar "
"desde una única tarea repetitiva (parte de una función) hasta ser "
"responsables de un módulo entero o una parte significativa del programa. En "
"el ejemplo anterior del antivirus, cada hilo del analizador es responsable "
"de analizar una unidad entera, y cada uno informa su progreso a un hilo "
"administrador que muestra el progreso total del análisis de virus."

#: ..\python_docs\spladdoninternals.py:433
msgid ""
"Using threads means each thread can execute on a processor core on a multi-"
"core system. Because of this, many people would want many programs to take "
"advantage of this and finish their jobs faster. However, threads introduce "
"disadvantages, namely many days spent designing careful coordination "
"routines between threads, preventing attempts by multiple threads to change "
"a critical value that a manager thread depends on (called race condition) "
"and so forth."
msgstr ""
"Usar hilos significa que cada hilo puede ejecutarse en un núcleo del "
"procesador en un sistema multinúcleo. Por este motivo, mucha gente querría "
"que muchos programas aprovecharan las ventajas de esta tecnología y "
"finalizaran sus trabajos más rápido. Sin embargo, los hilos presentan "
"desventajas, normalmente muchos días invertidos en diseñar cuidadosamente "
"procedimientos de coordinación entre hilos, evitar intentos de múltiples "
"hilos para que no intenten cambiar un valor crítico del que depende un hilo "
"gestor (fallo conocido como condición de carrera) y demás."

#: ..\python_docs\spladdoninternals.py:434
msgid "### Python's way of managing threads and the threading module"
msgstr ""
"### El módulo threading y la forma que tiene Python de gestionar los hilos"

#: ..\python_docs\spladdoninternals.py:435
msgid ""
"Python interpreter (and programs which uses them, including NVDA) is not "
"exactly multithreaded. Because of internal issues, Python uses so-called "
"global interpreter lock to prevent multiple threads from messing with each "
"other. One way to bring true parallelism in Python is use of multiprocessing "
"module (multiple Python interpreters, each one devoted to a single task), "
"which has its own advantages and drawbacks (NVDA does not ship with "
"multiprocessing module in the first place)."
msgstr ""
"El intérprete Python (y los programas que lo usan, incluido NVDA) no es "
"exactamente multihilo. Debido a problemas internos, Python usa algo llamado "
"bloqueo global del intérprete para evitar que varios hilos tengan conflictos "
"entre sí. Una forma de traer el paralelismo real a Python es usar el módulo "
"multiprocessing (varios intérpretes Python, cada uno dedicado a una tarea), "
"que tiene sus propias ventajas y desventajas (la primera, que NVDA no viene "
"con el módulo multiprocessing integrado)."

#: ..\python_docs\spladdoninternals.py:436
msgid ""
"To manage threads, Python programs (including NVDA) use Python's threading "
"module. This library includes various ways of managing threads, including "
"defining which function can execute in a separate thread, coordinating "
"sharing of information between threads (locks, semaphores (resource access "
"counter) and so on), and letting a thread run its task after waiting for a "
"while (called timers). Even with multiple threads defined, NVDA is mostly "
"single-threaded (serial execution)."
msgstr ""
"Para gestionar hilos, los programas en Python (incluido NVDA) usan el módulo "
"threading de Python. Esta biblioteca incluye varias formas de gestionar "
"hilos, incluida la de definir qué función se ejecutará en un hilo separado, "
"coordinación de la información compartida entre hilos (cerrojos, semáforos "
"(contador de accesos al recurso) y demás), y dejar que un hilo ejecute su "
"tarea tras esperar un rato (temporizadores). Incluso con varios hilos "
"definidos, NVDA es mayoritariamente de un solo hilo (ejecución en serie)."

#: ..\python_docs\spladdoninternals.py:437
msgid ""
"To use threads, a programmer will define the thread type (regular thread, "
"timer and so on), define some properties and tell the thread which routine "
"to execute. Once the thread is defined, the start (thread.start) method is "
"called to let the thread do its work."
msgstr ""
"Para usar hilos, un programador definirá el tipo de hilo (hilo regular, "
"temporizador y demás), definirá algunas propiedades e indicará al hilo qué "
"procedimiento debe ejecutar. Una vez el hilo está definido, se llama al "
"método de inicio (thread.start) para hacer que el hilo haga su trabajo."

#: ..\python_docs\spladdoninternals.py:438
msgid "### Threads in Studio app module"
msgstr "### Hilos en el módulo de aplicación de Studio"

#: ..\python_docs\spladdoninternals.py:439
msgid ""
"For the most part, Studio app module uses only one thread (NVDA's main "
"thread) to do its job. However, there are times when multiple threads are "
"used - up to three can be active at a time: NVDA's main thread (announcing "
"status changes, alarms, Cart Explorer and others), microphone alarm (a "
"timer) and library scan (a background thread). Another situation threads are "
"used is when background encoder monitoring is enabled (see the encoder "
"routines section for details and use of threads there)."
msgstr ""
"La mayoría del módulo de aplicación de Studio usa sólo un hilo (el hilo "
"principal de NVDA) para hacer su trabajo. Sin embargo, hay veces en que se "
"usan varios hilos - puede haber hasta tres hilos activos al mismo tiempo: el "
"hilo principal de NVDA (anunciando cambios de estado, alarmas, explorador "
"cart y otras funciones), la alarma del micrófono (un temporizador) y el "
"escaneo de biblioteca (un hilo en segundo plano). Otra situación en la que "
"se usan hilos es cuando está activada la monitorización en segundo plano del "
"codificador (mira el artículo de procedimientos del codificador para más "
"detalles y uso de hilos allí)."

#: ..\python_docs\spladdoninternals.py:440
msgid ""
"The main reason for using threads is to prevent background tasks from "
"blocking user input (commands will not work when a long running task is run "
"from the main NVDA thread). This is more noticeable when library scan is "
"active as you'll find out soon. For now, let's take a look at microphone "
"alarm."
msgstr ""
"El motivo principal para usar hilos es evitar que las tareas en segundo "
"plano bloqueen la entrada de usuario (las órdenes no funcionarán cuando una "
"tarea que tarda mucho en ejecutarse lo haga desde el hilo principal de "
"NVDA). Esto es más perceptible cuando el escaneo de biblioteca está activo, "
"como podrás comprobar pronto. Por ahora, echemos un vistazo a la alarma del "
"micrófono."

#: ..\python_docs\spladdoninternals.py:441
msgid "#### Microphone alarm: A timer duo waiting to do their work"
msgstr ""
"#### Alarma del micrófono: un dúo de temporizadores esperando para hacer su "
"trabajo"

#: ..\python_docs\spladdoninternals.py:442
msgid ""
"Simply put, microphone alarm is a timer (akin to a countdown timer). When "
"the microphone becomes active, Studio app module will tell a timer thread to "
"come alive. This timer's only job is to play the alarm sound and display a "
"warning message, and it will wait a while (microphone alarm value in "
"seconds; for example, five seconds)."
msgstr ""
"En pocas palabras, la alarma de micrófono es un temporizador (un "
"temporizador de cuenta atrás). Cuando el micrófono se pone activo, el módulo "
"de aplicación de Studio hará que un hilo temporizador venga a la vida. La "
"única misión de este temporizador es reproducir el sonido de alarma y "
"mostrar un mensaje de aviso, y esperará un rato (valor de la alarma del "
"micrófono en segundos; por ejemplo, cinco segundos)."

#: ..\python_docs\spladdoninternals.py:443
msgid "The master switch which flips the microphone alarm timer is:"
msgstr ""
"El interruptor maestro que hace girar al temporizador de la alarma del "
"micrófono es:"

#: ..\python_docs\spladdoninternals.py:444
msgid ""
"alarm = threading.Timer(micAlarm, messageSound, args=[micAlarmWav, "
"micAlarmMessage])"
msgstr ""
"alarm = threading.Timer(micAlarm, messageSound, args=[micAlarmWav, "
"micAlarmMessage])"

#: ..\python_docs\spladdoninternals.py:445
msgid ""
"Where \"micAlarm\" denotes how long this timer will wait and the second "
"argument is the task to be performed (messageSound function). If microphone "
"alarm is off (value is 0), this switch will be left alone forever (turned "
"off until you enable the alarm by specifying a value above 0)."
msgstr ""
"Donde \"micAlarm\" indica cuánto tiempo esperará el temporizador y el "
"segundo argumento es la tarea a realizar (función messageSound). Si la "
"alarma del micrófono está apagada (su valor es 0), este interruptor quedará "
"solo para siempre (apagado hasta que actives la alarma especificando un "
"valor superior a 0)."

#: ..\python_docs\spladdoninternals.py:446
msgid ""
"However, microphone alarm is more than a timer: a unique feature of timers "
"is responding to events (a cancel event, that is). When the microphone "
"becomes active, microphone alarm timer will become active. If you happen to "
"turn off your microphone before microphone alarm kicks in, NVDA instructs "
"microphone alarm to quit (timer is canceled). In other words, the \"real\" "
"master switch is status change, and one of the activities performed by name "
"change event handler (event_nameChange function described earlier) is to "
"manage microphone alarm timer via doExtraAction method (in fact, microphone "
"alarm and Cart Explorer are managed from this function)."
msgstr ""
"Sin embargo, la alarma del micrófono es más que un temporizador: una función "
"única de los temporizadores es responder a eventos (un evento de "
"cancelación). Cuando el micrófono se activa, el temporizador de la alarma "
"del micrófono se activará con él. Si apagas el micrófono antes de que la "
"alarma del micrófono salte, NVDA ordena a la alarma del micrófono que salga "
"(se cancela el temporizador). En otras palabras, el interruptor maestro "
"\"real\" es el cambio de estado, y una de las actividades que el manejador "
"de evento de cambio de nombre (función event_nameChange descrita "
"anteriormente) realiza es la de gestionar el temporizador de la alarma del "
"micrófono mediante el método doExtraAction (de hecho, la alarma del "
"micrófono y el explorador cart se gestionan desde esta función)."

#: ..\python_docs\spladdoninternals.py:447
msgid ""
"In some cases, NVDA can be told to periodically notify you that microphone "
"is active. If this is the case, NVDA will start a new timer (this time, wx."
"PyTimer) that'll run a function to do just that periodically after the "
"initial microphone alarm is sounded. Just like the master microphone alarm "
"timer, this time will quit if microphone is turned off."
msgstr ""
"En algunos casos, podemos decirle a NVDA que nos avise periódicamente de que "
"el micrófono está activo. Si este es el caso, NVDA iniciará un nuevo "
"temporizador (esta vez, wx.PyTimer) que ejecutará una función para hacerlo "
"periódicamente después de que suene la primera alarma de micrófono. Al igual "
"que con el temporizador maestro de alarma, este temporizador también se "
"detendrá si el micrófono se apaga."

#: ..\python_docs\spladdoninternals.py:448
msgid ""
"#### Library scan: a unique combination of Studio API and a background thread"
msgstr ""
"#### Escaneo de biblioteca: una combinación única de la api de Studio y un "
"hilo en segundo plano"

#: ..\python_docs\spladdoninternals.py:449
msgid ""
"When NVDA is told to keep an eye on background library scanning, it calls up "
"another thread to perform this duty. This thread will ask Studio for number "
"of items scanned so far and take appropriate action after scanning is "
"complete (in fact, multiple helper functions are used)."
msgstr ""
"Al decirle a NVDA que mantenga vigilado el escaneo de biblioteca en segundo "
"plano, este llama a otro hilo para hacer esta tarea. Este hilo le preguntará "
"a Studio por el número de elementos escaneados hasta ahora y tomará las "
"medidas adecuadas en cuanto el escaneo se complete (de hecho, se usan varias "
"funciones auxiliares)."

#: ..\python_docs\spladdoninternals.py:450
msgid "The library scan routine is performed as follows:"
msgstr "El procedimiento de escaneo de biblioteca es el siguiente:"

#: ..\python_docs\spladdoninternals.py:451
msgid ""
"1. NVDA will make sure you are not in Insert Tracks dialog (if you are, "
"background library scan routine will not be invoked, as event_nameChange "
"will perform this duty instead)."
msgstr ""
"1. NVDA se asegurará de que no estés en el diálogo de inserción de pistas "
"(si estás ahí, no se invocará el procedimiento de escaneo de la biblioteca "
"en segundo plano, ya que event_nameChange hará lo mismo en su lugar)."

#: ..\python_docs\spladdoninternals.py:452
msgid ""
"2. If you do close Insert Tracks while a scan is in progress, or invoke "
"library scan from SPL Assistant (Shift+R), NVDA will instruct a thread to "
"keep an eye on scan progress in the background(see below for signature) to "
"allow you to use Studio commands and to let you hear scan progress from "
"other programs."
msgstr ""
"2. Si cierras el diálogo de insertar pistas mientras hay un escaneo en "
"progreso, o invocas el escaneo de biblioteca desde el asistente de SPL (shift"
"+r), NVDA ordenará que un hilo vigile el progreso del escaneo en segundo "
"plano (mira abajo la cabecera) para permitirte usar órdenes de Studio y "
"dejarte oír el progreso del escaneo desde otros programas."

#: ..\python_docs\spladdoninternals.py:453
msgid ""
"3. Library scan thread will ask Studio to return number of items scanned "
"(this is done every second) and will store the result for record keeping."
msgstr ""
"3. El hilo de escaneo de biblioteca pedirá a Studio que le devuelva el "
"número de elementos escaneados (lo hace cada segundo) y almacenará el "
"resultado para llevar un registro."

#: ..\python_docs\spladdoninternals.py:454
msgid ""
"4. After the scan result is obtained, the thread will check where you are in "
"studio, and if you are back in Insert Tracks dialog, the thread will "
"terminate (see step 1)."
msgstr ""
"4. Después de obtener el resultado del escaneo, el hilo comprobará en qué "
"parte de Studio estás, y si te encuentras de vuelta en el diálogo de "
"inserción de pistas, el hilo finalizará (mira el paso 1)."

#: ..\python_docs\spladdoninternals.py:455
msgid ""
"5. Every five seconds, library scan thread will call a private function "
"(which wants to see how many items were scanned and current library scan "
"announcement setting) to announce library scan results as follows:"
msgstr ""
"5. Cada cinco segundos, el hilo de escaneo de biblioteca llamará a una "
"función privada (que quiere ver cuántos elementos se han escaneado y el "
"ajuste actual de verbalización de escaneo de biblioteca) para anunciar los "
"resultados del escaneo de la biblioteca de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:456
msgid ""
"\t* If you tell NVDA to announce scan progress, NVDA will say, \"scanning\" "
"and/or play a beep (if told to do so)."
msgstr ""
"\t* Si le pides a NVDA que verbalice el progreso del escaneo, este dirá "
"\"Escaneando\" y / o reproducirá un pitido (si así lo tiene indicado)."

#: ..\python_docs\spladdoninternals.py:457
msgid ""
"\t* If NVDA is told to announce scan count, number of items scanned so far "
"will be announced (again with or without a beep)."
msgstr ""
"\t* Si se pide a NVDA que verbalice la cantidad de elementos escaneados, se "
"verbalizarán los que se han analizado hasta ahora (otra vez con o sin "
"pitido)."

#: ..\python_docs\spladdoninternals.py:458
msgid ""
"\t* This reporter function will not be invoked if you tell NVDA to ignore "
"library scan completely or ask it to interupt you only when the overall scan "
"is complete (you can press Alt+NVDA+R to cycle through different library "
"scan announcement settings)."
msgstr ""
"\t* No se invocará a esta función informadora si le dices a NVDA que ignore "
"el escaneo de biblioteca completamente o le pides que te interrumpa sólo "
"cuando el escaneo general se haya completado (puedes pulsar alt+NVDA+r para "
"cambiar rápidamente entre los diferentes ajustes de verbalización de escaneo "
"de biblioteca)."

#: ..\python_docs\spladdoninternals.py:459
msgid ""
"6. Once library scanning is complete (after checking scan result value every "
"second and seeing that the previous scan result and the current one have "
"same values), NVDA will announce scan results (in some cases, number of "
"items scanned will be announced). In Studio 5.10 and later, the library scan "
"counter will not be defined when scan completes, which is more efficient "
"than keeping track of equalities."
msgstr ""
"6. Una vez el escaneo de la biblioteca se completa (después de comprobar el "
"valor del resultado cada segundo y ver que el resultado del escaneo anterior "
"y el actual tienen el mismo valor), NVDA verbalizará los resultados del "
"escaneo (en algunos casos, se verbalizará el número de elementos "
"escaneados). En Studio 5.10 y versiones posteriores, el contador del escaneo "
"de la biblioteca no estará definido cuando el escaneo se complete, lo que es "
"más eficiente que ir comparando."

#: ..\python_docs\spladdoninternals.py:460
msgid ""
"You can imagine what would have happened if the above operation was not a "
"background task: cannot perform other NVDA commands until library scan is "
"complete, cannot cancel this operation and what not. And this is the "
"signature of the thread that performs the above operation:"
msgstr ""
"Te puedes imaginar qué habría pasado si la operación anterior no fuese una "
"tarea en segundo plano: no se podrían ejecutar otras órdenes de NVDA hasta "
"que se completara el escaneo de biblioteca y no se podría cancelar la "
"operación. Esta es la cabecera del hilo que realiza la operación de arriba:"

#: ..\python_docs\spladdoninternals.py:461
msgid ""
"libraryScanner = threading.Thread(target=self.libraryScanReporter, "
"args=(_SPLWin, countA, countB, parem))"
msgstr ""
"libraryScanner = threading.Thread(target=self.libraryScanReporter, "
"args=(_SPLWin, countA, countB, param))"

#: ..\python_docs\spladdoninternals.py:462
msgid ""
"There are important arguments in use: the function (task) to be performed "
"and arguments for this function. The most important argument is the last "
"one: Studio 5.0x and 5.10 expects different arguments when told to report "
"number of items scanned so far."
msgstr ""
"Hay argumentos importantes en uso: la función (tarea) a realizar y los "
"argumentos para esta función. El argumento más importante es el último: "
"Studio 5.0x y 5.10 esperan argumentos diferentes cuando se les pide que "
"informen de los elementos escaneados hasta el momento."

#: ..\python_docs\spladdoninternals.py:463
msgid ""
"Despite limitations of Python's threading routines, if used properly, it can "
"open new possibilities, and you saw some of them above: microphone alarm and "
"background library scan. Use of threads in the Studio app module also allows "
"NVDA to be responsive while using Studio and allows background tasks to be "
"faithful to the tasks at hand. We'll come back to threads when we talk about "
"encoder connection routines. There is a more \"magical\" feature we'll "
"visit, and this is our next stop on the Add-on Internals: Cart Explorer."
msgstr ""
"A pesar de las limitaciones de los procedimientos de Python para hilos, si "
"se usan adecuadamente, pueden abrir nuevas posibilidades como las que has "
"visto arriba: la alarma del micrófono y el escaneo de la biblioteca en "
"segundo plano. El uso de hilos en el módulo de aplicación de Studio también "
"permite que NVDA sea rápido mientras se utilice Studio y permite que las "
"tareas en segundo plano sean fieles a la tarea que se desempeña a mano. "
"Volveremos a los hilos cuando hablemos de los procedimientos de conexión del "
"codificador. Hay una característica más \"mágica\" que visitaremos, y es "
"nuestra siguiente parada en el recorrido por el interior del complemento: el "
"explorador cart."

#: ..\python_docs\spladdoninternals.py:464
msgid "## The magic behind Cart Explorer"
msgstr "## La magia que hay tras el explorador cart"

#: ..\python_docs\spladdoninternals.py:465
msgid ""
"A live radio broadcast would not be complete without jingles. This can range "
"from station promotions (often called \"promos\"), advertisements, jingles "
"to convey the mood of a show, segment jingles and more. Many station "
"automation programs, including StationPlaylist Studio includes facilities to "
"manage jingles (sometimes called carts), including defining a cart to be "
"played when cart keys are pressed, announcing the name of the playing cart "
"and saving specific carts to a safe location."
msgstr ""
"Una emisión de radio en directo no estaría completa sin jingles. Estos "
"pueden ir desde promociones de radio (a veces llamadas \"promos\"), "
"anuncios, jingles para transmitir el estado de ánimo en un programa, jingles "
"de segmento y más. Muchos programas de automatización de emisoras, incluido "
"StationPlaylist Studio, incluyen formas de gestionar jingles (a veces "
"llamados carts), incluyendo la definición de un cart para que sea "
"reproducido al pulsar las teclas de cart, verbalizar el nombre del cart en "
"reproducción y guardar nuestros carts específicos en una ubicación segura."

#: ..\python_docs\spladdoninternals.py:466
msgid ""
"For blind broadcasters, one of the things they worry is pressing a wrong "
"jingle key by accident, thus script writers were asked to implement a way "
"for broadcasters to learn which carts are assigned to cart keys. As of time "
"of this post, all three screen readers (JAWS for Windows (script author: "
"Brian Hartgen), Window-Eyes (script author: Jeff Bishop), NVDA (script "
"author: Joseph Lee (I, the author of this article)) includes a feature to "
"learn jingle assignments. As this is an article on internals of an NVDA add-"
"on, I'll give you an overview of what happens when you activate and explore "
"cart assignments (in fact, this section was the most interesting and "
"feedback driven portion of the add-on). Along the way you'll learn where "
"Cart Explorer (NVDA's version of cart learn mode) draws its power and why it "
"is very important."
msgstr ""
"Una de las cosas que preocupa a los locutores ciegos es pulsar una tecla de "
"jingle incorrecta por accidente, por lo que se pidió a los desarrolladores "
"de scripts que implementaran una forma para que los locutores aprendieran "
"qué carts están asignados a las teclas cart. En el momento en que escribo "
"este artículo, los tres lectores de pantalla (JAWS for Windows (autor de los "
"scripts: Brian Hartgen), Window Eyes (autor de los scripts: Jeff Bishop) y "
"NVDA (autor de los scripts: Joseph Lee (yo, el autor de este artículo)) "
"incluyen una función para aprender las asignaciones de jingles. Como esta es "
"una serie de artículos sobre el interior de un complemento de NVDA, te daré "
"una descripción de lo que pasa cuando activas y exploras las asignaciones "
"cart (de hecho, esta sección fue la porción más interesante y dirigida por "
"comentarios del complemento). A lo largo del camino aprenderás de dónde coge "
"su poder el explorador cart (la versión de NVDA del modo de aprendizaje de "
"cart) y por qué es muy importante."

#: ..\python_docs\spladdoninternals.py:467
msgid "### Carts in StationPlaylist Studio"
msgstr "### Carts en StationPlaylist Studio"

#: ..\python_docs\spladdoninternals.py:468
msgid ""
"Studio comes in three editions: Demo (same as Pro but for limited time "
"trial), Standard and Pro. The first user visible difference between Standard "
"and Pro is number of cart assignments: Standard can store 48 jingles, while "
"Pro can work with 96 of them."
msgstr ""
"Studio viene en tres ediciones: Demo (igual que la Pro pero funcionando "
"durante un tiempo limitado de prueba), Standard y Pro. La primera diferencia "
"visible para el usuario entre Standard y Pro es la cantidad de asignaciones "
"de cart: la Standard puede almacenar 48 jingles, mientras que la Pro puede "
"trabajar con 96 de ellos."

#: ..\python_docs\spladdoninternals.py:469
msgid ""
"To play jingles, a broadcaster would use Cart Edit Mode Control+T), then "
"assign a hotkey to a file. For Studio Standard, you can assign F1 through "
"F12 by themselves or in combination with Control, Shift or Alt. In Demo and "
"Pro, number row can be assigned (1 through 9, 0, hyphen (-) and equals (=) "
"either by themselves or in combination with Control, Shift or Alt, for a "
"grand total of 96 jingles). Once jingles are assigned, they will appear "
"under cart menus (there are four cart menus, one for standalone keys (called "
"main) and one each for Control, Shift and Alt)."
msgstr ""
"Para reproducir jingles, un locutor usaría el modo de edición de cart (ctrl"
"+t), y a continuación asignaría una tecla rápida a un archivo. En Studio "
"Standard, puedes asignar de f1 a f12 por sí mismas o en combinación con "
"ctrl, shift o alt. En Demo y Pro, puede asignarse la fila de números (del 1 "
"al 9, el 0, el guión (-), y el igual (=) bien por sí solos o en combinación "
"con ctrl, shift o alt, para llegar al total de 96 jingles). Una vez los "
"jingles están asignados, aparecerán en los menús de cart (hay cuatro menús "
"de cart, uno para teclas independientes (llamado principal) y uno para "
"control, otro para shift y otro para alt)."

#: ..\python_docs\spladdoninternals.py:470
msgid "### Where does Studio store carts?"
msgstr "### ¿Dónde almacena Studio los carts?"

#: ..\python_docs\spladdoninternals.py:471
msgid ""
"Studio's \"carts\" are housed in Studio installation folder. There are four "
"cart files (called banks) in use: a .cart file for each of the cart banks "
"(main, Shift, Control, Alt). During normal business hours, Studio will work "
"with these four banks unless told by a broadcaster to load carts from a "
"different cart bank file."
msgstr ""
"Los \"carts\" de Studio se alojan en la carpeta de instalación de Studio. "
"Hay cuatro archivos de cart (llamados bancos) en uso: un archivo .cart por "
"cada uno de los bancos de carts (principal, shift, control, alt). Durante "
"las horas laborables, Studio funcionará con estos cuatro bancos a menos que "
"un locutor cargue otros carts desde un archivo de banco de carts diferente."

#: ..\python_docs\spladdoninternals.py:472
msgid "### Cart Explorer: my own Summer of Code"
msgstr "### Explorador cart: mi propio verano de código"

#: ..\python_docs\spladdoninternals.py:473
msgid ""
"It was a hot day in June 2014 when I sat down to design a way to let "
"broadcasters learn cart assignments. Since I was developing add-on 3.0 back "
"then, I decided that this feature should be a top priority feature to be "
"included in the upcoming release."
msgstr ""
"Era un día caluroso en junio de 2014 cuando me senté a diseñar una forma de "
"que los locutores aprendieran las asignaciones cart. Ya que estaba "
"desarrollando el complemento 3.0 por entonces, decidí que esta "
"característica debería tener la prioridad más alta para incluirla en la "
"liberación que estaba por llegar."

#: ..\python_docs\spladdoninternals.py:474
msgid ""
"When I started writing this feature, the first thing I thought about was its "
"name. I felt \"cart learn mode\" didn't really convey the picture - after "
"all, I reasoned that broadcasters will use this feature to explore cart "
"assignments. Thus the name \"Cart Explorer\" was chosen - in effect, when "
"you use this feature, you are browsing jingle assignments in preparation for "
"a show."
msgstr ""
"Cuando empecé a escribir esta característica, la primera cosa en la que "
"pensé fue su nombre. Yo sentía que \"Modo de aprendizaje de cart\" no "
"representaba adecuadamente el cuadro - después de todo, razoné que los "
"locutores usarán esta característica para explorar las asignaciones de cart. "
"Por tanto, elegí el nombre \"Explorador cart\" - en efecto, cuando usas esta "
"característica, estás explorando las asignaciones de jingles para prepararte "
"para un programa."

#: ..\python_docs\spladdoninternals.py:475
msgid ""
"Next, I read JAWS script documentation to get a glimpse of how Brian has "
"managed to implement cart learn mode. In JAWS scripts, script settings are "
"stored in the user configuration directory (typically this is %systemdrive%"
"\\Users\\%username%\\AppData\\Roaming\\Freedom Scientific\\JAWS\\%JAWSVersion"
"%\\Settings\\Enu; Brian, please correct me if I'm wrong). A section of this "
"script configuration file is dedicated to carts, and JAWS scripts use a map "
"of key names and cart values to announce cart information while cart learn "
"mode is active."
msgstr ""
"Después, leí la documentación de los scripts de Jaws para hacerme una idea "
"de cómo implementó Bryan el modo de aprendizaje de cart. En los scripts de "
"Jaws, los ajustes de cada script se alojan en la carpeta de configuración "
"del usuario (normalmente esta es %systemdrive%\\Users\\%username%\\AppDate"
"\\Roaming\\Freedom Scientific\\JAWS\\%JAWSVersion%\\Settings\\Esn; Bryan, "
"corrígeme por favor si me equivoco). Una sección de este archivo de "
"configuración del script está dedicada a los carts, y Jaws usa un mapa de "
"nombres de clave y valores de cart para anunciar la información del cart "
"mientras el modo de aprendizaje de carts esté activo."

#: ..\python_docs\spladdoninternals.py:476
msgid ""
"Based on this information, I started writing an ini file parser, seeing that "
"broadcasters would store cart assignments in a configuration database. This "
"was prone to a number of errors, including wrong cart name format, "
"nonexistent cart key assignment, invalid configuration format and others. I "
"once wrote a blog post (on my personal blog) explaining how this worked "
"(times have changed, as you'll see very soon)."
msgstr ""
"Basándome en esta información, comencé a escribir un intérprete de archivos "
"ini, viendo que los locutores almacenarían las asignaciones de cart en una "
"base de datos de configuración. Este estaba sujeto a un gran número de "
"errores, incluidos el formato equivocado del nombre del cart, asignación de "
"clave de cart no existente, formato de configuración no válido y otros. Una "
"vez escribí una entrada de blog (en mi blog personal) explicando cómo "
"funcionaba (los tiempos han cambiado, como verás muy pronto)."

#: ..\python_docs\spladdoninternals.py:477
msgid ""
"Then I became curious as to how Studio stores its own cart banks, and "
"naturally, I opened the folder where carts were stored and opened each .cart "
"file in Notepad++ (a very handy text editor). From reading the cart bank "
"format (explained below), I thought it might be useful to write a cart bank "
"file parser. Thus I resumed writing Cart Explorer routines, this time "
"incorporating the cart bank format, not forgetting to handle suttle errors, "
"and this is the routine used in add-on releases up to 5.x (6.0 uses a "
"completely different yet related routine, as you'll see)."
msgstr ""
"Entonces me entró la curiosidad de cómo guarda Studio sus propios bancos "
"cart y, naturalmente, abrí la carpeta donde se almacenaban los carts y abrí "
"cada archivo .cart en Notepad++ (un editor de texto muy útil). Desde que leí "
"el formato del banco cart (explicado debajo), pensé que podría ser útil "
"escribir un intérprete de archivos cart. Por tanto continué escribiendo los "
"procedimientos del explorador cart, en esta ocasión incorporando el formato "
"del banco cart, sin olvidarme de tener en cuenta los errores, y este es el "
"procedimiento que se usa en versiones del complemento posteriores a la 5.x "
"(la 6.0 usa un procedimiento relacionado pero totalmente diferente, como "
"verás)."

#: ..\python_docs\spladdoninternals.py:478
msgid ""
"While writing the first version of Cart Explorer, I realized that this "
"feature needed some real life testing, so I asked a seasoned blind "
"broadcaster to test this feature. We spent a better part of Independence Day "
"writing, debugging and rewriting this routine until we felt satisfied. In "
"the end, our hard work paid off, as you can see in subsequent paragraphs."
msgstr ""
"Mientras escribía la primera versión del explorador cart, me di cuenta de "
"que esta característica necesitaba algunas pruebas en la vida real, por lo "
"que pedí a un locutor ciego profesional que la probara. Invertimos la mejor "
"parte del día de la independencia escribiendo, depurando y reescribiendo "
"este procedimiento hasta que nos sentimos satisfechos. Al final, nuestro "
"duro trabajo fue recompensado, como puedes ver en los siguientes párrafos."

#: ..\python_docs\spladdoninternals.py:479
msgid "### Introducing Cart Explorer version 1"
msgstr "### Presentación del explorador cart versión 1"

#: ..\python_docs\spladdoninternals.py:480
msgid ""
"Cart Explorer version 1, shipped as part of add-on 3.0, worked as follows:"
msgstr ""
"La versión 1 del explorador cart, incorporada en el complemento 3.0, "
"funcionaba de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:481
msgid ""
"1. You press Control+NVDA+3 to activate Cart Explorer. When this happens, "
"NVDA will make sure you are in main playlist viewer, then it will set a flag "
"indicating that Cart Explorer is active."
msgstr ""
"1. Se pulsa NVDA+ctrl+3 para activar el explorador cart. Cuando esto ocurre, "
"NVDA se asegura de que estés en el visor principal de listas de "
"reproducción, y después establece un indicador para informar de que el "
"explorador cart está activo."

#: ..\python_docs\spladdoninternals.py:482
msgid ""
"2. NVDA will then open and parse cart bank files, storing cart assignments "
"in a dictionary of cart keys to cart names. This parser also takes care of "
"some corner cases, including skipping unassigned carts and determining "
"Studio edition in use. Once carts were parsed, NVDA says, \"Entering Cart "
"Explorer\", and if errors occur, NVDA will inform you that it cannot enter "
"Cart Explorer (this happens if the cart bank file doesn't exist)."
msgstr ""
"2. NVDA abre e interpreta los archivos de los bancos cart, almacenando las "
"asignaciones de carts en un diccionario con teclas de cart y nombres de "
"cart. Este intérprete también tiene en cuenta algunos casos excepcionales, "
"incluyendo saltarse los carts no asignados y determinar la edición de Studio "
"en uso. Una vez se interpretan los carts, NVDA dice \"Entrando en el "
"explorador cart\", y si ocurren errores, NVDA te informará de que no puede "
"entrar en el explorador cart (esto pasa si el archivo del banco de carts no "
"existe)."

#: ..\python_docs\spladdoninternals.py:483
msgid ""
"3. While using Cart Explorer, if you press a cart key, NVDA will look up the "
"name of the key in the carts dictionary, and announce the cart name "
"associated with it (if found, otherwise, NVDA says, \"cart unassigned\")."
msgstr ""
"3. Mientras usas el explorador cart, si pulsas una tecla cart, NVDA buscará "
"el nombre de la tecla en el diccionario de carts, y anunciará el nombre del "
"cart asociado con ella (si se encuentra, en cualquier otro caso NVDA dice "
"\"Cart sin asignar\")."

#: ..\python_docs\spladdoninternals.py:484
msgid ""
"4. It so happens that some people will activate Cart Edit Mode to modify "
"cart assignments while in the middle of exploring carts. If this happens, "
"NVDA will remind you (via doExtraAction function used by name change event) "
"that Cart Explorer is active, and when Cart Edit Mode is turned off, NVDA "
"will ask you to reenter Cart Explorer (this was done to parse newly updated "
"cart bank files)."
msgstr ""
"4. A veces algunas personas activan el modo de edición de cart para "
"modificar sus asignaciones mientras explora carts. Si esto pasa, NVDA te "
"recordará (mediante la función doExtraAction usada en el evento de cambio de "
"nombre) que el explorador cart está activo, y cuando el modo de edición de "
"cart se desactive, NVDA te preguntará si quieres volver a entrar en el "
"explorador cart (esto se hizo para interpretar los archivos actualizados de "
"bancos de carts)."

#: ..\python_docs\spladdoninternals.py:485
msgid ""
"5. You press Control+NVDA+3, and NVDA will clear carts dictionary, thereby "
"leaving Cart Explorer."
msgstr ""
"5. Se pulsa ctrl+NVDA+3, y NVDA limpiará el diccionario de carts, dejando el "
"explorador cart después."

#: ..\python_docs\spladdoninternals.py:486
msgid ""
"But there was a major concern with this approach: what if a future version "
"of Studio uses a different cart bank format? Thus, I revisited cart bank "
"files again in July 2015, and this time, I noticed a familiar structure: "
"comma-separated values, and thought about a possibility that a spreadsheet "
"application such as Excel would handle this gracefully. To test my "
"hypothesis, I opened .cart files in Excel, and voila, it presented itself "
"just like any CSV file. Thus I worked on modifying cart parsing routine, "
"this time using Python's CSV module to parse \"cart\" files (cart bank files "
"are really CSV files in disguise). This new routine (described below) made "
"its appearance as part of add-on 6.0."
msgstr ""
"Pero había un gran problema con este enfoque: ¿qué pasa si una versión "
"futura de Studio utiliza un formato diferente de bancos de cart? Por lo "
"tanto, volví a visitar los archivos de banco de cart de nuevo en julio de "
"2015, y esta vez me di cuenta de que había una estructura familiar: valores "
"separados por comas, y pensé en la posibilidad de que una aplicación de "
"hojas de cálculo los procesaría adecuadamente. Para probar mi hipótesis, "
"abrí los archivos .cart en Excel, y efectivamente, se mostraron como "
"archivos csv. Por lo tanto, trabajé en modificar el procedimiento de "
"interpretación de carts, en esta ocasión usando el módulo csv de Python para "
"interpretar los archivos \"cart\" (los archivos de bancos de cart realmente "
"son archivos csv en esencia). Este nuevo procedimiento (descrito debajo) "
"hizo su aparición como parte del complemento 6.0."

#: ..\python_docs\spladdoninternals.py:487
msgid "### The magic behind Cart Explorer version 2: handling CSV files"
msgstr ""
"### La magia tras el explorador cart versión 2: trabajar con archivos csv"

#: ..\python_docs\spladdoninternals.py:488
msgid ""
"Since Python comes with a library to handle CSV files and since cart banks "
"are CSV files, I rewrote Cart Explorer routine (a function in splmisc module "
"which returns the carts dictionary) as follows:"
msgstr ""
"Ya que Python viene con una biblioteca para trabajar con archivos csv y ya "
"que los bancos de carts son archivos csv, reescribí el procedimiento del "
"explorador cart (una función en el módulo splmisc que devuelve el "
"diccionario de carts) de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:489
msgid ""
"1. When entering Cart Explorer, Cart Explorer preparation routine (splmisc."
"cartExplorerInit) will take a snapshot of your user name and Studio edition "
"(Studio's title bar indicates which version is in use). Then it initializes "
"the carts dictionary and stores the Studio edition in use."
msgstr ""
"1. Al entrar en el explorador cart, el procedimiento de preparación del "
"explorador cart (splmisc.cartExplorerInit) tomará una instantánea de tu "
"nombre de usuario y la edición de Studio (la barra de título de Studio "
"indica qué versión se está usando). Después inicializa el diccionario de "
"carts y almacena la edición de Studio en uso."

#: ..\python_docs\spladdoninternals.py:490
msgid ""
"2. Next, the preparation function will write down names and paths to cart "
"banks. In case a user other than default user is using Studio, it'll modify "
"the cart file names to match the name likely to be used by Studio to present "
"user-specific cart banks. These cart names form one part of the cart bank "
"path (the other part is the path to the folder where the carts live, "
"obtained by using an environment variable)."
msgstr ""
"2. A continuación, la función de preparación escribirá nombres y rutas en "
"los bancos cart. En caso de que un usuario distinto al que hay por defecto "
"esté utilizando Studio, se modificarán los nombres de archivo de los carts "
"para que encajen con el nombre que probablemente usará Studio para presentar "
"los bancos de carts específicos del usuario. Estos nombres de carts forman "
"una parte de la ruta al banco de carts (la otra parte es la ruta a la "
"carpeta en la que residen los carts, obtenida mediante una variable de "
"entorno)."

#: ..\python_docs\spladdoninternals.py:491
msgid ""
"3. For each cart bank, NVDA will ask Python to parse the cart bank as a CSV "
"file (csv.reader; when finished, it returns a list of lists, with each list "
"representing one row of a CSV table)."
msgstr ""
"3. En cada banco de carts, NVDA pedirá a Python que interprete el banco como "
"un archivo csv (csv.reader; al acabar, devuelve una lista de listas, siendo "
"cada lista una fila de la tabla csv)."

#: ..\python_docs\spladdoninternals.py:492
msgid ""
"4. Once the csv version of the selected cart bank is ready, the row "
"containing cart keys and cart names, together with the cart bank modifier "
"and the carts dictionary are sent to a helper function (part of splmisc "
"module) that will do the following:"
msgstr ""
"4. Una vez está lista la versión csv del banco de carts correspondiente, la "
"fila que contiene las teclas de cart y sus nombres, junto con el modificador "
"del banco de carts y el diccionario de carts, se envían a una función "
"auxiliar (parte del módulo splmisc) que hará lo siguiente:"

#: ..\python_docs\spladdoninternals.py:493
msgid ""
"\t1. Depending on Studio edition, this helper will work with only the first "
"half (Standard will only work with function keys, which are the first twelve "
"columns of this row) or the entire row (the rest are number row keys) will "
"be processed."
msgstr ""
"\t1. Dependiendo de la edición de Studio, esta función auxiliar trabajará "
"con la primera mitad solamente (la Standard sólo trabajará con las teclas de "
"función, que están en las primeras doce columnas de esta fila) o se "
"procesará la fila entera (el resto son las teclas numéricas)."

#: ..\python_docs\spladdoninternals.py:494
msgid ""
"\t2. Depending on column position (items in the row list), it will see if "
"function keys or number row keys should be assigned to the selected cart "
"entry. This routine also checks the type of the cart bank (modifiers or none "
"(main)) and modifies the cart key name accordingly."
msgstr ""
"\t2. Dependiendo de la posición de la columna (elementos en la lista de la "
"fila), se verá si deberían asignarse las teclas de función o las de la fila "
"numérica a la entrada seleccionada del cart. Este procedimiento también "
"comprueba el tipo del banco de carts (modificadores o nada (principal)) y "
"modifica el nombre de la tecla cart según corresponda."

#: ..\python_docs\spladdoninternals.py:495
msgid ""
"\t3. Next, the helper routine will try to locate the name of the jingle "
"assigned to the cart key in question, and if there is one, it'll add the "
"cart key and jingle name pair into the carts dictionary."
msgstr ""
"\t3. A continuación, el procedimiento auxiliar intentará ubicar el nombre "
"del jingle asignado a la tecla cart en cuestión, y si hay uno, añadirá el "
"par de la tecla del cart y el nombre del jingle al diccionario de carts."

#: ..\python_docs\spladdoninternals.py:496
msgid ""
"5. Back at the cartExplorerInit function, if no erorrs were found while "
"parsing a cart bank, it'll move onto the next one, otherwise it will inform "
"the Studio app module by modifying a flag value in the carts dictionary "
"(stored as an integer, representing number of cart bankks with errors)."
msgstr ""
"5. De vuelta en la función cartExplorerInit, si no se encontraron errores "
"mientras se interpretaba un banco de carts, esta se moverá al siguiente, en "
"cualquier otro caso informará al módulo de aplicación de Studio modificando "
"un valor indicador en el diccionario de carts (almacenado como un entero que "
"representa el número de bancos cart con errores)."

#: ..\python_docs\spladdoninternals.py:497
msgid ""
"6. By now cartExplorerInit is desperate to pass the carts dictionary to "
"someone, and this someone turns out to be the Studio app module - once "
"picked up by the app module, carts dictionary is hired by you to look up "
"cart names for cart keys while you use Cart Explorer (to fire the carts "
"dictionary, simply deactivate Cart Explorer by pressing Control+NVDA+3)."
msgstr ""
"6. Ahora cartExplorerInit está desesperada por pasarle el diccionario de "
"carts a alguien, y ese alguien resulta ser el módulo de aplicación de Studio "
"- una vez es recogido por el módulo de aplicación, tú lo utilizas para mirar "
"los nombres de carts que se corresponden con las teclas cart mientras usas "
"el explorador cart (para echar al fuego el diccionario de carts, simplemente "
"desactiva el explorador cart pulsando ctrl+NVDA+3)."

#: ..\python_docs\spladdoninternals.py:498
msgid ""
"In effect, the routine above (the \"magic\" behind Cart Explorer) replaced a "
"hand-written cart bank parser and simplified the add-on code (I regret not "
"investigating CSV module in 2014). As far as user experience is concerned, "
"this is same as Cart Explorer 1, with the difference being the parsing "
"routine. With the addition of splmisc.cartExplorerInit, the majority of the "
"splmisc module (miscellaneous services, containing the Track Finder/Column "
"Search combo dialog, column retriever and Cart Explorer preparation tool) "
"was completed. But the innovations continued."
msgstr ""
"En efecto, el procedimiento anterior (la \"magia\" tras el explorador cart) "
"reemplazó un intérprete de bancos de carts escrito a mano y simplificó el "
"código del complemento (lamento no haber investigado el módulo csv en 2014). "
"En términos de experiencia de usuario, no cambia nada con respecto al "
"explorador cart versión 1, siendo la diferencia el procedimiento de "
"interpretación. Al añadir la función splmisc.cartExplorerInit, la mayoría "
"del módulo splmisc (servicios misceláneos entre los que están el diálogo "
"combinado del buscador de columnas y el buscador de pistas, el recuperador "
"de columnas y la herramienta de preparación del explorador cart) estaba "
"completo. Pero continuaron las innovaciones."

#: ..\python_docs\spladdoninternals.py:499
msgid "### Enter Cart Explorer version 3: file modification timestamps"
msgstr ""
"### Introducción al explorador cart versión 3: fechas de modificación de los "
"archivos"

#: ..\python_docs\spladdoninternals.py:500
msgid ""
"There were two issues with Cart Explorer version 2: confusing statements "
"when cart insert mode was active, and inability to detect that cart editing "
"is finished. Cart insert mode allows broadcasters to press the cart command "
"to have the file inserted into the playlist as a regular track. Inability to "
"detect cart edit completion meant one had to reenter Cart Explorer to view "
"updated cart assignments."
msgstr ""
"Había dos problemas con la versión 2 del explorador cart: frases confusas "
"cuando el modo de inserción de cart estaba activo, e incapacidad de detectar "
"que había finalizado la edición de carts. El modo de inserción de carts "
"permite a los locutores pulsar la orden cart para insertar el archivo dentro "
"de la lista de reproducción como si fuera una pista normal. La incapacidad "
"de detectar la finalización de la edición de carts significaba que había que "
"entrar en el explorador cart para ver las asignaciones cart actualizadas."

#: ..\python_docs\spladdoninternals.py:501
msgid ""
"The first issue was solved by telling users that Cart Explorer was active "
"while cart insert mode was active. The resolution to the second issue "
"required a bit of work, and involved rewriting parts of Cart Explorer (now "
"version 3), which is included as of add-on 17.01 (optimized in 17.04). The "
"biggest difference is recording file modification timestamps for carts when "
"carts dictionary is being built (see above), and if cart edit is turned off, "
"checking the timestamps of newly modified cart banks against previous "
"timestamps (when cart edit is off, when cart assignments have changed, cart "
"files are written back to disk) and skipping unmodified cart banks. In "
"spring 2017, this was further optimized by allowing carts dictionary to be "
"modified on the fly (only changed bits will be modified, including possible "
"new assignments, changes and deletions). This means no more need to reenter "
"cart Explorer when cart assignments have changed, a huge relief for "
"broadcasters who need to change cart assignments for holidays or other "
"special occasions."
msgstr ""
"El primer problema se solucionó indicando a los usuarios que el explorador "
"cart estaba activo mientras el modo de inserción de carts lo estaba. La "
"resolución del segundo problema necesitó un poco de trabajo, e implicó "
"reescribir partes del explorador cart (ahora versión 3), que viene incluido "
"a partir del complemento 17.01 (optimizado en 17.04). La gran diferencia es "
"que se registran las fechas de modificación de los archivos cart cuando se "
"construye el diccionario de carts (mira arriba), y si se desactiva la "
"edición de carts, se comprueba la fecha de modificación de los archivos de "
"banco de carts con las fechas guardadas (cuando la edición de carts se "
"apaga, cuando cambian las asignaciones de carts, se escriben los archivos de "
"carts de vuelta al disco) ignorando los archivos de cart no modificados. En "
"la primavera de 2017, esto se optimizó aún más permitiendo que el "
"diccionario de carts fuera modificado al vuelo (sólo se cambiarán los bits "
"modificados, incluidas las posibles nuevas asignaciones, cambios y "
"eliminaciones). Esto significa que desaparece la necesidad de volver a "
"entrar al explorador cart cuando las asignaciones de los carts cambian, un "
"gran alivio para los locutores que necesitan cambiar las asignaciones de "
"carts para las fiestas u otras ocasiones especiales."

#: ..\python_docs\spladdoninternals.py:503
msgid ""
"Cart Explorer has come a long way; from a simple suggestion to the CSV "
"parsing routine above to checking timestamps for cart assignment changes, "
"Cart Explorer has changed to meet the needs of broadcasters using Studio and "
"NVDA. I would like to improve this further in future releases (another "
"suggestion I received was ability to specify cart file names for individual "
"banks, and I'm thinking about implementing this in the near future)."
msgstr ""
"El explorador cart ha recorrido un largo camino; desde una sugerencia simple "
"hasta el procedimiento para interpretar csv que se ha descrito antes y la "
"comprobación de las fechas de modificación de los archivos para buscar "
"cambios de asignación de carts. El explorador cart ha cambiado hasta "
"satisfacer las necesidades de los locutores que usan Studio y NVDA. Me "
"gustaría mejorarlo más en versiones futuras (otra sugerencia que recibí fue "
"la capacidad de especificar los nombres de archivo con carts de bancos "
"individuales, y estoy pensando en implementarla en el futuro cercano)."

#: ..\python_docs\spladdoninternals.py:504
msgid ""
"One of the things you may have noticed as you read this article so far is "
"how I and other developers continue to research better ways of accomplishing "
"something. You also saw a glimpse of how developers and users shape a "
"feature and how much work is involved to bring a feature suggestion to life. "
"These activities (research and feature development collaboration) are just "
"two of the pillars of this add-on, and highlights how design philosophy and "
"product development approach affects future course of product development."
msgstr ""
"Una de las cosas de las que puedes haberte dado cuenta según lees este "
"artículo hasta ahora es cómo tanto yo como otros desarrolladores seguimos "
"investigando mejores maneras de resolver algo. También echaste un vistazo a "
"cómo desarrolladores y usuarios dan forma a una característica y cuánto "
"trabajo implica hacer realidad una sugerencia. Estas actividades "
"(investigación y colaboración en el desarrollo de características) son dos "
"de los pilares que dan soporte a este complemento, y resaltan cómo afectan "
"la filosofía del diseño y el enfoque de desarrollo del producto al curso "
"futuro de su evolución."

#: ..\python_docs\spladdoninternals.py:505
msgid ""
"This ends our detailed tour of internals of major features in Studio app "
"module. When we come back, we'll visit our friend from the past: SPL "
"Assistant layer and inner workings of various layer commands."
msgstr ""
"Con esto termina nuestro recorrido detallado por el interior de las "
"características más importantes del módulo de aplicación de Studio. Cuando "
"volvamos, visitaremos a nuestro amigo del pasado: la capa del asistente de "
"SPL y el funcionamiento interno de diversas órdenes de capa."

#: ..\python_docs\spladdoninternals.py:506
msgid "## All about StationPlaylist Assistant layer"
msgstr "## Todo sobre la capa del asistente de SPL"

#: ..\python_docs\spladdoninternals.py:507
msgid ""
"You may recall visiting two layer command sets in an earlier section: SPL "
"Controller and SPL Assistant, the former used to perform Studio functions "
"from any program and the latter for status announcements. I mentioned "
"throughout this series that we'll tour these layer sets, and we'll start "
"with SPL Assistant layer."
msgstr ""
"Como recordarás, en un artículo anterior hablamos de dos conjuntos de "
"órdenes de capa: el controlador de SPL y el asistente de SPL, el primero "
"usado para realizar funciones de Studio desde cualquier programa y el otro "
"para anuncios de estado. He mencionado a lo largo de este artículo que "
"visitaríamos estos conjuntos de capa, así que empezaremos con la capa del "
"asistente de SPL."

#: ..\python_docs\spladdoninternals.py:508
msgid "### Talk about layer commands"
msgstr "### Charla sobre las órdenes de capa"

#: ..\python_docs\spladdoninternals.py:509
msgid ""
"One of the common features of Studio scripts for JAWS, Window-Eyes and NVDA "
"is extensive use of layer commands. This was popularized by JAWS and its "
"Studio layer (grave key). Some of the benefits of this approach include "
"saving keyboard commands, reminding users as to commands available in Studio "
"and so on."
msgstr ""
"Una de las características que tienen en común los scripts de Jaws, Window "
"Eyes y NVDA es el uso extenso de órdenes de capa. Jaws popularizó este "
"concepto y su capa de Studio (la tecla grave). Algunos beneficios de este "
"enfoque incluyen ahorrar órdenes de teclado, recordar a los usuarios las "
"órdenes de Studio y así sucesivamente."

#: ..\python_docs\spladdoninternals.py:510
msgid "### Birth of SPL Assistant layer"
msgstr "### Nacimiento de la capa del asistente de SPL"

#: ..\python_docs\spladdoninternals.py:511
msgid ""
"As mentioned previously, since version 1.0 in January 2014, StationPlaylist "
"add-on comes with two layer commands to represent the global plugin and the "
"studio app module. In case of Studio app module and its layer set (SPL "
"Assistant), I borrowed some commands from both JAWS and Window-Eyes scripts "
"with some notable differences, namely some commands and how things were "
"announced."
msgstr ""
"Como mencioné antes, desde la versión 1.0 en enero de 2014, el complemento "
"StationPlaylist viene con dos órdenes de capa para representar a la "
"extensión global y al módulo de aplicación de Studio. En el caso del módulo "
"de aplicación de Studio y su conjunto de capa (asistente de SPL), tomé "
"prestadas algunas órdenes de los scripts de Jaws y Window Eyes con algunas "
"diferencias destacables, entre ellas algunas órdenes y cómo se verbalizaban "
"las cosas."

#: ..\python_docs\spladdoninternals.py:512
msgid ""
"When I sat down to design this layer set, I felt it would be helpful for "
"broadcasters if most of the Assistant layer commands borrowed from Studio "
"command assignments. For example, a broadcaster will press M to toggle "
"microphone on and off, and in SPL Assistant layer, pressing M announces "
"microphone status. Another example was Cart Edit Mode - pressing Control+T "
"in Studio will toggle this, and pressing SPL Assistant, T will announce "
"whether this mode is on or off (the reason for assigning T for Cart Edit "
"Mode status will be discussed later)."
msgstr ""
"Cuando me senté a diseñar este conjunto de capa, sentí que sería útil para "
"los locutores que la mayoría de las órdenes de la capa del asistente "
"vinieran de las órdenes asignadas a Studio. Por ejemplo, un locutor pulsará "
"la m para encender o apagar el micrófono, y en la capa del asistente del "
"SPL, pulsar la m hace que se verbalice el estado del micrófono. Otro ejemplo "
"fue el modo de edición de cart - pulsar ctrl+t en Studio lo conmutará, y "
"pulsar asistente de SPL, t indicará si este modo está encendido o apagado "
"(más tarde se discutirá la razón por la que se asignó la t al estado del "
"modo de edición de carts)."

#: ..\python_docs\spladdoninternals.py:513
msgid ""
"Originally, one could invoke SPL Assistant layer by pressing Control+NVDA"
"+grave key from within Studio. However, some NVDA translators told me that "
"this key combination is used for NVDA screen reader commands in their "
"languages. Thus, in add-on 2.0 (late spring 2014), I decided to remove this "
"command, which means in order for you (broadcasters) to invoke SPL Assistant "
"layer, you need to go to Input Gestures dialog while focused in Studio, "
"expand StationPlaylist category and look for the Assistant entry (I "
"personally use Control+NVDA+grave, and in recent add-on development builds, "
"I told the add-on to let SPL Controller layer command (discussed later) to "
"invoke Assistant layer)."
msgstr ""
"Originalmente se podía invocar la capa del asistente de SPL pulsando ctrl"
"+NVDA+grave desde Studio. Sin embargo, algunos traductores de NVDA me "
"dijeron que esta combinación de teclas se usa para algunas órdenes de NVDA "
"en su idioma. Por tanto, en el complemento 2.0 (a finales de la primavera de "
"2014), decidí eliminar esta orden, lo que se traduce en que para que podáis "
"invocar la capa del asistente de SPL (locutores), debéis ir al diálogo "
"gestos de entrada mientras tengáis el foco en Studio, expandir la categoría "
"StationPlaylist y buscar la entrada del asistente (personalmente uso ctrl"
"+NVDA+grave, y en compilaciones recientes de desarrollo del complemento, "
"hice que el complemento dejara a la orden de capa del controlador de SPL "
"(explicada más tarde) invocara la capa del asistente)."

#: ..\python_docs\spladdoninternals.py:514
msgid ""
"Another addition to SPL Assistant layer is ability to emulate layer commands "
"provided by other screen readers. This is achieved by using gestures map for "
"each screen reader (NVDA included), with the correct gestures map chosen "
"when entering SPL Assistant layer. Currently, in addition to default NVDA "
"layout, the add-on includes JAWS for Windows layer commands (Window-Eyes "
"layer was removed in 2020)."
msgstr ""
"Otro extra añadido a la capa del asistente de SPL es la capacidad de emular "
"órdenes de capa proporcionadas por otros lectores de pantalla. Esto se "
"consigue usando un mapa de gestos para cada lector de pantalla (incluido "
"NVDA), con el mapa de gestos correcto elegido al entrar en la capa del "
"asistente de SPL. Actualmente, además de la distribución por defecto de "
"NVDA, el complemento tiene soporte para las órdenes de capa de Jaws for "
"Windows (la capa de Window Eyes se eliminó en 2020)."

#: ..\python_docs\spladdoninternals.py:515
msgid "### Categorizing SPL Assistant commands"
msgstr "### Categorización de las órdenes del asistente de SPL"

#: ..\python_docs\spladdoninternals.py:516
msgid ""
"Once you invoke SPL Assistant layer (a beep will be heard), you can perform "
"one of the following operations:"
msgstr ""
"Una vez que invoques a la capa del asistente de SPL (se escuchará un "
"pitido), podrás hacer una de las siguientes operaciones:"

#: ..\python_docs\spladdoninternals.py:517
msgid "* Status announcements (automation, microphone, etc.)."
msgstr "* Indicaciones de estado (automatización, micrófono, etc.)."

#: ..\python_docs\spladdoninternals.py:518
msgid ""
"* Tools (library scan, track time analysis, obtaining playlist snapshots and "
"transcripts and so on)."
msgstr ""
"* Herramientas (escaneo de biblioteca, análisis de tiempo de pista, "
"obtención de instantáneas y transcripciones de listas de reproducción y "
"demás)."

#: ..\python_docs\spladdoninternals.py:519
msgid "* Configuration (switching broadcast profiles)."
msgstr "* Configuración (alternar perfiles de emisión)."

#: ..\python_docs\spladdoninternals.py:520
msgid ""
"* Ask for help (opening SPL Assistant help document or the online user "
"guide)."
msgstr ""
"* Pedir ayuda (abriendo el documento de ayuda del asistente de Spl o la guía "
"de usuario en línea)."

#: ..\python_docs\spladdoninternals.py:521
msgid "* Until 18.12, checking for add-on updates (manually)."
msgstr ""
"* Hasta la versión 18.12, buscar actualizaciones del complemento "
"(manualmente)."

#: ..\python_docs\spladdoninternals.py:522
msgid ""
"For the first two categories, they can be divided further into commands "
"which uses studio API (via studioAPI function discussed in a previous "
"section), ones using Windows API (Columns explorer) and those relying on "
"object navigation (multiple components are involved and is sensitive to user "
"interface changes). We'll go through each of these categories in turn."
msgstr ""
"Las primeras dos categorías pueden subdividirse en órdenes que usan la api "
"de Studio (mediante la función studioAPI de la que hablamos en un artículo "
"anterior), las que usan la api de Windows (explorador de columnas) y las que "
"se apoyan en la navegación por objetos (varios componentes están implicados "
"y son sensibles a los cambios en la interfaz de usuario). Vamos a ir "
"recorriendo estas categorías de una en una."

#: ..\python_docs\spladdoninternals.py:523
msgid "#### SPL Assistant 1: status announcements"
msgstr "#### Asistente de SPL 1: indicaciones de estado"

#: ..\python_docs\spladdoninternals.py:524
msgid ""
"These commands allow you to obtain various status information such as title "
"and duration of the next track, cart edit mode status and so on. These can "
"be divided into those which uses object navigation (old style) and Studio "
"API (new style) commands. In some cases, both methods are available and the "
"appropriate version is chosen based on Studio version in use."
msgstr ""
"Estas órdenes te permiten obtener diversa información de estado como el "
"título y duración de la próxima pista, el estado del modo de edición de "
"carts y demás. Pueden dividirse en aquellos que usan la navegación por "
"objetos (el viejo estilo) y órdenes que usan la api de Studio (el nuevo "
"estilo). En algunos casos ambos métodos están disponibles, y se elige la "
"versión apropiada basándose en la versión de Studio en uso."

#: ..\python_docs\spladdoninternals.py:525
msgid ""
"The following commands (sorted alphabetically) utilize Studio API to perform "
"needed functions:"
msgstr ""
"Las siguientes órdenes (ordenadas alfabéticamente) utilizan la api de Studio "
"para llevar a cabo las funciones necesarias:"

#: ..\python_docs\spladdoninternals.py:526
msgid "* E: Announces if any metadata streaming URL's are defined."
msgstr "* E: indica si se ha definido alguna URL de flujo de metadatos."

#: ..\python_docs\spladdoninternals.py:527
msgid "* H: Duration of tracks in the selected hour."
msgstr "* H: duración de pistas en la hora seleccionada."

#: ..\python_docs\spladdoninternals.py:528
msgid "* Shift+H: Duration of the remaining tracks in the hour slot."
msgstr "* Shift+h: duración de las pistas restantes en la hora."

#: ..\python_docs\spladdoninternals.py:529
msgid "* P: Playback status."
msgstr "* P: estado de la reproducción."

#: ..\python_docs\spladdoninternals.py:530
msgid ""
"* Shift+1 through Shift+4 and Shift+0: Checks metadata streaming status for "
"each URL (0 is DSP encoder). See below for details."
msgstr ""
"* Shift+1 a shift+4 y shift+0: comprueba el estado de los metadatos del "
"flujo de cada URL (0 es el codificador DSP). Mira debajo para más detalles."

#: ..\python_docs\spladdoninternals.py:531
msgid ""
"Note that playlist remainder announcement (SPL Assistant, D) was part of "
"this category until add-on 6.x. In add-on 7.0, due to refactoring work "
"surrounding this command, it has been moved to tools category."
msgstr ""
"Ten en cuenta que la indicación del recordatorio de lista de reproducción "
"(asistente de SPL, D) era parte de esta categoría hasta el complemento 6.x. "
"En el complemento 7.0, debido a los trabajos de refactorización que "
"afectaban a esta orden, se ha movido a la categoría de herramientas."

#: ..\python_docs\spladdoninternals.py:532
msgid "##### A step sideways: Metadata streaming"
msgstr "##### Un paso a un lado: flujo de metadatos"

#: ..\python_docs\spladdoninternals.py:533
msgid ""
"Studio can be told to stream track metadata to five URL's: the DSP encoder "
"address and four additional URL's (Options/Now Playing). By default, DSP "
"encoder address is used to send metadata information."
msgstr ""
"Se puede pedir a Studio que emita en tiempo real los metadatos de una pista "
"a cinco URLS: la dirección del codificador DSP y cuatro URLS adicionales "
"(Opciones / Reproducción en curso). Por defecto, se usa la dirección del "
"codificador DSP para enviar información de metadatos."

#: ..\python_docs\spladdoninternals.py:534
msgid ""
"One of the activities Studio app module performs when starting is to check "
"if metadata streaming is enabled on any URL's. In addition, NVDA can tell "
"you status of metadata streaming for all uRL's (SPL Assistant, E) or for "
"individual addresses (SPL Assistant, Shift+1 through Shift+4 and Shift+0). "
"This is done through a metadata management and announcement function "
"(metadataAnnouncer) that gathers streaming flags for URL's and presents "
"status messages and connects to predefined servers if you tell Studio to "
"connect to streaming servers."
msgstr ""
"Una de las actividades que realiza el módulo de aplicación de Studio al "
"iniciar es comprobar si la emisión de metadatos está activada en alguna URL. "
"Además, NVDA te puede informar del estado del flujo de metadatos para todas "
"las URLS (asistente de SPL, E) o para direcciones individuales (asistente de "
"SPL, shift+1 a shift+4 y shift+0). Esto se hace mediante una función de "
"indicación y administración de metadatos (metadataAnnouncer) que recopila "
"indicadores de flujo de las URLS y presenta mensajes de estado y se conecta "
"a los servidores por defecto si le pides a Studio que se conecte a "
"servidores en tiempo real."

#: ..\python_docs\spladdoninternals.py:535
msgid "When the metadata announcer is called, NVDA does the following:"
msgstr "Cuando se llama al indicador de metadatos, NVDA hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:536
msgid ""
"1. NVDA will look at connection flag (reminder = True, but in reality, this "
"is mostly used as the connection flag), and if the flag is set, connects to "
"a predefined set of streaming URL's."
msgstr ""
"1. NVDA mirará el indicador de conexión (reminder=True, pero en realidad, "
"esto se usa mayoritariamente como el indicador de conexión), y si el "
"indicador está activo, se conecta a un conjunto predefinido de URLS de flujo."

#: ..\python_docs\spladdoninternals.py:537
msgid "2. Gathers metadata streaming flags, starting with the DSP encoder."
msgstr ""
"2. Recopila indicadores de emisión de metadatos, empezando por el "
"codificador DSP."

#: ..\python_docs\spladdoninternals.py:538
msgid ""
"3. The announcer will count number of metadata enabled URL's used to format "
"the status message."
msgstr ""
"3. El anunciador contará el número de URLS de metadatos activas usadas para "
"dar formato al mensaje de estado."

#: ..\python_docs\spladdoninternals.py:539
msgid ""
"4. announces the status message. This message isn't announced right away if "
"this function is called when the app module starts - after a short pause, "
"the status message will be announced and an alarm sound will be played. This "
"is done to make sure this message is the last message to be announced when "
"Studio starts."
msgstr ""
"4. Se verbaliza el mensaje de estado. Este mensaje no se verbaliza en el "
"momento si se llama a la función cuando el módulo de aplicación se inicia - "
"se verbalizará el mensaje y se reproducirá un sonido de alarma tras una "
"breve pausa. Esto se hace para asegurarse de que este mensaje es el último "
"que se verbaliza cuando arranca Studio."

#: ..\python_docs\spladdoninternals.py:540
msgid "##### Revisiting the past: object navigation"
msgstr "##### Volviendo al pasado: navegación por objetos"

#: ..\python_docs\spladdoninternals.py:541
msgid ""
"Before the new style routines were written, all commands used object "
"navigation. Typically, the command will use a helper function and an object "
"map to locate the needed object and will announce what you are looking for "
"(typically obj.name or an error message). The process was as follows:"
msgstr ""
"Antes de escribir los procedimientos del nuevo estilo, todas las órdenes "
"usaban navegación por objetos. Normalmente, el comando usará una función "
"auxiliar y un mapa de objetos para ubicar el objeto que necesita y "
"verbalizará lo que estás buscando (normalmente obj.name o un mensaje de "
"error). El proceso era como se describe a continuación:"

#: ..\python_docs\spladdoninternals.py:542
msgid ""
"1. The Studio app module contains a map of indecies where the object lives "
"in relation to the foreground window. For example, for a given object, if "
"index was 0, NVDA nows that the object is the first child of the foreground "
"object. Technically, it is a dictionary of lists, with each list item "
"(indecies) corresponding to the version of Studio the add-on supports."
msgstr ""
"1. El módulo de aplicación de Studio contiene un mapa de índices donde el "
"objeto reside en relación con la ventana en primer plano. Por ejemplo, para "
"un objeto dado, si el índice es 0, NVDA sabe que el objeto es el primer hijo "
"del objeto en primer plano. Técnicamente, es un diccionario de listas, "
"correspondiendo cada elemento de lista (índice) con cada versión de Studio a "
"la que el complemento da soporte."

#: ..\python_docs\spladdoninternals.py:543
msgid ""
"2. To fetch needed objects and to record the command type, a number of "
"constants are defined in the app module (all integers, denoting what you "
"wish to hear). These constants serve as keys to the object index map."
msgstr ""
"2. Para recuperar los objetos necesarios y registrar el tipo de orden, se "
"definen una serie de constantes en el módulo de aplicación (todas enteras, "
"indicando lo que quieres oír). Estas constantes sirven como claves al mapa "
"de índices de objeto."

#: ..\python_docs\spladdoninternals.py:544
msgid ""
"3. After entering SPL Assistant layer and once you press one of the commands "
"below, NVDA will do the following:"
msgstr ""
"3. Después de entrar en la capa del asistente de SPL y una vez que pulses "
"una de las siguientes órdenes, NVDA hará lo siguiente:"

#: ..\python_docs\spladdoninternals.py:545
msgid ""
"\t1. Each command will obtain the object in question by calling object "
"fetcher (status function) with the announcement type as the parameter "
"(status(SPLConstant; for example, for cart edit mode, the signature is self."
"status(self.SPLPlayStatus), with the constant denoting a status bar)."
msgstr ""
"\t1. Cada orden obtendrá el objeto en cuestión llamando al recuperador de "
"objetos (función de estado) pasando como parámetro el tipo de anuncio "
"(estado (SPLConstant; por ejemplo, para el modo de edición de carts, la "
"llamada sería self.status(self.SPLPlayStatus), con la constante indicando "
"una barra de estado)."

#: ..\python_docs\spladdoninternals.py:546
msgid ""
"\t2. The object fetcher (status function) will first consult an object cache "
"(part of the Studio app module) hoping that the needed object is ready for "
"use (for performance reasons; this is also performed in Playlist Editor for "
"performance reasons as explained later)."
msgstr ""
"\t2. El recuperador de objetos (función de estado) consultará primero una "
"caché de objetos (parte del módulo de aplicación de Studio) esperando que el "
"objeto necesario esté listo para usarse (por razones de rendimiento; esto se "
"hace también en el editor de listas de reproducción como se explica más "
"adelante)."

#: ..\python_docs\spladdoninternals.py:547
msgid ""
"\t3. If the object was not cached, the fetcher will first write down the "
"foreground window, then use the directions specified in the object index map "
"(the constant passed into the status function is the key to this map and "
"different values are returned based on Studio version) to locate, cache and "
"return the object in question (in that order)."
msgstr ""
"\t3. Si el objeto no está en la caché, el recuperador anotará primero la "
"ventana en primer plano, luego usará las directrices especificadas en el "
"mapa de índices de objeto (la constante pasada a la función de estado es la "
"clave de este mapa y se devuelven valores diferentes según la versión de "
"Studio) para ubicar, meter en caché y devolver el objeto en cuestión (en ese "
"orden)."

#: ..\python_docs\spladdoninternals.py:548
msgid ""
"\t4. Back at the routine for the command, it is up to the routine as to what "
"to do with it (sometimes, the actual object is a child of the just returned "
"object)."
msgstr ""
"\t4. De vuelta en el procedimiento para esa orden, se hará una cosa u otra "
"con el objeto en función del procedimiento elegido (a veces, el objeto real "
"es hijo del objeto devuelto)."

#: ..\python_docs\spladdoninternals.py:549
msgid "The commands which utilizes object navigation steps above include:"
msgstr ""
"Las órdenes que utilizan los pasos anteriores con navegación por objetos "
"incluyen:"

#: ..\python_docs\spladdoninternals.py:550
msgid "* A. Automation."
msgstr "* A. Automatización."

#: ..\python_docs\spladdoninternals.py:551
msgid "* C: Title of the currently playing track."
msgstr "* C: título de la pista actualmente en reproducción."

#: ..\python_docs\spladdoninternals.py:552
msgid ""
"* I: Listener count (I have tried using Studio API to obtain this "
"information, but after experimenting with it, object navigation routine was "
"more stable)."
msgstr ""
"* I: número de oyentes (he intentado usar la api de Studio para obtener esta "
"información, pero después de experimentar con ella, el procedimiento de "
"navegación por objetos resultó más estable)."

#: ..\python_docs\spladdoninternals.py:553
msgid "* L: Line in."
msgstr "* L: línea de entrada."

#: ..\python_docs\spladdoninternals.py:554
msgid "* M: Microphone."
msgstr "* M: micrófono."

#: ..\python_docs\spladdoninternals.py:555
msgid "* N: Title and duration for the next track."
msgstr "* N: título y duración de la siguiente pista."

#: ..\python_docs\spladdoninternals.py:556
msgid "* Shift+P: Track pitch."
msgstr "* Shift+p: tono de pista."

#: ..\python_docs\spladdoninternals.py:557
msgid "* R: Record to file."
msgstr "* R: grabar a archivo."

#: ..\python_docs\spladdoninternals.py:558
msgid "* S: Track scheduled for."
msgstr "* S: pista programada."

#: ..\python_docs\spladdoninternals.py:559
msgid "* Shift+S: Duration of selected tracks in the current hour slot."
msgstr "* Shift+s: duración de las pistas seleccionadas en la hora actual."

#: ..\python_docs\spladdoninternals.py:560
msgid ""
"* T: Cart Edit Mode (I assigned T to this command for efficiency reasons)."
msgstr ""
"* T: modo de edición de carts (asigné la t a esta orden por razones de "
"eficiencia)."

#: ..\python_docs\spladdoninternals.py:561
msgid "* U: Studio up time."
msgstr "* U: tiempo de funcionamiento de Studio."

#: ..\python_docs\spladdoninternals.py:562
msgid "* W: Weather and temperature (if configured)."
msgstr "* W: tiempo atmosférico y temperatura (si se han configurado)."

#: ..\python_docs\spladdoninternals.py:563
msgid "* Y: Playlist modification."
msgstr "* Y: modificación de lista de reproducción."

#: ..\python_docs\spladdoninternals.py:564
msgid ""
"Note that in Studio 5.20 and later, some of these (such as automation) uses "
"Studio API."
msgstr ""
"Ten en cuenta que en Studio 5.20 y versiones posteriores, algunas de ellas "
"(como la automatización) usan la api de Studio."

#: ..\python_docs\spladdoninternals.py:565
msgid ""
"For example, if you press A to obtain automation status from Studio 5.10:"
msgstr ""
"Por ejemplo, si pulsas la A para obtener el estado de la automatización en "
"Studio 5.10:"

#: ..\python_docs\spladdoninternals.py:566
#: ..\python_docs\spladdoninternals.py:573
msgid "1. Invoke SPL Assistant, then press A."
msgstr "1. Se invoca al asistente de SPL, y luego se pulsa la A."

#: ..\python_docs\spladdoninternals.py:567
msgid ""
"2. The status function (object fetcher) is called, taking the status bar "
"constant (SPLPlayStatus, which is 0) as the key to the index map."
msgstr ""
"2. Se llama a la función de estado (recuperador de objetos), tomando la "
"constante de la barra de estado (SPLPlayStatus, que es 0) como clave para el "
"mapa de índices."

#: ..\python_docs\spladdoninternals.py:568
msgid ""
"3. Object fetcher will see if the status bar object (cache dictionary with "
"the key of 0) has been cached. For this example, it isn't."
msgstr ""
"3. El recuperador de objetos comprobará si el objeto de la barra de estado "
"(diccionario de la caché, clave 0) está cacheado. En este ejemplo, no lo "
"está."

#: ..\python_docs\spladdoninternals.py:569
msgid ""
"4. Seeing that the status bar isn't cached, object fetcher will now look at "
"the index map and will decide which column to read (for this example, it is "
"column 2 (index 1)). The column records the child position of the status bar "
"relative to the foreground window (in our case, index is 6 or the seventh "
"child)."
msgstr ""
"4. Al ver que la barra de estado no está en caché, el recuperador de objetos "
"mirará ahora el mapa de índices y decidirá qué columna va a leer (en este "
"ejemplo, es la columna 2 (índice 1)). La columna registra la posición de la "
"barra de estado hija relativa a la ventana en primer plano (en nuestro caso, "
"se trata del séptimo hijo con índice 6)."

#: ..\python_docs\spladdoninternals.py:570
msgid ""
"5. Once the child object position index is obtained, object fetcher will "
"locate the actual object and cache it (self._cachedStatusObjs[infoIndex] = "
"fg.children[statusObj]), then returns the object to the automation "
"announcement routine."
msgstr ""
"5. Una vez se obtiene el índice de la posición del objeto hijo, el "
"recuperador de objetos ubicará el objeto real y lo meterá en caché (self."
"_cachedStatusObjs[infoIndex] = fg.children[statusObj]), y luego devolverá "
"este objeto a la función de verbalización de automatización."

#: ..\python_docs\spladdoninternals.py:571
msgid ""
"6. Back at the script routine, NVDA will be reminded that it needs to look "
"at one of the object's children (status bars can contain child objects if "
"exposed by accessibility API's), then will announce one of it's contents "
"(second child object, which records automation status)."
msgstr ""
"6. De vuelta en la función del script, se le recordará a NVDA que debe mirar "
"uno de los objetos hijo (las barras de estado pueden contener objetos hijos "
"si las apis de accesibilidad lo exponen así), y luego verbalizará uno de sus "
"contenidos (segundo objeto hijo, que registra el estado de la "
"automatización)."

#: ..\python_docs\spladdoninternals.py:572
msgid "In Studio 5.20 and later:"
msgstr "En Studio 5.20 y posteriores:"

#: ..\python_docs\spladdoninternals.py:574
msgid ""
"2. Calls Studio API to retrieve the given status flag (in this case, 1, "
"which records automation status)."
msgstr ""
"2. Se llama a la api de Studio para recuperar el indicador de estado dado "
"(en este caso es el 1, que registra el estado de automatización)."

#: ..\python_docs\spladdoninternals.py:575
msgid ""
"3. A lookup table with possible status bar messages is then consulted, and "
"the appropriate message based on status flag and value is retrieved and "
"announced."
msgstr ""
"3. Después, se consulta una tabla de búsqueda con posibles mensajes de la "
"barra de estado, y se recupera y verbaliza el mensaje apropiado basándose en "
"el indicador de estado y el valor."

#: ..\python_docs\spladdoninternals.py:576
msgid ""
"Not all status bar messages will use Studio API and status messages table. "
"The lone exception is cart mode status, which requires consulting two flag "
"values returned by Studio to construct the actual announcement (cart edit "
"mode on/off and whether cart insert mode is active)."
msgstr ""
"No todos los mensajes de la barra de estado usarán la api de Studio y la "
"tabla de mensajes de estado. Una excepción es el estado del modo de carts, "
"para el que es necesario consultar dos valores devueltos por Studio para "
"construir el mensaje verbalizado finalmente (modo de edición de carts "
"activado o desactivado y si el modo de edición de carts está activado)."

#: ..\python_docs\spladdoninternals.py:577
msgid "##### Another side tour: Playlist Editor and object caching"
msgstr ""
"##### Otra visita complementaria: el editor de listas de reproducción y la "
"caché de objetos"

#: ..\python_docs\spladdoninternals.py:578
msgid ""
"As noted above, part of object navigation commands in SPL Assistant involve "
"object cache. This is necessary for performance reasons, as retrieving and "
"navigating via objects is slow versus retrieving needed object from a cache, "
"which is faster than manual object retrieval. This technique is frequently "
"labeled \"memoization\" and is used to improve responsiveness if an "
"important data is present somewhere for fast retrieval."
msgstr ""
"Como se ha observado antes, parte de las órdenes de navegación por objetos "
"en el asistente de SPL involucran a la caché de objetos. Es necesaria por "
"motivos de rendimiento, ya que recuperar los objetos y navegar por ellos es "
"lento comparado con recuperar el objeto necesario de una caché, que es más "
"rápido que una recuperación de objeto manual. Esta técnica se conoce "
"frecuentemente como \"memorización\", y se usa para mejorar el rendimiento "
"si hay datos importantes presentes en algún lugar y hay que recuperarlos "
"deprisa."

#: ..\python_docs\spladdoninternals.py:579
msgid ""
"Similar to SPL Assistant commands involving object navigation, Creator's "
"Playlist Editor's status objects require caching because slowness of object "
"navigation. Without caching, retrieving needed information will take seconds "
"instead of fraction of a second. Just like Studio, cached information is "
"cleared when Creator app module is terminated."
msgstr ""
"De forma similar a las órdenes del asistente de SPL que implican navegación "
"por objetos, los objetos de estado del editor de listas de reproducción de "
"Creator requieren una caché debido a la lentitud de la navegación por "
"objetos. Sin caché, recuperar la información necesaria tomaría segundos en "
"vez de fracciones de segundo. Al igual que en Studio, la información en "
"caché se limpia cuando finaliza la ejecución del módulo de aplicación de "
"Creator."

#: ..\python_docs\spladdoninternals.py:580
msgid "#### SPL Assistant 2: tools"
msgstr "#### Asistente de SPL 2: herramientas"

#: ..\python_docs\spladdoninternals.py:581
msgid ""
"These are miscellaneous commands in SPL Assistant, and three of them use "
"Studio API:"
msgstr ""
"Aquí hay órdenes varias del asistente de SPL, tres de ellas usan la api de "
"Studio:"

#: ..\python_docs\spladdoninternals.py:582
msgid "* D: Remaining time for the opened playlist."
msgstr "* D: tiempo restante de la lista de reproducción abierta."

#: ..\python_docs\spladdoninternals.py:583
msgid ""
"* K: Moves to a marked track. This was discussed in column routines and "
"place marker sections."
msgstr ""
"* K: se mueve a una pista marcada. Ya se habló de esto en las secciones de "
"procedimientos de columna y marcadores."

#: ..\python_docs\spladdoninternals.py:584
msgid ""
"* Control+K: Sets track place marker. Consult the place marker section to "
"learn how it works."
msgstr ""
"* Ctrl+k: sitúa un marcador de pista. Consulta la sección de marcadores para "
"aprender cómo funciona."

#: ..\python_docs\spladdoninternals.py:585
msgid ""
"* Shift+R: Library scan. This is a convenience function to start library "
"scan in the background, useful if you have added new tracks from a number of "
"folders via Studio Options dialog. Consult library scan section for details "
"on library scan internals."
msgstr ""
"* Shift+r: escaneo de biblioteca. Esta es una función útil para iniciar un "
"escaneo de biblioteca en segundo plano, viene bien si has añadido nuevas "
"pistas desde una serie de carpetas mediante el diálogo de opciones de "
"Studio. Consulta un artículo anterior sobre el escaneo de biblioteca para "
"más detalles sobre el interior de esta característica."

#: ..\python_docs\spladdoninternals.py:586
msgid ""
"* F8: Obtains playlist snapshot information for the currently loaded track, "
"including track count, shortest and longest tracks and top artists. This "
"feature uses a combination of Windows and Studio API's."
msgstr ""
"* F8: obtiene una instantánea con información de la lista de reproducción "
"para la pista cargada actualmente, incluyendo la cantidad de pistas, pistas "
"más cortas y más largas y artistas más populares. Esta función usa una "
"combinación de las apis de Windows y Studio."

#: ..\python_docs\spladdoninternals.py:587
msgid ""
"* Shift+F8: requests a playlist transcript (data about loaded playlist). "
"Just like playlist snapshots, it uses a combination of object navigation and "
"Windows API."
msgstr ""
"* Shift+f8: solicita una transcripción de lista de reproducción (datos sobre "
"la lista de reproducción cargada). Al igual que las instantáneas de listas "
"de reproducción, aquí se usa una combinación de la navegación de objetos y "
"la API de Windows."

#: ..\python_docs\spladdoninternals.py:588
msgid ""
"* F9: Marks the current position of the playlist as start of track time "
"analysis (more on this feature below)."
msgstr ""
"* F9: marca la posición actual de la lista de reproducción como inicio del "
"análisis de tiempo de pista (se explica más sobre esto debajo)."

#: ..\python_docs\spladdoninternals.py:589
msgid "* F10: Performs track time analysis (add-on 6.0)."
msgstr "* F10: realiza el análisis de tiempo de pista (complemento 6.0)."

#: ..\python_docs\spladdoninternals.py:590
msgid "##### Track time analysis: Duration of \"selected\" tracks"
msgstr ""
"##### Análisis de tiempo de pista: duración de las pistas seleccionadas"

#: ..\python_docs\spladdoninternals.py:591
msgid ""
"A few months ago, during a Skype chat with a number of add-on users, someone "
"suggested a feature where NVDA will tell you how long it'll take to play "
"selected tracks. Since I was familiar with this concept from JAWS scripts, I "
"decided to work on it as part of add-on 6.0."
msgstr ""
"Hace unos meses, mientras conversaba en un chat de Skype con algunos "
"usuarios del complemento, alguien sugirió una característica que permitiera "
"a NVDA decir cuánto tiempo llevaría reproducir las pistas seleccionadas. Ya "
"que este concepto era familiar para mí porque lo conocía de los scripts de "
"Jaws, decidí trabajar en ello como parte del complemento 6.0."

#: ..\python_docs\spladdoninternals.py:592
msgid ""
"The resulting routine (which is available if you are focused on the main "
"playlist viewer with the playlist loaded) is as follows:"
msgstr ""
"El procedimiento resultante (que está disponible si tienes el foco en el "
"visor principal de la lista de reproducción con la lista de reproducción "
"cargada) es el siguiente:"

#: ..\python_docs\spladdoninternals.py:593
msgid ""
"1. Move to the position in a playlist to mark as start of track time "
"analysis."
msgstr ""
"1. Te mueves a una posición en la lista de reproducción para marcarla como "
"punto de inicio del análisis de tiempo de pista."

#: ..\python_docs\spladdoninternals.py:594
msgid "2. Enter SPL assistant, then press F9."
msgstr "2. Entras al asistente de SPL y pulsas f9."

#: ..\python_docs\spladdoninternals.py:595
msgid ""
"3. Move to another track in the playlist, open SPL Assistant then press F10. "
"NVDA will then:"
msgstr ""
"3. Te mueves a otra pista en la lista de reproducción, abres el asistente de "
"SPL y pulsas f10. A partir de ahí, NVDA:"

#: ..\python_docs\spladdoninternals.py:596
msgid ""
"\t1. Determine analysis range. For most cases, it'll be top to bottom "
"analysis, but in some cases, it could be reverse (bottom to top). Also, a "
"variable to hold total duration will be prepared."
msgstr ""
"\t1. Determina el rango del análisis. En la mayoría de casos será un "
"análisis de arriba a abajo, pero en otros casos podría invertirse (de abajo "
"a arriba). Además, se preparará una variable para almacenar la duración "
"total."

#: ..\python_docs\spladdoninternals.py:597
msgid ""
"\t2. For each track in the analysis range, NVDA will obtain file name and "
"track duration (in reality, segue) via Studio API. Once the track duration "
"is received, it is then added to the total duration variable."
msgstr ""
"\t2. Para cada pista en el rango de análisis, NVDA obtendrá el nombre de "
"archivo y la duración de la pista (en realidad, sesgo) mediante la api de "
"Studio. Una vez se reciba la duración de la pista, se añadirá a la variable "
"con la duración total."

#: ..\python_docs\spladdoninternals.py:598
msgid ""
"\t3. Once time analysis (calculating total duration) is done, NVDA will "
"announce number of tracks selected and the total duration using mm:ss format."
msgstr ""
"\t3. Una vez se hace el análisis de tiempo (cálculo de la duración total), "
"NVDA verbalizará el número de pistas seleccionadas y la duración total "
"usando el formato mm:ss."

#: ..\python_docs\spladdoninternals.py:599
msgid ""
"If you are a seasoned NVDA user, you may have noticed a familiar pattern: "
"the command to set a marker to copy review cursor text is NVDA+F9, and you "
"would move to a different location and press NVDA+F10 to copy the selected "
"text to the clipboard. Replacing the NVDA modifier key with SPL Assistant "
"produces the commands above: F9 to mark current position for time analysis, "
"and F10 to perform the actual calculation. I intentionally chose these two "
"function keys to provide consistent experience and to reenforce concepts "
"used in NVDA screen reader: review cursor."
msgstr ""
"Si eres un usuario experto de NVDA, puedes haberte dado cuenta de un patrón "
"familiar: la orden para situar un marcador para copiar texto del cursor de "
"revisión es NVDA+f9, y te moverías a una ubicación diferente y pulsarías NVDA"
"+f10 para copiar el texto seleccionado al portapapeles. Reemplazando la "
"tecla modificadora de NVDA con el asistente de SPL produce un resultado "
"parecido: f9 marca la posición inicial del análisis de tiempo, y f10 realiza "
"el cálculo. Elegí estas dos teclas de función intencionadamente para "
"proporcionar una experiencia consistente y reforzar conceptos usados en el "
"lector de pantalla NVDA: el cursor de revisión."

#: ..\python_docs\spladdoninternals.py:600
msgid "##### Playlist remainder announcement"
msgstr "##### Anuncio de tiempo restante de la lista de reproducción"

#: ..\python_docs\spladdoninternals.py:601
msgid ""
"Until add-on 6.x, playlist remainder announcement was based on Studio API. "
"However, it was found that this \"remainder\" was actually the remaining "
"time within the selected hour slot. To get around this, in add-on 7.0, this "
"routine was rewritten to take advantage of Track Dial introduced in add-on "
"5.0 (see Track Dial section above)."
msgstr ""
"Hasta el complemento 6.x, el anuncio de tiempo restante de la lista de "
"reproducción estaba basado en la api de Studio. Sin embargo, nos dimos "
"cuenta de que este \"tiempo restante\" era el de la hora actual. Para "
"solucionarlo, en el complemento 7.0 se reescribió este procedimiento para "
"aprovechar la ventaja que daba el dial de pista introducido en el "
"complemento 5.0 (mira la sección de más arriba sobre el dial de pista)."

#: ..\python_docs\spladdoninternals.py:602
msgid ""
"Technically, a combination of column content fetching and track navigation "
"routines are used to accomplish this. When SPL Assistant, D is pressed, NVDA "
"will write down the focused track and will move down the playlist (starting "
"from the focused track), recording the segue (total track duration minus "
"crossfade). Once playlist navigation is complete, the total duration is then "
"sent to time announcement routine (see above) for processing (converted to "
"hours, minutes and seconds format)."
msgstr ""
"Técnicamente, se aplica una combinación de recuperación de contenido de "
"columnas y procedimientos de navegación por pistas para solucionar el "
"problema. Al pulsar asistente de SPL, D, NVDA anotará la pista con el foco y "
"se moverá hacia abajo en la lista de reproducción (empezando desde la pista "
"con el foco), registrando la secuencia (duración total de pista menos "
"transición). En cuanto se completa la navegación por la lista de "
"reproducción, se envía la duración total al procedimiento de verbalización "
"de tiempo (mira arriba) para su procesamiento (conversión al formato de "
"horas, minutos y segundos)."

#: ..\python_docs\spladdoninternals.py:603
msgid "##### Playlist snapshots and transcripts"
msgstr "##### Instantáneas y transcripciones de lista de reproducción"

#: ..\python_docs\spladdoninternals.py:604
msgid ""
"Although similar in appearance, playlist snapshots and transcripts are two "
"different things. Both uses a combination of object navigation and Windows "
"API, work by retrieving and analyzing column content for tracks, and involve "
"SPL Assistant followed by F8 with or without modifiers. Whereas a snapshot "
"is used to gather statistics about the loaded playlist, a transcript is the "
"entire playlist formatted in different ways. Also, after invoking SPL "
"Assistant layer, just pressing F8 will launch snapshots, whereas you need to "
"press Shift+F8 to obtain a playlist transcript and choose appropriate action "
"such as transcript range, output format and so on via the dialog that "
"appears afterwards."
msgstr ""
"Aunque en apariencia son similares, las transcripciones y las instantáneas "
"en listas de reproducción son dos cosas diferentes. Ambas usan una "
"combinación de navegación por objetos y la API de Windows, funcionan "
"recuperando y analizando el contenido de las columnas en las pistas, e "
"implican al asistente de SPL seguido de f8 con o sin modificadores. Mientras "
"que una instantánea se usa para obtener estadísticas sobre la lista de "
"reproducción cargada, una transcripción es la lista de reproducción entera "
"formateada de diversas maneras. Además, después de invocar a la capa del "
"asistente de SPL, simplemente pulsando f8 se tomará la instantánea, mientras "
"que es necesario pulsar shift+f8 para obtener una transcripción de la lista "
"de reproducción y elegir la acción apropiada, como el rango de "
"transcripción, formato de salida y demás, mediante el diálogo que aparece "
"después."

#: ..\python_docs\spladdoninternals.py:605
msgid ""
"A playlist snapshot presents statistics about the currently loaded playlist "
"(or parts of it). Information gathered include how many items (including "
"hour markers) are loaded, longest and shortest tracks, and average track "
"duration. Also, if asked to do so, up to top ten artists, categories, and/or "
"track genres are recorded. This information is presented either via speech "
"and braille, or if the command is pressed twice, in a browse mode window."
msgstr ""
"Una instantánea de lista de reproducción presenta estadísticas sobre la "
"lista de reproducción cargada (o partes de ella). Entre la información "
"recopilada se incluye cuántos elementos hay cargados (también marcadores de "
"hora), pistas más largas y más cortas, y duración media de la pista. "
"También, si se pide, se registran hasta diez artistas, categorías y/o "
"géneros de pista. Esta información se representa bien mediante voz o "
"braille, o si se pulsa la orden dos veces, en una ventana del modo "
"exploración."

#: ..\python_docs\spladdoninternals.py:606
msgid ""
"In contrast, a playlist transcript is the complete overview of the loaded "
"playlist (or parts of it) presented in various formats. This complete "
"overview includes data from all columns (not just the ones examined by "
"playlist snapshots). Once data from all columns are gathered for a track, "
"NVDA will convert this information into various formats, including plain "
"text, HTML table, comma-separated values (CSV) and so on for viewing in a "
"browse mode window, copying to clipboard (for some formats), or saving to a "
"file."
msgstr ""
"En contraste, una transcripción de lista de reproducción es una descripción "
"completa de la lista de reproducción cargada (o partes de ella) presentada "
"en diversos formatos. Esta descripción completa incluye datos de todas las "
"columnas (y no simplemente las que se examinan en la instantánea de lista de "
"reproducción). Una vez se recuperan todos los datos de las columnas en una "
"pista, NVDA convierte esta información a diversos formatos, incluidos texto "
"plano, una tabla HTML, valores separados por comas (CSV) y demás para que se "
"pueda ver en una ventana del modo exploración, copiar al portapapeles (en "
"algunos formatos) oo guardarla en un archivo."

#: ..\python_docs\spladdoninternals.py:607
msgid "#### SPL Assistant 3: configuration"
msgstr "#### Asistente de SPL 3: configuración"

#: ..\python_docs\spladdoninternals.py:608
msgid ""
"There is another function key assigned to SPL Assistant: pressing F12 will "
"switch to an instant switch profile (if defined). We'll come back to what is "
"meant by \"instant switch profile\" and the mechanics of it (and internals "
"of SPL Assistant, F12) in the next section."
msgstr ""
"Hay otra tecla de función asignada al asistente de SPL: pulsar f12 cambiará "
"a un perfil de cambio instantáneo (si está definido). Volveremos a explicar "
"qué se entiende por \"perfil de cambio instantáneo\" y sus mecanismos (y el "
"interior del asistente de SPL, f12) en la próxima sección."

#: ..\python_docs\spladdoninternals.py:609
msgid "#### SPL Assistant 4: getting help"
msgstr "#### Asistente de SPL 4: conseguir ayuda"

#: ..\python_docs\spladdoninternals.py:610
msgid ""
"I believe that a product isn't complete without a good quality "
"documentation. For this reason, SPL Assistant provides two commands to help "
"you use the layer commands or the add-on itself. They are:"
msgstr ""
"Yo creo que un producto no está completo sin una buena documentación de "
"calidad. Por esta razón, el asistente de SPL proporciona dos órdenes para "
"ayudarte a usar la capa de órdenes o el complemento en sí. Son las "
"siguientes:"

#: ..\python_docs\spladdoninternals.py:611
msgid ""
"* F1: Opens a browse mode document presenting a list of SPL Assistant layer "
"commands."
msgstr ""
"* F1: muestra un documento en modo exploración que presenta una lista de "
"órdenes de la capa del asistente de SPL."

#: ..\python_docs\spladdoninternals.py:612
msgid "* Shift+F1: Opens the online user guide (os.startfile)."
msgstr "* Shift+f1: abre la guía de usuario en línea (os.startfile)."

#: ..\python_docs\spladdoninternals.py:613
msgid "#### SPL Assistant 5: Checking for add-on updates"
msgstr "#### Asistente de SPL 5: búsqueda de actualizaciones"

#: ..\python_docs\spladdoninternals.py:614
msgid ""
"If using add-on 18.12 and earlier, pressing Control+Shift+U after entering "
"SPL Assistant layer will cause the add-on to check for add-on updates. "
"Unlike the automatic update check process described earlier, this one is a "
"manual check, thus it'll perform additional actions such as stopping the "
"automatic update check timer before actually checking for updates. Another "
"difference is that this command will display a results dialog if there are "
"no updates or other errors are encountered, whereas in automatic check mode, "
"they are not shown."
msgstr ""
"Al usar el complemento 18.12 o anterior, si pulsas ctrl+shift+u después de "
"entrar en la capa del asistente de SPL hará que el complemento busque "
"actualizaciones de sí mismo. A diferencia del proceso automático de búsqueda "
"de actualizaciones descrito anteriormente, esta es una búsqueda manual, y "
"por tanto llevará a cabo acciones adicionales como detener el temporizador "
"de búsqueda automática de actualizaciones antes de buscar actualizaciones "
"realmente. Otra diferencia es que esta orden mostrará un diálogo de "
"resultados si no hay actualizaciones o se encuentran otros errores, mientras "
"que en el modo de búsqueda automática, no se muestran."

#: ..\python_docs\spladdoninternals.py:615
msgid ""
"### A surprise: some Assistant layer commands can be invoked without "
"entering the layer first"
msgstr ""
"### Una sorpresa: pueden invocarse algunas órdenes de la capa del asistente "
"sin entrar a ella primero"

#: ..\python_docs\spladdoninternals.py:616
msgid ""
"There are times when a broadcaster will need to obtain certain information "
"quickly. So the question becomes, \"is there a way to announce something "
"without first invoking Assistant layer?\" Yes, you can assign a custom "
"command for the following Assistant commands:"
msgstr ""
"Hay veces en las que un locutor querrá obtener cierta información "
"rápidamente. Por eso nos hacemos la siguiente pregunta: \"¿Hay forma de "
"verbalizar algo sin tener que invocar primero la capa del asistente?\". Sí, "
"se puede asignar una orden personalizada a las siguientes funciones del "
"asistente:"

#: ..\python_docs\spladdoninternals.py:617
msgid "* Name of the next track."
msgstr "* Nombre de la próxima pista."

#: ..\python_docs\spladdoninternals.py:618
msgid "* Name of the current track."
msgstr "* Nombre de la pista actual."

#: ..\python_docs\spladdoninternals.py:619
msgid "* Weather and temperature."
msgstr "* Tiempo y temperatura."

#: ..\python_docs\spladdoninternals.py:620
msgid "* Playlist snapshots."
msgstr "* Instantáneas de lista de reproducción."

#: ..\python_docs\spladdoninternals.py:621
msgid "* Track time analysis marker."
msgstr "* Marcador de análisis de tiempo de pista."

#: ..\python_docs\spladdoninternals.py:622
msgid "* Track time analysis."
msgstr "* Análisis de tiempo de pista."

#: ..\python_docs\spladdoninternals.py:623
msgid ""
"For these routines, an extra step is performed to make sure that SPL "
"Assistant flag is turned off automatically after the shortcut for these "
"routines are pressed. Without this step, you might end up with a situation "
"like the following:"
msgstr ""
"En estos procedimientos, se lleva a cabo un paso adicional para asegurarse "
"de que el indicador del asistente de SPL se apaga automáticamente tras "
"pulsar el atajo de teclado en cuestión. Sin este paso, podrías acabar en una "
"situación como la siguiente:"

#: ..\python_docs\spladdoninternals.py:624
msgid "1. You invoke Assistant layer."
msgstr "1. Invocas la capa del asistente."

#: ..\python_docs\spladdoninternals.py:625
msgid ""
"2. You then press the shortcut key (not the layer counterpart) for the layer "
"command you wish to use."
msgstr ""
"2. Después pulsas la tecla rápida para la orden de capa que quieras usar "
"(sin activar la capa antes)."

#: ..\python_docs\spladdoninternals.py:626
msgid ""
"3. You press another key which may announce something else, or you hear the "
"same thing twice if you do press the layer command counterpart to the "
"command you have pressed. In effect, you have invoked two layer commands in "
"one sitting (the purpose of the layer set is to let you hear one "
"announcement at a time)."
msgstr ""
"3. Pulsas otra tecla que puede verbalizar algo más, o incluso oyes lo mismo "
"dos veces si pulsas el atajo de la capa homólogo a la orden que has pulsado. "
"En efecto, has invocado dos órdenes de capa de una vez (el propósito del "
"conjunto de capas es dejarte oír un mensaje a la vez)."

#: ..\python_docs\spladdoninternals.py:627
msgid ""
"## Introducing configuration facilities: add-on settings dialog and "
"broadcast profiles"
msgstr ""
"## Presentación de las funciones de configuración: diálogo de ajustes del "
"complemento y perfiles de emisión"

#: ..\python_docs\spladdoninternals.py:628
msgid ""
"We have arrived at our last station stop for Studio app module internals: "
"configuration management. This facility allows a broadcaster to configure "
"various options such as alarms, column announcement order and so on, as well "
"as package settings for a show as a broadcast profile to be invoked during "
"the show. Along the way you'll learn how NVDA screen reader stores various "
"settings, what happens if something goes wrong and get into internals of how "
"broadcast profiles work."
msgstr ""
"Hemos llegado a nuestra última parada del módulo de aplicación de Studio "
"visto por dentro: gestión de la configuración. Esta característica permite "
"que un locutor configure diversas opciones, como alarmas, orden de "
"verbalización de columnas y demás, así como empaquetar ajustes para un "
"programa como un perfil de emisión para invocarlo durante el programa. "
"Durante el camino aprenderás cómo almacena el lector de pantalla NVDA "
"diversos ajustes, qué pasa si algo va mal y verás cómo están hechos por "
"dentro los perfiles de emisión."

#: ..\python_docs\spladdoninternals.py:629
msgid "### ConfigObj: NVDA's configuration manager assistant"
msgstr "### ConfigObj: asistente de gestión de la configuración de NVDA"

#: ..\python_docs\spladdoninternals.py:630
msgid ""
"NVDA uses ConfigObj library to manage settings. This Python module, inspired "
"by Python's own Config Parser, allows developers to store settings in a text "
"file, read and interpret settings and validate options against default "
"configuration options."
msgstr ""
"NVDA usa la biblioteca ConfigObj para gestionar sus ajustes. Este módulo "
"Python, inspirado en el propio intérprete de configuración de Python, "
"permite que los desarrolladores almacenen ajustes en un fichero de texto, "
"leer e interpretar ajustes y validar opciones basándose en opciones de "
"configuración por defecto."

#: ..\python_docs\spladdoninternals.py:631
msgid ""
"NVDA comes with a collection of default options. They live in source/config/"
"__init__ and are used for various things, including presenting preferences, "
"validating user configuration and so on. The config management module also "
"includes facilities to handle profiles (a package of user settings to be "
"used in an app, during say all or reserved for manual activation)."
msgstr ""
"NVDA viene con una colección de opciones por defecto. Estas residen en "
"source/config/__init__ y se emplean para varias cosas, incluyendo la "
"presentación de preferencias, validación de configuración de usuario y "
"demás. El módulo de gestión de configuración también incluye funciones para "
"gestionar perfiles (un paquete de ajustes de usuario que se emplea en una "
"aplicación, al verbalizar todo o se reserva para activación manual)."

#: ..\python_docs\spladdoninternals.py:632
msgid ""
"### NVDA configuration profiles: multiple configuration files, one online "
"database"
msgstr ""
"### Perfiles de configuración de NVDA: varios archivos de configuración, una "
"única base de datos en línea"

#: ..\python_docs\spladdoninternals.py:633
msgid ""
"A number of users asked NV Access if it would be possible to have profiles "
"where certain settings can take effect while one is using apps or during say "
"all. NV Access listened and introduced configuration profiles in late 2013. "
"As of August 2015, one can create a manual or an automated (triggered) "
"profile, with the latter further divided into say all profile and app-"
"specific one."
msgstr ""
"Muchos usuarios preguntaron a NV Access si sería posible perfiles donde "
"ciertos ajustes tengan efecto mientras se esté usando una aplicación o la "
"función de verbalizar todo. NV Access escuchó e introdujo los perfiles de "
"configuración ya entrado 2013. Desde agosto de 2015, se pueden crear perfil "
"manual o automático (disparado), con estos últimos divididos en perfiles de "
"verbalizar todo y específicos de una aplicación."

#: ..\python_docs\spladdoninternals.py:634
msgid ""
"Configuration profiles involve a few support routines and a careful "
"coordination between configuration files. In essence, each configuration "
"profile (stored in profiles folder in user configuration folder) is a "
"snapshot of differences between the profile and the main user configuration "
"file (named nvda.ini). When a profile becomes active, NVDA will load the "
"profile file associated with the given profile and modify user settings "
"according to values stored in the newly activated profile, and wwill record "
"the name of the profile file to remind itself as to which profile is active "
"(the default user configuration profile is named \"normal configuration\" "
"with the file name of nvda.ini)."
msgstr ""
"Los perfiles de configuración implican unos cuantos procedimientos de "
"soporte y una cuidadosa coordinación entre archivos de configuración. En "
"esencia, cada perfil de configuración (almacenado en la carpeta profiles en "
"el directorio de configuración de usuario) es una instantánea de diferencias "
"entre el perfil y el archivo de configuración principal del usuario (llamado "
"nvda.ini). Cuando un perfil se activa, NVDA cargará el archivo de perfil "
"asociado con el perfil dado y modificará los ajustes del usuario en función "
"de los valores almacenados en el perfil recién activado. También registrará "
"el nombre del archivo de perfil para recordarse a sí mismo qué perfil está "
"activo (el perfil de configuración por defecto del usuario se llama "
"\"Configuración normal\" y tiene como nombre de archivo nvda.ini)."

#: ..\python_docs\spladdoninternals.py:635
msgid ""
"What if settings had errors? As part of the startup routine (portions of "
"main function (source/core.py) prior to entering the main loop), NVDA will "
"display a configuration error dialog if it detects serious issues with "
"configuration values (in reality, ConfigObj notifies NVDA of this problem). "
"You'll see this is also implemented in the Studio app module to deal with "
"add-on configuration issues."
msgstr ""
"¿Y si los ajustes tuvieran errores? Como parte del procedimiento de "
"inicialización (partes de la función principal (source/core.py) antes de "
"entrar en el bucle principal), NVDA mostrará un diálogo de error de "
"configuración si detecta problemas serios con los valores de configuración "
"(en realidad, ConfigObj notifica a NVDA de este problema). Verás que esto "
"también está implementado en el módulo de aplicación de Studio para tratar "
"con los problemas de configuración del complemento."

#: ..\python_docs\spladdoninternals.py:636
msgid "### All about StationPlaylist add-on Configuration Manager"
msgstr ""
"### Todo sobre el gestor de configuración del complemento StationPlaylist"

#: ..\python_docs\spladdoninternals.py:637
msgid ""
"Until recently, Studio app module handled all add-on configuration routines. "
"With the advent of add-on 5.0 which introduced add-on settings dialog, "
"configuration management routines were split into a dedicated Configuration "
"Manager (splstudio.splconfig). The new module takes care of configuration "
"routines, including validating the user configuration, presenting add-on "
"settings dialog and other dialogs inside it, handling broadcast profiles and "
"more. In add-on 7.0, routines pertaining to configuration dialog were split "
"into splconfui module, with the main add-on settings listed under NVDA "
"preferences menu."
msgstr ""
"Hasta hace poco, el módulo de aplicación de Studio se encargaba de la "
"gestión de la configuración del complemento. Con la llegada del complemento "
"5.0 y el diálogo de ajustes del complemento, los procedimientos de gestión "
"de configuración se movieron a un gestor de configuración dedicado "
"(splstudio.splconfig). El nuevo módulo se encarga de las funciones de "
"configuración, incluida su validación, la presentación del diálogo de "
"ajustes del complemento y otros diálogos dentro de él, la gestión de "
"perfiles de emisión y más. En el complemento 7.0, los procedimientos "
"pertenecientes al diálogo de configuración se movieron al módulo splconfui, "
"estando los ajustes principales del complemento listados en el menú de "
"preferencias de NVDA."

#: ..\python_docs\spladdoninternals.py:638
msgid "### How settings are loaded, used and saved"
msgstr "### Cómo se cargan, se usan y se guardan los ajustes"

#: ..\python_docs\spladdoninternals.py:639
msgid ""
"As mentioned in the chapter on life of the Studio app module, one of the "
"things the app module does is load the add-on configuration database by "
"calling splconfig.initialize function. The job of this function is to load "
"the add-on configuration map from various places (for add-on 5.x, it will be "
"the main configuration map only, while 6.0 also searches appModules/profiles "
"folder to load broadcast profiles). The format of the configuration file is "
"that of a typical ini file, and as far as NVDA is concerned, it is a "
"dictionary."
msgstr ""
"Como se menciona en el capítulo que habla del ciclo de vida del módulo de "
"aplicación de Studio, una de las cosas que el módulo de aplicación hace es "
"cargar la base de datos con la configuración del complemento llamando a la "
"función splconfig.initialize. El trabajo de esta función es cargar el mapa "
"de configuración del complemento de diversos lugares (en el complemento 5.x, "
"será sólo el mapa de configuración principal, mientras que el 6.0 también "
"busca en la carpeta appModules/profiles para cargar los perfiles de "
"emisión). El formato del archivo de configuración es el de un archivo ini "
"típico, y tal y como NVDA está concebido, se trata de un diccionario."

#: ..\python_docs\spladdoninternals.py:640
msgid ""
"When the configuration database is ready, Studio app module will then use "
"values stored in this settings dictionary to perform various tasks, "
"including microphone alarm, announcing listener count and so on. If multiple "
"profiles are defined, NVDA will start with the first configuration map "
"(normal profile), and the active profile is denoted by splconfig.SPLConfig "
"map (more on profiles in a moment)."
msgstr ""
"Cuando la base de datos de configuración está lista, el módulo de aplicación "
"empleará los valores almacenados en este diccionario de ajustes para llevar "
"a cabo diversas tareas, incluyendo la alarma del micrófono, verbalización "
"del número de oyentes y demás. Si se han definido varios perfiles, NVDA "
"empezará con el primer mapa de configuración (perfil normal), y el perfil "
"activo irá determinado por el mapa splconfig.SPLConfig (más sobre los "
"perfiles en un momento)."

#: ..\python_docs\spladdoninternals.py:641
msgid ""
"After you are done using Studio, close Studio so settings can be saved to "
"disk. This involves saving individual profiles, copying global settings to "
"the normal profile and saving the normal profile to disk."
msgstr ""
"Después de que acabes de usar Studio, ciérralo para que los ajustes puedan "
"guardarse a disco. Esto implica guardar perfiles individuales, copiar los "
"ajustes globales al perfil normal y guardar el perfil normal a disco."

#: ..\python_docs\spladdoninternals.py:642
msgid "### The StationPlaylist Add-on Settings Dialog"
msgstr "### El diálogo de ajustes del complemento StationPlaylist"

#: ..\python_docs\spladdoninternals.py:643
msgid ""
"Studio app module allows you to configure various settings in two ways: via "
"a shortcut key (discussed in a section on configuring basic settings) or via "
"the settings dialog. When you use a shortcut key to change settings, NVDA "
"will look up the value for the setting, change it, announce the new setting "
"and store the newly changed value in the settings map."
msgstr ""
"El módulo de aplicación de Studio te permite configurar diversos ajustes de "
"dos formas: mediante un atajo de teclado (expuesto en una sección que habla "
"de configurar ajustes básicos), o mediante el diálogo de ajustes. Cuando "
"usas un atajo de teclado para cambiar ajustes, NVDA buscará el valor para el "
"ajuste, lo cambiará, verbalizará el nuevo ajuste y almacenará el valor "
"recién cambiado en el mapa de ajustes."

#: ..\python_docs\spladdoninternals.py:644
msgid ""
"Alternatively, you can configure settings via the add-on settings dialog (Alt"
"+NVDA+0). As it is a settings dialog (powered by gui.SettingsDialog), it "
"will look just like any NVDA preferences dialog. For some advanced options, "
"this dialog is the only gateway to access them (covered below)."
msgstr ""
"Alternativamente, puedes configurar los ajustes mediante el diálogo de "
"ajustes del complemento (alt+NVDA+0). Como es un diálogo de preferencias "
"(proporcionado por gui.SettingsDialog), será muy parecido a todos los "
"diálogos de preferencias de NVDA. Este diálogo es la única puerta para "
"llegar a algunas opciones avanzadas (explicadas debajo)."

#: ..\python_docs\spladdoninternals.py:645
msgid ""
"Until 2018, add-on settings were divided into various dialogs. With the "
"release of NVDA 2018.2, it became possible to house all settings under one "
"roof, divided into various settings panels. Visually, it resembles a two-"
"column layout, with the left column showing a list of settings categories, "
"and the right column displaying settings for the chosen category. See below "
"for notes on multi-category settings."
msgstr ""
"Hasta 2018, las opciones del complemento estaban divididas en varios "
"diálogos. Con la llegada de NVDA 2018.2, se hizo posible alojar todas las "
"opciones bajo un mismo techo, divididas en diversos paneles de ajustes. "
"Visualmente, recuerda a una disposición en dos columnas, teniendo la columna "
"de la izquierda una lista de categorías de opciones, y la columna derecha "
"mostrando los ajustes de la categoría elegida. Mira más abajo para ver notas "
"sobre las opciones multicategoría."

#: ..\python_docs\spladdoninternals.py:646
msgid ""
"In 2020, broadcast profiles management was split into its own dialog. Prior "
"to this split, most add-on settings panels relied on broadcast profiles "
"panel for synchronization and updating their controls. This created "
"complications, especially when panels other than broadcast profiles were "
"opened directly. To avoid this issue and to make panels independent of each "
"other, broadcast profiles dialog was born."
msgstr ""
"En 2020, la gestión de perfiles de emisión se separó en su propio diálogo. "
"Antes de esta división, la mayoría de paneles de opciones del complemento se "
"apoyaban en el panel de perfiles de emisión para sincronizar y actualizar "
"sus controles. Esto creaba complicaciones, especialmente cuando se abrían "
"directamente paneles que no fueran el de perfiles de emisión. Para evitar "
"este problema y hacer los paneles independientes entre sí, nació el diálogo "
"de perfiles de emisión."

#: ..\python_docs\spladdoninternals.py:647
msgid ""
"The add-on settings dialog (splconfui.SPLConfigDialog) contains following "
"options:"
msgstr ""
"El diálogo de ajustes del complemento (splconfui.SPLConfigDialog) contiene "
"las siguientes opciones:"

#: ..\python_docs\spladdoninternals.py:648
msgid ""
"* Global settings: these are settings not affected by profiles. These "
"include status announcements, announcing listener count, library scan "
"options and so on."
msgstr ""
"* Ajustes globales: son ajustes a los que no les afectan los perfiles. Estos "
"incluyen anuncios de estado, verbalización del número de oyentes, opciones "
"del escaneo de biblioteca y demás."

#: ..\python_docs\spladdoninternals.py:649
msgid ""
"* Profile-specific settings: Currently alarms, metadata streaming and column "
"announcement settings are profile-specific. These are end of track alarm and "
"the option to use this alarm, song ramp (intro) time and the setting to use "
"this alarm, microphone alarm and microphone alarm interval. It also includes "
"URL's for metadata streaming and column announcement order and inclusion. "
"For numeric settings such as alarm value, it is a spin control (wx.SpinCtrl; "
"use up or down arrow keys to change them)."
msgstr ""
"* Ajustes específicos del perfil: actualmente las alarmas, el flujo de "
"metadatos y los ajustes de verbalización de columnas son específicos del "
"perfil. Estos son la alarma de fin de pista y la opción para usarla, la "
"alarma de introducción y el ajuste para usarla, la alarma del micrófono y el "
"intervalo de alarma de micrófono. También se incluyen URLS para flujo de "
"metadatos y orden de verbalización e inclusión de columnas. Para los ajustes "
"numéricos como el valor de la alarma, se muestra un botón giratorio (wx."
"SpinCtrl; usa las flechas arriba y abajo para cambiarlos)."

#: ..\python_docs\spladdoninternals.py:650
msgid ""
"* Reset settings: NVDA will ask if you wish to reset settings in the "
"currently active profile back to factory defaults. This is done by using a "
"function in splconfig module (splconfig.resetConfig) that will set current "
"profile values to defaults (a default configuration map is included for this "
"purpose; this map uses a configuration specification (confspec, part of "
"defining validation routine via validator module (a close friend of "
"ConfigObj), and this confspec is defined in the splconfspec module)."
msgstr ""
"* Restablecer ajustes: NVDA te preguntará si quieres restablecer los ajustes "
"del perfil activo actualmente a los que vienen por defecto de fábrica. Esto "
"se hace usando una función en el módulo splconfig (splconfig.resetConfig) "
"que establecerá los valores del perfil actual a los que vienen por defecto "
"(con este propósito se incluye un mapa con la configuración por defecto; "
"este mapa usa una especificación de configuración (confspec, parte de la "
"definición del proceso de validación mediante el módulo validator (un amigo "
"cercano de ConfigObj), la confspec se define en el módulo splconfspec)."

#: ..\python_docs\spladdoninternals.py:651
msgid ""
"When you press Alt+NVDA+0 from Studio to open this dialog, the following "
"will happen:"
msgstr ""
"Cuando pulses alt+NVDA+0 desde Studio para abrir este diálogo, ocurrirá lo "
"siguiente:"

#: ..\python_docs\spladdoninternals.py:652
msgid ""
"1. Just like alarm dialogs (see above), NVDA will make sure no other dialogs "
"are open."
msgstr ""
"1. Al igual que con los diálogos de alarma (mira los artículos anteriores), "
"NVDA se asegurará de que no hay otros diálogos abiertos."

#: ..\python_docs\spladdoninternals.py:653
msgid ""
"2. It'll then call a function in splconfui module, which in turn will "
"prepare the dialog to be shown."
msgstr ""
"2. Después llamará a una función en el módulo splconfui, que se encargará de "
"preparar el diálogo a mostrar."

#: ..\python_docs\spladdoninternals.py:654
msgid ""
"3. The preparation routine (SettingsDialog.makeSettings) will populate the "
"dialog with controls and options associated with each control, with current "
"options coming from configuration values stored in the active profile."
msgstr ""
"3. El procedimiento de preparación (SettingsDialog.makeSettings) poblará el "
"diálogo con controles y opciones asociadas con cada control. Las opciones "
"actuales vendrán de los valores de configuración almacenados en el perfil "
"activo."

#: ..\python_docs\spladdoninternals.py:655
msgid ""
"4. Once the dialog is ready, it'll pop up and you'll land on \"General add-"
"on settings\" button (formerly status message checkbox) or list of active "
"profiles depending on the add-on version and add-on command-line switches "
"(former is 5.x or restrictions on loading profiles is in place, latter is "
"6.0 and no restrictions). You can then use typical dialog navigation "
"commands to navigate through various options."
msgstr ""
"4. Una vez el diálogo esté listo, aparecerá y aterrizarás en el botón "
"\"Ajustes generales del complemento\" (anteriormente la casilla de "
"verificación del mensaje de estado) o en la lista de perfiles activos, según "
"la versión del complemento que tengas y los argumentos de la línea de "
"órdenes del complemento (lo primero pasa en la 5.x o cuando haya "
"restricciones en la carga de perfiles, lo segundo en la 6.0 y sin "
"restricciones). A partir de ahí ya puedes usar órdenes estándar de "
"navegación por diálogos para desplazarte por las distintas opciones."

#: ..\python_docs\spladdoninternals.py:656
msgid ""
"After configuring some settings, click OK or Apply. NVDA will then locate "
"the selected profile and tell SPLConfig to use this profile, then store "
"options from the settings dialog into the configuration map. If Apply button "
"is pressed and if the selected profile is not the active one, NVDA will "
"present a message reminding users that settings will be saved to the profile "
"selected from settings dialog, not the active one at the moment. After that, "
"changes will be saved and add-on settings will reappear."
msgstr ""
"Después de configurar algunos ajustes, haz clic en aceptar o aplicar. NVDA "
"localizará a continuación el perfil seleccionado y pedirá a SPLConfig que "
"use este perfil, luego almacenará las opciones del diálogo de ajustes dentro "
"del mapa de configuración. Si se pulsa el botón aplicar y el perfil "
"seleccionado no es el perfil activo, NVDA mostrará un mensaje recordando a "
"los usuarios que los ajustes se guardarán en el perfil seleccionado en el "
"diálogo de ajustes, y no en el que esté activo en ese momento. Después de "
"eso, se guardarán los cambios y reaparecerán los ajustes del complemento."

#: ..\python_docs\spladdoninternals.py:657
msgid ""
"In case you discard new settings (clicking Cancel), NVDA will check to see "
"if an instant switch profile is defined, and if so, it'll perform various "
"operations depending on whether the instant profile has been renamed or "
"deleted."
msgstr ""
"En el caso de que descartes los nuevos ajustes (haciendo clic en cancelar), "
"NVDA comprobará si se ha definido un perfil de cambio instantáneo, y si es "
"así, realizará varias operaciones dependiendo de si el perfil instantáneo se "
"ha renombrado o eliminado."

#: ..\python_docs\spladdoninternals.py:658
msgid "#### Multi-category settings"
msgstr "#### Ajustes en varias categorías"

#: ..\python_docs\spladdoninternals.py:659
msgid ""
"The description above refers to the old add-on settings interface, which was "
"based on old NVDA settings routines. In the past, there were discussions "
"between add-on users regarding changing the current add-on interface to that "
"of a multi-category settings interface so all add-on settings can be found "
"under one roof."
msgstr ""
"La descripción anterior se refiere a la interfaz antigua de ajustes del "
"complemento, que estaba basada en las funciones antiguas de ajustes de NVDA. "
"En el pasado hubo debates entre los usuarios del complemento relacionados "
"con cambiar la interfaz actual del complemento a una interfaz agrupada en "
"categorías de tal forma que todos los ajustes del complemento se encuentren "
"bajo un mismo techo."

#: ..\python_docs\spladdoninternals.py:660
msgid ""
"In the old days, if one wanted to change settings in NVDA, one would open "
"NVDA's preferences menu and hunt for correct dialog. For instance, when "
"changing browse mode related settings, the place to go was NVDA menu/"
"Preferences/Browse Mode. This meant settings were scattered throughout "
"different dialogs."
msgstr ""
"En los viejos tiempos, si se querían modificar ajustes en NVDA, había que "
"abrir el menú de preferencias de NVDA y elegir el diálogo correcto. Por "
"ejemplo, al cambiar los ajustes relacionados con el modo exploración, el "
"lugar al que ir era menú de NVDA / preferencias / modo exploración. Esto "
"significaba que la configuración estaba dispersa a lo largo de diferentes "
"diálogos."

#: ..\python_docs\spladdoninternals.py:661
msgid ""
"In 2018, a major paradigm shift occurred in NVDA's own user interface: multi-"
"category settings screen. In NVDA 2018.2, a new settings screen, combining "
"various dialogs into a panel, launched. For many settings, one can now open "
"NVDA Menu/Preferences/Settings, select the desired settings category, then "
"change settings. This also had the benefit of moving many settings under one "
"roof."
msgstr ""
"En 2018, se produjo un cambio importante en el paradigma de la propia "
"interfaz de usuario de NVDA: la pantalla de opciones en categorías. En NVDA "
"2018.2 se lanzó una nueva pantalla de ajustes, combinando varios diálogos en "
"un panel. Para muchos ajustes, ahora se puede abrir el menú de NVDA / "
"preferencias / opciones, seleccionar la categoría de ajustes deseada, y "
"luego cambiar los ajustes. Esto también tuvo el beneficio de mover muchos "
"ajustes bajo un solo techo."

#: ..\python_docs\spladdoninternals.py:662
msgid ""
"As a follow-up to this development, StationPlaylist add-on settings has "
"undergone a major facelift. As noted throughout this article, add-on "
"settings are housed under various dialogs, with the main add-on settings "
"dialog serving as a gateway to these dialogs. In 2018, this has changed into "
"a multi-category settings screen."
msgstr ""
"Como un seguimiento a este desarrollo, los ajustes del complemento de "
"StationPlaylist están sufriendo un lavado de cara. Como se observa a lo "
"largo de este artículo, los ajustes del complemento se alojan bajo diversos "
"diálogos, sirviendo el diálogo principal de ajustes del complemento como una "
"puerta hacia estos diálogos. En 2018, esto se ha convertido en una pantalla "
"de ajustes con varias categorías."

#: ..\python_docs\spladdoninternals.py:663
msgid "### All about broadcast profiles"
msgstr "### Todo sobre los perfiles de emisión"

#: ..\python_docs\spladdoninternals.py:664
msgid ""
"In Studio app module world, a broadcast profile (usually shortened to "
"profile) is a group of settings to be used in a show. This is achieved by "
"using a configuration profile container (splconfig.SPLConfigPool for add-on "
"6.x and 7.x, splconfig.SPLConfig.profiles for 8.0 and later) for storing "
"these profiles, and one of them is used at any given time (by default, the "
"first profile)."
msgstr ""
"En el mundo del módulo de aplicación de Studio, un perfil de emisión (o "
"simplemente perfil, para abreviar) es un grupo de ajustes que se usan en un "
"programa. Esto se lleva a cabo empleando un contenedor de perfiles de "
"configuración (splconfig.SPLConfigPool en los complementos 6.x y 7.x, "
"splconfig.SPLConfig.profiles en 8.0 y posteriores) para almacenar estos "
"perfiles, uno de ellos se usa durante un tiempo específico (por defecto, el "
"primer perfil)."

#: ..\python_docs\spladdoninternals.py:665
msgid ""
"There are two ways of creating a profile: brand new or as a copy. Both uses "
"the same dialog (splconfui.NewProfileDialog), with the difference being the "
"base profile in use. For a brand new profile, settings from the normal "
"profile will be used (minus profile-specific settings, which are set to "
"default values), and for a copy, the new profile will contain all settings "
"from the base profile. In both cases, a memory resident profile will be "
"created and initialized just like other profiles (splconfig.unlockConfig/"
"splconfig.SPLConfig.createProfile, taking the name of the new profile as a "
"parameter); this was done to reduce unnecessary disk writes. Also, new/copy "
"profile dialog (and other dialogs invoked from the main configuration "
"dialog) will disable the main settings dialog."
msgstr ""
"Hay dos formas de crear un perfil: partiendo desde cero o como una copia. "
"Ambas formas usan el mismo diálogo (splconfui.NewProfileDialog), siendo la "
"única diferencia el perfil de partida que se usa. Para un nuevo perfil desde "
"cero, se usarán los ajustes del perfil normal (excepto los ajustes "
"específicos del perfil, para los que se establecen valores por defecto), y "
"para la copia, el nuevo perfil contendrá todos los ajustes del perfil de "
"partida. En ambos casos, se creará un perfil residente en memoria y se "
"iniciará como cualquier otro perfil (splconfig.unlockConfig/splconfig."
"SPLConfig.createProfile, que reciben el nombre de perfil como parámetro); "
"esto se hizo para reducir escrituras innecesarias en disco. Además, el "
"diálogo de nuevo perfil o copiar perfil (y otros diálogos invocados desde el "
"diálogo principal de configuración) deshabilitarán el diálogo principal de "
"ajustes."

#: ..\python_docs\spladdoninternals.py:666
msgid ""
"In case the selected profile is deleted, the profile will be removed from "
"the profiles list, the configuration file associated with the profile will "
"be deleted (if it exists) and a previously active profile will take over "
"unless if the active profile itself is gone, in which case normal profile "
"will be set as the active profile. In case of a rename operation, it'll look "
"for a profile with the old name and change some properties to reflect name "
"change. There is an important step the app module will perform if an instant "
"switch profile is renamed or deleted (if renamed, the instant profile "
"variable will hold the new name, and if deleted, instant profile value will "
"be None). A similar procedure was invoked in older releases when dealing "
"with time-based profiles."
msgstr ""
"En caso de que el perfil seleccionado sea eliminado, este se quitará de la "
"lista de perfiles, se eliminará el archivo de configuración asociado al "
"perfil (si existe) y el perfil activo anteriormente tomará el control a "
"menos que sea el perfil activo el que se vaya, en cuyo caso el perfil normal "
"se establecerá como perfil activo. En caso de operaciones de renombrado, se "
"buscará un perfil con el nombre antiguo y se cambiarán algunas propiedades "
"para reflejar el cambio de nombre. Hay un paso muy importante que el módulo "
"de aplicación llevará a cabo si se renombra o se elimina un perfil de cambio "
"instantáneo (si se renombra, la variable del perfil instantáneo guardará el "
"nuevo nombre, y si se elimina, el valor del perfil instantáneo será None). "
"Se invocaba un procedimiento similar en versiones antiguas al tratar con "
"perfiles basados en tiempo."

#: ..\python_docs\spladdoninternals.py:667
msgid "#### Broadcast profiles dialog"
msgstr "#### El diálogo de perfiles de emisión"

#: ..\python_docs\spladdoninternals.py:668
msgid ""
"Inspired by NVDA screen reader's configuration profiles dialog, this dialog "
"(splconfui.BroadcastProfilesDialog) shows various profile management "
"controls. When you press Alt+NVDA+P to open this dialog, you'll be greeted "
"with  a list of profiles loaded and buttons to create a brand new profile or "
"a copy of an existing profile, rename and delete profiles. It also contains "
"a \"triggers\" button to configure profile triggers such as instant profile "
"switching."
msgstr ""
"Inspirado en el diálogo de perfiles de configuración del lector de pantalla "
"NVDA, este diálogo (splconfui.BroadcastProfilesDialog) muestra diversos "
"controles de gestión de perfiles. Al pulsar alt+NVDA+p para abrir este "
"diálogo, se mostrará una lista con perfiles cargados y botones para crear un "
"nuevo perfil o copiar un perfil existente, renombrar y eliminar perfiles. "
"También contiene un botón \"Disparadores\" para configurar disparadores de "
"perfiles, como cambio instantáneo."

#: ..\python_docs\spladdoninternals.py:669
msgid ""
"There is one more control: activate button. This button is disabled by "
"default if the selected profile is the active profile, becoming active "
"otherwise. Regardless of status of activate button, pressing Enter from "
"profiles list will activate the selected profile."
msgstr ""
"Hay un control más: el botón Activar. Este botón se encuentra deshabilitado "
"por defecto si el perfil seleccionado es el perfil activo, habilitándose en "
"cualquier otro caso. Dejando aparte el botón Activar, al pulsar intro desde "
"la lista de perfiles se activará el perfil seleccionado."

#: ..\python_docs\spladdoninternals.py:670
msgid ""
"But there are no OK and Cancel buttons - there is only a \"Close\" button. "
"How can a broadcast profile become \"active\" when you press Enter? This is "
"done by setting AffirmativeId to \"Activate\" button. In effect, \"activate"
"\" button acts as OK button, which will eventually call the handler "
"associated with \"close\" button."
msgstr ""
"Pero no hay botones Aceptar y Cancelar - tan sólo hay un botón \"Cerrar\". "
"¿Cómo se puede \"activar\" un perfil al pulsar intro? Esto se hace "
"configurando AffirmativeId en el botón \"Activar\". A efectos prácticos, el "
"botón \"Activar\" actúa como el botón \"Aceptar\", que eventualmente llama "
"al manejador asociado con el botón \"Cerrar\"."

#: ..\python_docs\spladdoninternals.py:671
msgid "#### Introducing Config Hub"
msgstr "#### Presentación del centro de configuración"

#: ..\python_docs\spladdoninternals.py:672
msgid ""
"In add-on 6.x and 7.x, a combination of SPLConfig map and the config pool "
"was used to allow users to switch between profiles. Because these were using "
"facilities provided by other modules, this meant custom variables such as "
"active profile flag had to live in splconfig module."
msgstr ""
"En los complementos 6.x y 7.x, se usaba una combinación del mapa SPLConfig y "
"la pool de configuración para permitir a los usuarios cambiar entre "
"perfiles. Debido a que se apoyaban en funciones proporcionadas por otros "
"módulos, algunas variables personalizadas como el indicador del perfil "
"activo debían residir en el módulo splconfig."

#: ..\python_docs\spladdoninternals.py:673
msgid ""
"To solve this problem and to allow centralized profile management, a concept "
"of Configuration Hub (ConfigHub) was introduced in add-on 8.0. Inspired by "
"NVDA's own configuration management facility and powered by Chain Map (a "
"dictionary that holds multiple lookup maps), this class not only stores list "
"of currently loaded profiles and the dictionary representing current "
"settings, it also houses various records such as name of the active profile, "
"a history of previously activated profiles and so on, as well as support "
"routines for profile management."
msgstr ""
"Para resolver este problema y permitir una gestión centralizada de perfiles, "
"se introdujo el concepto de centro de configuración (ConfigHub) en el "
"complemento 8.0. Inspirado por el propio sistema de gestión de configuración "
"de NVDA y potenciado por un mapa en cadena (un diccionario que contiene "
"varios mapas de búsqueda), esta clase no sólo almacena la lista de perfiles "
"actualmente cargados y el diccionario que representa los ajustes actuales, "
"también aloja diversos registros como el nombre del perfil activo, un "
"historial de perfiles activados anteriormente y demás, así como "
"procedimientos de soporte para la gestión de perfiles."

#: ..\python_docs\spladdoninternals.py:674
msgid "The various changes due to introduction of Config Hub are:"
msgstr ""
"Los diversos cambios producidos al introducir el centro de configuración son:"

#: ..\python_docs\spladdoninternals.py:675
msgid ""
"* Switching profiles: no longer need to copy settings back and forth between "
"live config dictionary and the designated profile in the config pool. "
"Profile switching is simple as swapping new and old profile maps."
msgstr ""
"* Cambios de perfil: ya no existe la necesidad de copiar los ajustes de un "
"sitio a otro entre el diccionario de configuración activa y el perfil en "
"cuestión en la pool de configuración. El cambio de perfiles es tan simple "
"como intercambiar los mapas del antiguo y el nuevo perfil."

#: ..\python_docs\spladdoninternals.py:676
msgid "* A history of activated profiles is now kept inside this dictionary."
msgstr ""
"* Se guarda en este diccionario un historial de los perfiles activados."

#: ..\python_docs\spladdoninternals.py:677
msgid ""
"* It is possible to pass in additional options when creating a new profile, "
"such as whether it should be cached, validated now and so on."
msgstr ""
"* Es posible pasar opciones adicionales al crear un nuevo perfil, tales como "
"si debería meterse en caché, validarse en el momento y demás."

#: ..\python_docs\spladdoninternals.py:678
msgid "#### How does profile switching work"
msgstr "#### Cómo funciona el cambio de perfiles"

#: ..\python_docs\spladdoninternals.py:679
msgid "Note: information on time-based profile is included for completeness."
msgstr ""
"Nota: la información de perfiles basados en tiempo se incluye por "
"completitud."

#: ..\python_docs\spladdoninternals.py:680
msgid ""
"Besides switching to different profiles via broadcast profiles dialog, a "
"profile can be set to be switched to instantly during a live show. In older "
"releases, time-based profiles were supported in which NVDA will switch to a "
"designated broadcast profile just before the show starts."
msgstr ""
"Además de pasar a distintos perfiles mediante el diálogo de perfiles de "
"emisión, se puede configurar un perfil para que se active instantáneamente "
"durante un programa en directo. En versiones anteriores, se soportaban "
"perfiles basados en tiempo, que NVDA activaba justo antes de que empezara el "
"programa."

#: ..\python_docs\spladdoninternals.py:681
msgid ""
"An instant switch profile is a profile to be switched to if told by the "
"user. This is used before you connect to a streaming server to load settings "
"appropriate for a show (as of time of this writing, only one can be selected "
"as an instant switch profile; to define this profile, select a profile to be "
"used as a show, then go to profile switching button and select it)."
msgstr ""
"Un perfil de cambio instantáneo es un perfil al que se cambia si así lo "
"indica el usuario. Se suelen usar antes de conectar a un servidor de emisión "
"para cargar los ajustes apropiados para un programa (en el momento en que se "
"escribe esto, sólo puede elegirse un único perfil como perfil de cambio "
"instantáneo; para definirlo, selecciona el perfil de tu programa, ve al "
"botón de cambio de perfil y selecciónalo)."

#: ..\python_docs\spladdoninternals.py:682
msgid ""
"In contrast, a time-based profile is a special type of instant switch "
"profile that will be activated at a specific date and time. A separate map "
"(a pickle map) is employed to store settings related to these profiles, and "
"the user-facing options can be found in triggers dialog found in add-on "
"settings (see the next section for an overview of this dialog and the "
"configuration format for this map)."
msgstr ""
"En contraste, un perfil basado en tiempo es un tipo especial de perfil de "
"cambio instantáneo que se activará en la fecha y hora especificadas. Se "
"emplea un mapa separado (un mapa pickle) para almacenar los ajustes "
"relativos a estos perfiles, sus opciones de interfaz de usuario pueden "
"encontrarse en el diálogo de disparadores situado en los ajustes del "
"complemento (mira la siguiente sección para ver una descripción de este "
"diálogo y el formato de configuración de este mapa)."

#: ..\python_docs\spladdoninternals.py:683
msgid ""
"To activate an instant switch profile, press SPL Assistant, F12. For time-"
"based profile, it'll activate itself when it is time to do so (with help "
"from a countdown timer located in splmisc module). In ither case, the "
"switching procedure is as follows:"
msgstr ""
"Para activar un perfil de cambio instantáneo, pulsa asistente de SPL, f12. "
"Los perfiles basados en tiempo se activarán por sí solos cuando sea hora de "
"hacerlo (con la ayuda de un temporizador de cuenta atrás situado en el "
"módulo splmisc). En ambos casos, el procedimiento para cambiar el perfil es "
"el siguiente:"

#: ..\python_docs\spladdoninternals.py:684
msgid "1. Performs some checks, including:"
msgstr "1. Se hacen varias comprobaciones, entre ellas:"

#: ..\python_docs\spladdoninternals.py:685
msgid "\t* Checks if a switch profile (instant or time-based) is defined."
msgstr ""
"\t* Se comprueba si se ha definido un perfil de cambio (instantáneo o basado "
"en tiempo)."

#: ..\python_docs\spladdoninternals.py:686
msgid ""
"\t* For instant switch profiles, if a profile is defined, it'll make sure "
"you are not using the instant switch profile yet."
msgstr ""
"\t* Para los perfiles de cambio instantáneo, si hay alguno definido, se "
"comprueba que no lo estás usando todavía."

#: ..\python_docs\spladdoninternals.py:687
msgid "2. For add-on 7.x and earlier, saves the index of the active profile."
msgstr ""
"2. En los complementos 7.x y anteriores, se guarda el índice del perfil "
"activo."

#: ..\python_docs\spladdoninternals.py:688
msgid ""
"3. Locates the name of the switch profile and the profile associated with it "
"and switches to the switch profile (for add-on 7.x, reassigns SPLConfig to "
"use the switch profile; for 8.0 and later, swaps normal profile with the "
"instant profile map). At this point, NVDA may announce metadata streaming "
"status if told to do so when switching profiles, and with 17.12, made "
"simpler through an action extension point notifier that tells appropriate "
"functions to respond to profile switch action."
msgstr ""
"3. Se ubica el nombre del perfil de cambio y el perfil asociado a él, y se "
"cambia al perfil seleccionado (en el complemento 7.x, se reasigna SPLConfig "
"para que use el perfil de cambio; en el 8.0 y posteriores, se intercambian "
"los mapas del perfil normal y el perfil instantáneo). En ese momento, NVDA "
"puede verbalizar el estado de los metadatos del flujo si está configurado "
"para hacerlo al cambiar de perfil. En la versión 17.12, esto se ha "
"simplificado a través de un notificador de punto de extensión de acción que "
"indica a las funciones apropiadas que reaccionen ante la acción de cambio de "
"perfil."

#: ..\python_docs\spladdoninternals.py:689
msgid ""
"4. If no duration is specified for a time-based profile, NVDA will set next "
"switch time and date by calling splconfig.setNextTrigger, otherwise this is "
"delayed until the show is complete."
msgstr ""
"4. Si un perfil basado en tiempo no tiene una duración especificada, NVDA "
"establecerá la siguiente fecha y hora de cambio llamando a splconfig."
"setNextTrigger, en cualquier otro caso se espera a que el programa termine."

#: ..\python_docs\spladdoninternals.py:690
msgid ""
"5. If told to return to the previously active profile, it'll tell SPLConfig "
"to use the previously active profile (the index for the previously active "
"profile is located and is used to pull the profile with the given index from "
"the config pool)."
msgstr ""
"5. Si se indica que hay que volver al perfil previamente activo, SPLConfig "
"recibirá la orden de usar el perfil anterior (el índice para el perfil "
"activo anteriormente ya se había guardado y se usa para recuperar el perfil "
"de la pool de perfiles)."

#: ..\python_docs\spladdoninternals.py:691
msgid ""
"6. When deactivating a time-based profile, NVDA will now find out when the "
"next switch date and time will be."
msgstr ""
"6. Al desactivar un perfil basado en tiempo, NVDA averiguará cuándo serán "
"las próximas fecha y hora de activación."

#: ..\python_docs\spladdoninternals.py:692
msgid "#### Time-based switching fields and triggers dialog"
msgstr "#### El diálogo de disparadores y campos del cambio basado en tiempo"

#: ..\python_docs\spladdoninternals.py:693
msgid ""
"Note: this section is no longer applicable since 2020 but is kept for "
"historical reasons."
msgstr ""
"Nota: esta sección ya no es aplicable desde 2020, pero se conserva por "
"motivos históricos."

#: ..\python_docs\spladdoninternals.py:694
msgid ""
"For each time-based profile, a list with seven fields is employed to "
"describe trigger (switch) date and time. These are:"
msgstr ""
"Para cada perfil basado en tiempo, se emplea una lista con siete campos para "
"describir la fecha y hora del disparador (cambio). Son los siguientes:"

#: ..\python_docs\spladdoninternals.py:695
msgid ""
"* Trigger date (integer between 0 and 127): A 7-bit integer, denoting days "
"on which a given profile should be activated. This field is used in profile "
"triggers dialog to set or clear activation day checkboxes. A value of 0 "
"means the profile should not be activated, and if so, it is removed from the "
"triggers map."
msgstr ""
"* Fecha del disparador (entero entre 0 y 127): un entero de 7 bits, "
"indicando en cuántos días debería activarse un perfil. Este campo se usa en "
"el diálogo de disparadores de perfil para marcar o desmarcar las casillas de "
"verificación de días de activación. El valor 0 significa que el perfil no "
"debería activarse, y si es así, se elimina del mapa de disparadores."

#: ..\python_docs\spladdoninternals.py:696
msgid ""
"* Switch date and time (five integers): The first five fields used for "
"constructing datetime.datetime object (year, month, day, hour, minute) are "
"stored. This is used to let NVDA know when to switch profiles."
msgstr ""
"* Fecha y hora del cambio (cinco enteros): los cinco primeros campos usados "
"para construir datetime. El objeto datetime (año, mes, día, hora, minuto) se "
"almacena. Se usa para que NVDA sepa cuándo cambiar de perfil."

#: ..\python_docs\spladdoninternals.py:697
msgid ""
"* Duration (integer between 0 and 1439): An integer specifying the duration "
"of this profile (show) in minutes. This is mainly used by a timer that "
"becomes active when the profile in question becomes active, and the only job "
"of this timer is to switch back to another profile when the show is complete."
msgstr ""
"* Duración (entero entre 0 y 1439): un entero que especifica la duración de "
"este perfil (programa) en minutos. Lo usa principalmente un temporizador que "
"se activa al activarse el perfil en cuestión, y cuya única función es volver "
"a otro perfil cuando el programa se acabe."

#: ..\python_docs\spladdoninternals.py:698
msgid ""
"The triggers dialog, used to configure these fields for the selected "
"profile, consists of two groups of controls:"
msgstr ""
"El diálogo de disparadores, usado para configurar estos campos en el perfil "
"seleccionado, consta de dos grupos de controles:"

#: ..\python_docs\spladdoninternals.py:699
msgid ""
"* Trigger days: seven checkboxes, one for each day of the week. Checking or "
"clearing these boxes sets corresponding bits in the trigger date field."
msgstr ""
"* Días del disparador: siete casillas de verificación, una para cada día de "
"la semana. Al marcarlas o desmarcarlas se cambian los bits correspondientes "
"en el campo de fecha del disparador."

#: ..\python_docs\spladdoninternals.py:700
msgid ""
"* Switch time: three number entry fields denoting when to switch to this "
"profile (hour and minute) and the duration of this show (minutes)."
msgstr ""
"* Hora del cambio: tres campos de entrada numérica que indican cuándo se "
"debe cambiar al perfil (hora y minuto) y la duración del programa (en "
"minutos)."

#: ..\python_docs\spladdoninternals.py:701
msgid ""
"Once the data is gathered, NVDA will first check if trigger date checkboxes "
"are checked (if no checkboxes are checked, the profile is removed). Next, "
"NVDA will see if another profile has taken the given time slot, and if not, "
"will proceed to store the next trigger date and time (will not be saved "
"until OK button is clicked from the main add-on settings dialog)."
msgstr ""
"Una vez que se recopilan los datos, NVDA primero comprobará si están "
"marcadas las casillas de verificación de fecha del disparador (si no hay "
"ninguna marcada, se elimina el perfil). A continuación, NVDA comprobará si "
"otro perfil tiene asignada la misma franja de tiempo, y si no es así, "
"procederá a almacenar la fecha y hora del disparador (no se guardarán hasta "
"que se haga clic en el botón aceptar en el diálogo principal de ajustes del "
"complemento)."

#: ..\python_docs\spladdoninternals.py:702
msgid "#### Profile caching"
msgstr "#### Caché de perfiles"

#: ..\python_docs\spladdoninternals.py:703
msgid ""
"Note: profile caching was a core component of broadcast profiles management "
"from add-on 7.0 to 21.10 and is documented for historical reasons."
msgstr ""
"Nota: la caché de perfiles fue un componente clave en la gestión de perfiles "
"de emisión desde el complemento 7.0 hasta el 21.10, y se documenta por "
"motivos históricos."

#: ..\python_docs\spladdoninternals.py:704
msgid ""
"More recent computers ship with a type of drive called a solid-state drive "
"(sSD). This is the internal disk version of a high-quality flash drive that "
"is larger (physically and in capacity) than a typical USB flash drive. "
"Unlike a spinning hard drives, solid-state drives use flash memory to store "
"information, and therefore data can be read and written faster."
msgstr ""
"Los ordenadores más recientes vienen con un tipo de unidad llamada unidad de "
"estado sólido (SSD). Esta es la versión en disco interno de una unidad flash "
"de alta calidad mayor (físicamente y en capacidad) que una unidad flash USB "
"normal. Al contrario que los discos duros giratorios, las unidades de estado "
"sólido usan la memoria flash para almacenar información, y por tanto los "
"datos se pueden leer y escribir más rápido."

#: ..\python_docs\spladdoninternals.py:705
msgid ""
"One downside of an SSD is limited data writes. Flash memory can endure a "
"limited number of read and write cycles before data cannot be written to a "
"specific location. To avoid this, system software will do its best to store "
"new content across the entire disk so every location can store content (this "
"is called ware leveling)."
msgstr ""
"Una desventaja de los SSD es la limitación de escrituras de datos. La "
"memoria flash puede resistir un número limitado de ciclos de lectura y "
"escritura antes de que los datos no se puedan escribir en una ubicación "
"concreta. Para evitarlo, el software del sistema se esforzará en alojar el "
"nuevo contenido por todo el disco de tal forma que se distribuya por todas "
"las ubicaciones (esto se llama nivelación ware)."

#: ..\python_docs\spladdoninternals.py:706
msgid ""
"To help prolong SSD life, add-on 7.0 introduced broadcast profile caching. "
"Whenever profiles (including normal profile) are loaded from disk the first "
"time, a copy of settings stored in profiles is stored in an online cache, a "
"dictionary with profile names as keys, which in turn refers to the "
"dictionary view of profile settings. When profiles are saved, the contents "
"of the profile to be saved is compared to this online cache and the profile "
"contents will be written to disk if settings are changed. This assumption "
"takes advantage of the fact that users would not change add-on settings "
"every time Studio is used."
msgstr ""
"Para ayudar a prolongar la vida de los SSD, el complemento 7.0 introdujo una "
"caché de perfiles de emisión. Siempre que se cargan los perfiles desde disco "
"(incluyendo el perfil normal) por primera vez, se aloja una copia de los "
"ajustes de estos perfiles en una caché en línea, un diccionario que usa "
"nombres de perfiles como claves, que en cierto modo hacen referencia a la "
"vista de diccionario de los ajustes del perfil. Cuando los perfiles se "
"guardan, el contenido de cada perfil a guardar se compara con esta caché en "
"línea y sus contenidos se escriben en disco si las opciones han cambiado. "
"Esta suposición aprovecha el hecho de que los usuarios no cambian las "
"opciones del complemento cada vez que se usa Studio."

#: ..\python_docs\spladdoninternals.py:707
msgid ""
"At first profile caching was seen as a way to increase SSD life. But it was "
"later discovered that the caching mechanism made profile save procedure "
"complex. Further, the SSD technology is more robust in 2021 compared to the "
"first time profile caching was introduced (2016), therefore profile caching "
"mechanism was removed in add-on 21.10."
msgstr ""
"Al principio, la caché de perfiles se veía como una forma de aumentar la "
"vida de los SSD. Sin embargo, más tarde se descubrió que el mecanismo de "
"caché volvía complejo el procedimiento para guardar perfiles. Además, la "
"tecnología SSD es más robusta en 2021 comparada con la primera vez que se "
"introdujo la caché de perfiles (2016). Por tanto, el mecanismo de caché de "
"perfiles se eliminó en el complemento 21.10."

#: ..\python_docs\spladdoninternals.py:708
msgid ""
"This concludes a detailed tour of Studio app module internals. The rest of "
"the article will focus on SPL Studio Utilities global plugin, encoder "
"support and a few thoughts on how the add-on is developed, starting with a "
"tour of SPL Controller layer commands."
msgstr ""
"Así concluye un recorrido detallado por el interior del módulo de aplicación "
"de Studio. El resto de los capítulos se enfocarán en la extensión global de "
"utilidades de SPL, soporte del codificador y unas cuantas consideraciones "
"sobre cómo se desarrolla el complemento, comenzando con un recorrido por las "
"órdenes del controlador de SPL."

#: ..\python_docs\spladdoninternals.py:709
msgid ""
"## Introduction to SPL Utilities: SPLController and focusing to Studio window"
msgstr ""
"## Introducción a las utilidades de SPL: SPLController y cómo llevar el foco "
"a la ventana de Studio"

#: ..\python_docs\spladdoninternals.py:710
msgid ""
"Now that we've covered the \"kernel\" (innermost parts) of this add-on, it "
"is time to talk about the icing: SPL Utilities global plugins and its "
"contents."
msgstr ""
"Ahora que hemos cubierto el \"kernel\" (la parte más íntima) de este "
"complemento, es hora de hablar sobre la extensión global de utilidades de "
"SPL Studio y sus contenidos."

#: ..\python_docs\spladdoninternals.py:711
msgid ""
"Note: until 2019, encoder support was part of SPL Utilities, but it is now "
"part of SPL Engine app module which is covered next."
msgstr ""
"Nota: hasta 2019, el soporte de codificadores era parte de las utilidades de "
"SPL, pero ahora forma parte del módulo de aplicación del motor de SPL, que "
"se explica a continuación."

#: ..\python_docs\spladdoninternals.py:712
msgid "### Overview and global plugin contents"
msgstr "### Descripción y contenidos de la extensión global"

#: ..\python_docs\spladdoninternals.py:713
msgid ""
"As described in the add-on design section, SPL add-on comes with several app "
"modules and a global plugin. This was needed not only to differentiate "
"between module types and expertese, but also allow Studio functions to be "
"invoked from other programs."
msgstr ""
"Como se ha descrito en la sección de diseño del complemento, el complemento "
"de SPL viene con diversos módulos de aplicación y una extensión global. Esto "
"era necesario no sólo para diferenciar entre tipos de módulos y "
"experiencias, sino también para permitir que las funciones de Studio puedan "
"invocarse desde otros programas."

#: ..\python_docs\spladdoninternals.py:714
msgid ""
"Previously, SPL Utilities was also the home of encoder support routines, "
"introduced in fall 2014 with add-on 3.0. In 2020, encoder support module was "
"moved into its own app module named SPL Engine (splengine package)."
msgstr ""
"Anteriormente, las utilidades de SPL constituían el hogar de los "
"procedimientos de soporte del codificador, introducidos a finales de 2014 "
"con el complemento 3.0. En 2020, el módulo de soporte del codificador se ha "
"movido a su propio módulo de aplicación, conocido como motor de SPL (paquete "
"splengine)."

#: ..\python_docs\spladdoninternals.py:715
msgid ""
"The SPL Utilities global plugin is housed inside globalPlugins/splUtils/"
"__init__.py. The module consists of global plugin class, SPL Controller "
"driver and commands housed inside the class, and global constants used to "
"communiocate with Studio. It also includes a routine to switch focus to "
"Studio from anywhere."
msgstr ""
"La extensión global de utilidades de SPL se aloja en globalPlugins/splUtils/"
"__init__.py. El módulo consta de una clase de extensión global, el "
"controlador de SPL y órdenes alojadas dentro de la clase, así como "
"constantes globales usadas para comunicarse con Studio. También incluye un "
"procedimiento para desplazar el foco a Studio desde cualquier parte."

#: ..\python_docs\spladdoninternals.py:716
msgid "### SPL Controller layer"
msgstr "### La capa del controlador de SPL"

#: ..\python_docs\spladdoninternals.py:717
msgid ""
"The SPL Controller layer (entry command unassigned, same reason as the "
"Assistant layer entry command) is used to invoke Studio functions from "
"anywhere. The entry routine is similar to the app module counterpart (SPL "
"Assistant) except for the following:"
msgstr ""
"La capa del controlador de SPL (orden de entrada sin asignar, mismo motivo "
"que el de la orden de entrada al asistente de SPL) se usa para invocar "
"funciones de Studio desde cualquier sitio. El procedimiento de entrada es "
"similar a su homólogo del módulo de aplicación (el asistente de SPL) salvo "
"por lo siguiente:"

#: ..\python_docs\spladdoninternals.py:718
msgid ""
"* NVDA will make sure Studio is running (if so, it'll cache the window "
"handle value just as in the Studio app module), otherwise it cannot enter "
"SPL Controller layer."
msgstr ""
"* NVDA se asegurará de que Studio esté en ejecución (si es así, almacenará "
"en caché el valor del manejador de ventana al igual que en el módulo de "
"aplicación de Studio), en cualquier otro caso no se puede entrar en la capa "
"del controlador de SPL."

#: ..\python_docs\spladdoninternals.py:719
msgid ""
"* All commands (except two) use Studio API (Studio API and use of user32."
"dll's SendMessage was described in a previous section)."
msgstr ""
"* Todas las órdenes (excepto dos) usan la api de Studio (en un artículo "
"anterior se describió el funcionamiento de la api de Studio y la función "
"SendMessage de user32.dll)."

#: ..\python_docs\spladdoninternals.py:720
msgid ""
"For mechanics of layer commands, see section on add-on design where layer "
"commands were discussed."
msgstr ""
"Para ver los mecanismos de las órdenes de capa, consulta un artículo "
"anterior que hablaba del diseño del complemento, donde se expusieron estas "
"órdenes."

#: ..\python_docs\spladdoninternals.py:721
msgid "The following commands utilize Studio API:"
msgstr "Las siguientes órdenes utilizan la api de Studio:"

#: ..\python_docs\spladdoninternals.py:722
msgid "* A/Shift+A: Automation on/off."
msgstr "* A/Shift+A: activar o desactivar automatización."

#: ..\python_docs\spladdoninternals.py:723
msgid "* L/Shift+L: Line in on/off."
msgstr "* L/Shift+L: activar o desactivar entrada de línea."

#: ..\python_docs\spladdoninternals.py:724
msgid "* M/Shift+M/N: Microphone on/off/instant on/off toggle."
msgstr ""
"* M/Shift+M/N: activar o desactivar micrófono, o conmutador instantáneo para "
"encenderlo y apagarlo."

#: ..\python_docs\spladdoninternals.py:725
msgid "* P: Play."
msgstr "* P: reproducir."

#: ..\python_docs\spladdoninternals.py:726
msgid ""
"* Q: Obtain various status information. Due to API changes, this command "
"works better in studio 5.20 and later.)"
msgstr ""
"* Q: obtener diversa información de estado (debido a cambios en la api, esta "
"orden funciona mejor en Studio 5.20 y posteriores.)"

#: ..\python_docs\spladdoninternals.py:727
msgid "* R: Remaining time for the currently playing track (if any)."
msgstr ""
"* R: tiempo restante de la pista actualmente en reproducción (si la hay)."

#: ..\python_docs\spladdoninternals.py:728
msgid "* Shift+R: Library scan progress and umber of items scanned."
msgstr ""
"* Shift+r: progreso del escaneo de biblioteca y cantidad de elementos "
"escaneados."

#: ..\python_docs\spladdoninternals.py:729
msgid "* S/T: Stop with fade/instant stop."
msgstr "* S/T: parar progresivamente o parar de forma instantánea."

#: ..\python_docs\spladdoninternals.py:730
msgid "* U: Play/pause."
msgstr "* U: reproducir / pausar."

#: ..\python_docs\spladdoninternals.py:731
msgid ""
"For readers familiar with Studio keyboard commands, you'll find yourself at "
"home (they are indeed Studio commands except pressing Shift will turn a "
"feature off and Shift+R will remind you of Control+Shift+R for library scan "
"from Insert Tracks dialog). The letter \"Q\" stands for \"query Studio status"
"\"."
msgstr ""
"Los lectores familiarizados con las órdenes te teclado de Studio se sentirán "
"como en casa (en cierto modo estas son órdenes de Studio, salvo porque shift "
"se usa para desactivar algunas características, y shift+r te recordará al "
"ctrl+shift+r que se usa para escanear desde el diálogo de inserción de "
"pistas). La letra Q se queda para \"Consultar el estado de Studio"
"\" (consultar, en inglés, es query)."

#: ..\python_docs\spladdoninternals.py:732
msgid "Here are the two exceptions"
msgstr "Estas son las dos excepciones"

#: ..\python_docs\spladdoninternals.py:733
msgid ""
"* E: NVDA will search for and announce connection status of encoders. This "
"is done by locating top-level windows for various encoder windows and using "
"EnumChildWindows to look for actual encoders list."
msgstr ""
"* E: NVDA buscará y anunciará el estado de conexión de los codificadores. "
"Esto se hace ubicando las ventanas de más alto nivel y buscando diversas "
"ventanas de codificadores, para a continuación obtener la lista real de "
"codificadores llamando a EnumChildWindows."

#: ..\python_docs\spladdoninternals.py:734
msgid ""
"* F1: Opens a browse mode document displaying Controller layer commands "
"(does this sound familiar?)."
msgstr ""
"* F1: abre un documento en modo exploración que muestra las órdenes de la "
"capa del controlador (¿Te suena familiar?)."

#: ..\python_docs\spladdoninternals.py:735
msgid "### Focusing to Studio window from anywhere"
msgstr "### Cómo llevar el foco a la ventana de Studio desde cualquier parte"

#: ..\python_docs\spladdoninternals.py:736
msgid ""
"As you are broadcasting a show with Studio, you may find yourself in a "
"situation where you need to switch to Studio quickly to take care of "
"automation, insert new tracks and so on. An ideal situation is to switch to "
"Studio when you press Alt+TAB (this isn't the case if you have more than two "
"programs opened). For this reason, screen reader scripts for Studio includes "
"a command to switch to Studio upon request (unassigned in NVDA)."
msgstr ""
"Según estás emitiendo un programa en Studio, puedes encontrarte en una "
"situación donde necesitas pasar rápidamente a Studio para cambiar la "
"automatización, insertar nuevas pistas y demás. Una situación ideal es pasar "
"a Studio al pulsar alt+tab (no es el caso si tienes más de dos programas "
"abiertos). Por esta razón, los scripts de lectores de pantalla para Studio "
"incluyen una orden para pasar a Studio a petición (sin asignar en NVDA)."

#: ..\python_docs\spladdoninternals.py:737
msgid ""
"Until 2016, this was accomplished with a function in the SPL Utilities "
"module (SPLStudioUtils.fetchSPLForegroundWindow). This was employed not only "
"by the main global plugin module (called from a script to focus to Studio "
"window), but also used in encoders for various functions. The routine was as "
"follows:"
msgstr ""
"Hasta 2016, esto se llevaba a cabo con una función en el módulo de "
"utilidades de SPL (SPLStudioUtils.fetchSPLForegroundWindow). No sólo la "
"empleaba el módulo principal de la extensión global (llamada desde un script "
"para llevar el foco a la ventana de Studio), sino que se usaba en los "
"codificadores para diversos propósitos. El procedimiento era el siguiente:"

#: ..\python_docs\spladdoninternals.py:738
msgid ""
"1. The focus to Studio script will check if Studio is running, and if so, "
"it'll call the fetch window function, which in turn locates the desktop "
"(shell) window to serve as the starting point for locating Studio window."
msgstr ""
"1. El script que lleva el foco a Studio comprobará si Studio está en "
"ejecución, y si es así, llamará a la función de recuperación de ventana, que "
"primero localiza la ventana del escritorio (shell) para usarla como punto de "
"partida para encontrar la ventana de Studio."

#: ..\python_docs\spladdoninternals.py:739
msgid ""
"2. NVDA will scan top-level windows (children of desktop object) until a "
"Studio window (where the window's app module is the Studio app module) is "
"found, and if found, NVDA will increment a Studio window candidate counter."
msgstr ""
"2. NVDA escaneará las ventanas de nivel superior (hijas del objeto del "
"escritorio) hasta que se encuentre la ventana de Studio (donde el módulo de "
"aplicación de la ventana sea el de Studio), y si la encuentra, incrementará "
"un contador de ventanas de Studio candidatas."

#: ..\python_docs\spladdoninternals.py:740
msgid ""
"3. Once top-level window scanning is complete, NVDA will take action based "
"on what the Studio window candidate counter says before passing the "
"foreground object back to the main script. It can do one of the following:"
msgstr ""
"3. Una vez se haya completado el escaneo de ventanas de alto nivel, NVDA "
"tomará acciones en base a lo que diga el contador de ventanas candidatas de "
"Studio antes de devolver el objeto en primer plano al script principal. "
"Puede hacer una de las siguientes cosas:"

#: ..\python_docs\spladdoninternals.py:741
msgid ""
"\t1. If counter is 0 (fg is None), NVDA will know that you have minimized "
"Studio, so it'll tell you that Studio is minimized."
msgstr ""
"\t1. Si el contador es 0 (fg es None), NVDA sabrá que has minimizado Studio, "
"por lo que te lo dirá."

#: ..\python_docs\spladdoninternals.py:742
msgid ""
"\t2. If counter is 1, NVDA will locate the Studio window by looking for the "
"main Studio window (user32.dll is involved)."
msgstr ""
"\t2. Si el contador es 1, NVDA localizará la ventana de Studio buscándola "
"(user32.dll está implicada)."

#: ..\python_docs\spladdoninternals.py:743
msgid ""
"\t3. For all other values, NVDA will assume the last window found is the "
"Studio window (held in fg variable) and return it."
msgstr ""
"\t3. Para el resto de valores, NVDA asumirá que la última ventana que ha "
"encontrado es la ventana de Studio (contenida en la variable fg) y la "
"devolverá."

#: ..\python_docs\spladdoninternals.py:744
msgid ""
"4. Back at the focus to Studio script, NVDA will either announce if Studio "
"is minimized or switch to the foreground window returned by the fetch window "
"function (fg.SetFocus)."
msgstr ""
"4. De vuelta al script que lleva el foco a Studio, NVDA indicará que Studio "
"está minimizado o pasará a la ventana en primer plano devuelta por la "
"función de recuperación de ventana (fg.SetFocus)."

#: ..\python_docs\spladdoninternals.py:745
msgid ""
"In 2017, this has been simplified to use SetForegroundWindow Windows API "
"function with the handle to the Studio window being the only required "
"parameter. Not only this simplified this routine significantly, it also "
"improved performance of this command."
msgstr ""
"En 2017, eso se ha simplificado para usar la función SetForegroundWindow de "
"la api de Windows, siendo el manejador de la ventana de Studio el único "
"parámetro necesario que se pasaba. Esto no sólo simplificó la función "
"significativamente, sino que también aumentó el rendimiento de esta orden."

#: ..\python_docs\spladdoninternals.py:746
msgid ""
"One side effect was difficulty in determining if Studio window is minimized, "
"hence the clue was seeing if NVDA says \"unavailable\". In 2020, focus to "
"Studio routine was refined to look for visibility of Studio window, and if "
"not visible, present an error message. One can then go to system tray and "
"restore Studio window."
msgstr ""
"Un efecto colateral es que ya no es posible detectar Studio cuando está "
"minimizado, pero nos podemos hacer una idea de ello cuando NVDA dice \"No "
"disponible\" al intentar cambiar a Studio. En 2020, el procedimiento para "
"llevar el foco a Studio se refinó para comprobar la visibilidad de la "
"ventana de Studio, y si no se veía, presentaba un mensaje de error. De esa "
"forma, el usuario puede ir a la bandeja del sistema y restaurar la ventana "
"de Studio."

#: ..\python_docs\spladdoninternals.py:747
msgid "## Encoder support"
msgstr "## Soporte del codificador"

#: ..\python_docs\spladdoninternals.py:748
msgid ""
"We have now arrived at the penultimate chapter in this Add-on Internals "
"article for StationPlaylist add-on: encoder support. We'll talk about how "
"encoder support is implemented, how NVDA can detect encoder labels and a "
"behind the scenes overview of what happens when you connect to a streaming "
"server."
msgstr ""
"Ahora hemos llegado al penúltimo capítulo en este artículo de complementos "
"vistos por dentro para el complemento de StationPlaylist: soporte del "
"codificador. Hablaremos sobre cómo ha sido implementado el soporte del "
"codificador, cómo puede NVDA detectar las etiquetas del codificador y una "
"descripción tras el escenario de lo que pasa cuando te conectas a un "
"servidor de emisión."

#: ..\python_docs\spladdoninternals.py:749
msgid "### Encoder support: From suggestion to implementation"
msgstr "### Soporte del codificador: de la sugerencia a la implementación"

#: ..\python_docs\spladdoninternals.py:750
msgid ""
"Originally, I wasn't planning on including encoder support into the SPL add-"
"on. However, after talking to some Studio users who were using SAM encoders "
"and seeing how other screen readers supported it, I decided to investigate "
"SAM encoder support in summer 2014, resulting in encoders support becoming a "
"part of SPL Utilities global plugin in add-on 3.0."
msgstr ""
"Originalmente, no tenía planeado incluir soporte para el codificador en el "
"complemento de SPL. Sin embargo, tras hablar con varios usuarios de Studio "
"que utilizaban los codificadores SAM y viendo cómo les daban soporte otros "
"lectores de pantalla, decidí investigar el soporte para el codificador SAM "
"en verano del 2014, dando como resultado el soporte para los codificadores "
"como parte de la extensión global de utilidades de SPL en el complemento 3.0."

#: ..\python_docs\spladdoninternals.py:751
msgid ""
"The first issue I had to solve was making NVDA recognize the encoder entries "
"themselves. Once that was solved, the next task was announcing connection "
"error messages, which led to figuring out how SAM encoders react when "
"connected to a streaming server."
msgstr ""
"El primer problema que tenía que resolver era hacer que NVDA reconociera las "
"entradas de codificador en sí mismas. Una vez estuvo resuelto, la siguiente "
"tarea era verbalizar los mensajes de error de conexión, lo que llevó a "
"averiguar cómo reaccionaban los codificadores SAM al conectarse a un "
"servidor de emisión."

#: ..\python_docs\spladdoninternals.py:752
msgid ""
"Originally, I manipulated text written to the screen to obtain needed status "
"messages (via text infos). This routine caused some to experience screen "
"flickering issues when connecting to a streaming server. This was resolved "
"by using encoder description (obj.description), which opened up a "
"possibility to monitor changes to this text via a background thread (more on "
"this routine below), which also eliminated a need to stay on the encoders "
"window until connected."
msgstr ""
"Originalmente, manipulaba el texto escrito en pantalla para obtener los "
"mensajes de estado necesarios (mediante text infos). Este procedimiento "
"causaba que algunos usuarios experimentaran problemas de parpadeo al "
"conectarse a un servidor de emisión. Esto se resolvió usando la descripción "
"del codificador (obj.description), que abría una posibilidad de monitorizar "
"cambios en el texto mediante un hilo en segundo plano (más sobre este "
"procedimiento debajo), lo que también eliminó la necesidad de permanecer en "
"la ventana de codificadores hasta estar conectado."

#: ..\python_docs\spladdoninternals.py:753
msgid ""
"While I was resolving problems with SAM encoders, I also worked on "
"refactoring encoder support code to support StationPlaylist encoders (add-on "
"4.0). Initially, encoder support code was optimized for SAM encoders, but "
"the current code structure (explained below) was written to extend basic "
"encoder support easily, and as a result, both SAM and SPL encoder entries "
"(and other encoder types) present similar interfaces and commands, including "
"a common encoder configuration dialog (add-on 7.0)."
msgstr ""
"Mientras estaba resolviendo problemas con los codificadores SAM, trabajé "
"también en refactorizar el código de soporte del codificador para dar "
"compatibilidad con los codificadores de StationPlaylist (complemento 4.0). "
"Inicialmente, el código de soporte para el codificador se optimizó para los "
"codificadores SAM, pero la estructura actual del código (explicada debajo) "
"se escribió para extender fácilmente el soporte básico de codificadores, y "
"como resultado, las entradas del codificador de SAM y SPL (y otros "
"codificadores) presentan interfaces y órdenes similares, incluyendo un "
"diálogo común de configuración del codificador (complemento 7.0)."

#: ..\python_docs\spladdoninternals.py:754
msgid ""
"Few years later, encoder support became a hot topic when I was asked by a "
"broadcaster to add support for Edcast in 2019. Edcast, while free, was end "
"of life, and Altacast took its place. Thankfully, adding support for "
"AltaCast encoder (Winamp plugin which must be recognized by Studio and "
"Streamer) was a breeze because its user interface is similar to SPL "
"encoders. Thus, AltaCast encoder support is similar to SPL encoders, thus "
"for purposes of this section, AltaCast is synonymous with SPL encoder."
msgstr ""
"Pocos años después, el tema del soporte para codificadores se puso sobre la "
"mesa cuando un locutor me pidió que añadiera soporte para Edcast en 2019. "
"Edcast, aunque era gratis, llegaba al final de su vida, y AltaCast ocupó su "
"lugar. Por suerte, añadir soporte para el codificador AltaCast (plugin de "
"Winamp que debe ser reconocido por Studio y Streamer) fue sencillo, ya que "
"su interfaz de usuario es similar a la de los codificadores de SPL. Por lo "
"tanto, el soporte del codificador AltaCast es similar al de los "
"codificadores de SPL, así que para los propósitos de esta sección, AltaCast "
"es un sinónimo del codificador SPL."

#: ..\python_docs\spladdoninternals.py:755
msgid ""
"At the same time, encoder support was reorganized. In 2014, with limited "
"knowledge on encoder engines, I felt it was best to house encoder support "
"module inside SPL Utilities. In the course of time, two encoder engines were "
"found: SPL Engine (splengine) and Streamer (splstreamer). After learning "
"that encoder engines were housed inside these apps, it was decided in 2020 "
"to separate encoder support module into its own app module, transfering "
"encoder support from the global plugin to SPL Engine app module package with "
"Streamer deriving most of its power from the former."
msgstr ""
"Al mismo tiempo, se reorganizó el soporte del codificador. En 2014, con "
"conocimientos limitados en motores de codificación, sentí que era mejor "
"alojar el módulo de soporte del codificador dentro de las utilidades de SPL. "
"Con el paso del tiempo, se encontraron dos motores de codificación: el motor "
"SPL (splengine) y Streamer (splstreamer). Tras aprender que los motores de "
"codificación estaban alojados dentro de estas aplicaciones, decidí en 2020 "
"separar el módulo de soporte del codificador en su propio módulo de "
"aplicación, transfiriendo el soporte del codificador de la extensión global "
"al paquete del módulo de aplicación del motor SPL y derivando la mayoría de "
"funciones de Streamer del paquete del motor de SPL."

#: ..\python_docs\spladdoninternals.py:756
msgid "### Encoder support structure"
msgstr "### Estructura del soporte del codificador"

#: ..\python_docs\spladdoninternals.py:757
msgid ""
"Encoder support is part of two app modules: SPL Engine and StationPlaylist "
"Streamer, the former being an app module package similar to SPL Studio "
"package. The complete picture is thus:"
msgstr ""
"El soporte del codificador es parte de dos módulos de aplicación: SPL Engine "
"y StationPlaylist Streamer, siendo el primero un módulo de aplicación "
"similar al paquete SPL Studio. Por tanto, el cuadro al completo queda así:"

#: ..\python_docs\spladdoninternals.py:758
msgid ""
"* SPL Engine app module (splengine/__init__.py), providing base app module "
"services for use by both SPL Engine and Streamer such as encoder detection."
msgstr ""
"* Módulo de aplicación del motor de SPL (splengine/__init__.py), que "
"proporciona servicios básicos de módulo de aplicación usados tanto por el "
"motor SPL como por Streamer, como por ejemplo la detección de codificadores."

#: ..\python_docs\spladdoninternals.py:759
msgid ""
"* Encoder support (splengine/encoders.py), outlining NVDA's support for "
"various encoders and is the focus of this section."
msgstr ""
"* Soporte del codificador (splengine/encoders.py), describiendo el soporte "
"de NVDA para diversos codificadores y que constituye el tema principal de "
"esta sección."

#: ..\python_docs\spladdoninternals.py:760
msgid ""
"* Streamer app module (splstreamer.py), which simply imports everything from "
"SPL Engine app module package and adds overlay class management for Streamer "
"user interface."
msgstr ""
"* Módulo de aplicación de Streamer (splstreamer.py), que simplemente importa "
"todo del paquete del módulo de aplicación del motor de SPL y añade gestión "
"de envoltura de clases para la interfaz de usuario de Streamer."

#: ..\python_docs\spladdoninternals.py:761
msgid "### Encoder entries: Yet another overlay class family"
msgstr ""
"### Entradas del codificador: otra familia más de clases de superposición"

#: ..\python_docs\spladdoninternals.py:762
msgid ""
"Just like Studio track items (see the section on track items), encoder "
"entries are overlay classes. Each encoder type (SAM, SPL, AltaCast and "
"future encoders) inherit from a single encoder object (splengine.encoders."
"Encoder) that provides basic services such as settings commands, announcing "
"encoder labels and so on. Then each encoder type adds encoder-specific "
"routines such as different connection detection routines, ways of obtaining "
"encoder labels and so on. Speaking of encoder labels and settings, the base "
"encoder class is helped by some friends from the encoder module itself, "
"including a configuration map to store encoder labels and basic settings, a "
"routine to obtain encoder ID (encoder string and the IAccessible child ID) "
"and so on."
msgstr ""
"Al igual que los elementos de pista de Studio (mira la sección de elementos "
"de pista), las entradas del codificador son clases de superposición. Cada "
"tipo de codificador (SAM, SPL, AltaCast y los codificadores futuros) hereda "
"de un único objeto codificador (splengine.encoders.Encoder), que proporciona "
"servicios básicos como órdenes de ajustes, verbalización de etiquetas del "
"codificador y demás. Cada tipo de codificador agrega procedimientos "
"específicos del codificador como diferentes funciones de detección de "
"conexión, formas de obtener etiquetas del codificador y demás. Hablando de "
"etiquetas del codificador y ajustes, la clase base del codificador recibe "
"ayuda de algunos amigos del módulo del codificador en sí, incluido un mapa "
"de configuración para almacenar etiquetas de flujo y ajustes básicos, una "
"función para obtener el identificador del codificador (cadena del "
"codificador e identificador del hijo de IAccessible) y demás."

#: ..\python_docs\spladdoninternals.py:763
msgid ""
"On top of the base encoder class are three encoder classes, representing "
"entries from SAM, SPL, and AltaCast. SAM encoder entries (splengine.encoders."
"SAMEncoder) are laid out just like Studio's track items with parts deriving "
"from SysListView32 objects, whereas SPL encoder list (splengine.encoders."
"SPLEncoder) is a typical SysListView32 control (see the section on column "
"routines for more information). Being similar in appearance to SPL encoder, "
"AltaCast encoder (splengine.encoders.AltaCastEncoder) derives from SPL "
"encoder class with encoder specific differences. All encoder classes provide "
"similar routines, with differences being how connection messages are handled "
"and obtaining encoder specific data such as encoder type identifier used for "
"looking up encoder settings with help from encoder ID's."
msgstr ""
"Construidas sobre la clase base del codificador hay tres clases de "
"codificadores, representando las entradas de SAM, SPL y AltaCast. Las "
"entradas del codificador SAM (splengine.encoders.SAMEncoder) se presentan "
"como los elementos de pista de Studio con partes que derivan de objetos "
"SysListView32, mientras que las entradas del codificador SPL (splengine."
"encoders.SPLEncoder) es un control SysListView32 típico (mira el artículo "
"sobre procedimientos de columna para más información). Siendo similar en "
"apariencia al codificador SPL, las entradas del codificador AltaCast "
"(splengine.encoders.AltaCastEncoder) derivan de la clase del codificador SPL "
"con diferencias específicas del codificador. Todas las clases proporcionan "
"procedimientos similares, diferenciándose en cómo se capturan los mensajes "
"de conexión y cómo se obtienen datos específicos del codificador, como el "
"identificador de tipo de codificador usado para acceder a las opciones del "
"codificador con la ayuda de sus identificadores."

#: ..\python_docs\spladdoninternals.py:764
msgid "### Encoder ID's"
msgstr "### Identificadores de codificador"

#: ..\python_docs\spladdoninternals.py:765
msgid ""
"An encoder ID is a string which uniquely identifies an encoder. This "
"consists of a string denoting the encoder type (SAM for SAM encoder, for "
"instance), followed by the encoder position (separated by a space). For "
"instance, the first SAM encoder is given the ID \"SAM 1\". The ID's are used "
"to retrieve and configure encoder settings, as well as identifying encoders "
"when monitoring them in the background."
msgstr ""
"Un identificador de codificador es una cadena que identifica unívocamente un "
"codificador. Consta de una cadena que indica el tipo de codificador (SAM "
"para el codificador SAM, por ejemplo), seguida de la posición del "
"codificador (separada por un espacio). Por ejemplo, el primer codificador "
"SAM tiene el identificador \"SAM 1\". Los identificadores se usan para "
"recuperar y configurar ajustes e identificar codificadores monitorizados en "
"segundo plano."

#: ..\python_docs\spladdoninternals.py:766
msgid "### Common services: basic settings, encoder labels and related methods"
msgstr ""
"### Servicios comunes: ajustes básicos, etiquetas del codificador y métodos "
"relacionados"

#: ..\python_docs\spladdoninternals.py:767
msgid "All encoder classes provide the following common services:"
msgstr ""
"Todas las clases de codificadores proporcionan los siguientes servicios "
"comunes:"

#: ..\python_docs\spladdoninternals.py:768
msgid "* Configuring settings: six settings can be configured:"
msgstr "* Configuración de ajustes: se pueden configurar seis ajustes:"

#: ..\python_docs\spladdoninternals.py:769
msgid "\t* A custom encoder label can be defined for ease of identification."
msgstr ""
"\t* Se puede definir una etiqueta personalizada del codificador para "
"facilitar su identificación."

#: ..\python_docs\spladdoninternals.py:770
msgid ""
"\t* Pressing F11 will tell NVDA if NVDA should switch to Studio when the "
"encoder is connected."
msgstr ""
"\t* Al pulsar f11 indicaremos a NVDA si este debería pasar a Studio cuando "
"el codificador esté conectado."

#: ..\python_docs\spladdoninternals.py:771
msgid ""
"\t*Pressing Shift+F11 will tell NVDA if NVDA should ask Studio to play the "
"next track when connected."
msgstr ""
"\t* Al pulsar shift+f11 se dirá a NVDA que pida a Studio que reproduzca la "
"siguiente pista al conectarse."

#: ..\python_docs\spladdoninternals.py:772
msgid ""
"\t* Pressing Control+F11 will enable background encoder monitoring (more on "
"this in a second)."
msgstr ""
"\t* Al pulsar ctrl+f11 se activará la monitorización del codificador en "
"segundo plano (más sobre esto en un segundo)."

#: ..\python_docs\spladdoninternals.py:773
msgid ""
"\t* Enabling or disabling connection progress tones (add-on 7.0, "
"configurable from encoder settings dialog described below)."
msgstr ""
"\t* Activar o desactivar la reproducción de tonos que indiquen el progreso "
"de la conexión (complemento 7.0, configurable desde el diálogo de ajustes "
"del codificador que se describe más abajo)."

#: ..\python_docs\spladdoninternals.py:774
msgid ""
"\t* Announcing connection status until the selected encoder is connected "
"(add-on 20.03), also configurable from encoder settings dialog."
msgstr ""
"\t* Anunciar el estado de conexión hasta que el codificador seleccionado se "
"conecte (complemento 20.03), configurable también desde el diálogo de "
"opciones del codificador."

#: ..\python_docs\spladdoninternals.py:775
msgid ""
"\t* Once these settings are changed, the new values will be stored in "
"appropriate flag in the encoder entry, which in turn are saved in the "
"configuration map."
msgstr ""
"\t* Una vez se cambien estos ajustes, los nuevos valores se almacenarán en "
"el indicador apropiado de la entrada del codificador, que eventualmente se "
"guarda en el mapa de configuración."

#: ..\python_docs\spladdoninternals.py:776
msgid ""
"* Apart from encoder labels, retrieves settings. This is done by various "
"property methods - once called, these methods will look up various settings "
"for the encoder from the configuration map (key is the setting flag, value "
"is the encoder ID). Encoder labels are organized differently (see below)."
msgstr ""
"* Además de las etiquetas del codificador, recupera ajustes. Esto se hace "
"con diversos métodos de propiedad - una vez llamados, estos métodos "
"recuperarán diversos ajustes para el codificador desde el mapa de "
"configuración (la clave es el indicador del ajuste, y el valor es el "
"identificador del codificador). Las etiquetas del codificador se organizan "
"de forma diferente (mira más abajo)."

#: ..\python_docs\spladdoninternals.py:777
msgid ""
"* Monitors and responds to connection status changes. The response routine "
"(onConnection method) attempts to set focus to Studio and/or play the first "
"checked track if configured to do so."
msgstr ""
"* Monitorización y reacción ante cambios de estado de la conexión. El "
"procedimiento de respuesta (método onConnection) intenta llevar el foco a "
"Studio y / o reproducir la primera pista marcada si está configurado para "
"hacerlo."

#: ..\python_docs\spladdoninternals.py:778
msgid ""
"* Loads encoder labels when an encoder first gains focus (if this was loaded "
"earlier, it could be a waste of space, especially if encoders are never "
"used)."
msgstr ""
"* Carga las etiquetas del codificador cuando un codificador obtiene el foco "
"por primera vez (si se habían cargado antes, podría suponer un gasto de "
"espacio, especialmente si nunca se usan los codificadores)."

#: ..\python_docs\spladdoninternals.py:779
msgid ""
"* Announces encoder labels (if defined) via a dedicated name getter. Labels "
"are stored as dictionary keys corresponding to encoder ID's under a "
"dedicated encoder labels section inside the configuration map."
msgstr ""
"* Anuncia las etiquetas del codificador (si se han definido) mediante un "
"método getter dedicado para el nombre. Las etiquetas se almacenan como "
"claves de un diccionario y se corresponden con identificadores de "
"codificadores bajo una sección dedicada a las etiquetas de los codificadores "
"dentro del mapa de configuración."

#: ..\python_docs\spladdoninternals.py:780
msgid ""
"* Define and remove encoder labels. If a label is defined (no empty string), "
"encoder label is stored in an encoder labels collection, otherwise removed "
"from the collection."
msgstr ""
"* Define y elimina etiquetas del codificador. Si una etiqueta está definida "
"(cadena no vacía), la etiqueta del codificador se almacena en una colección "
"de etiquetas del codificador, y en cualquier otro caso se elimina de la "
"colección."

#: ..\python_docs\spladdoninternals.py:781
msgid ""
"* Updates encoder label and flags position when told to do so (via a dialog, "
"activated by pressing Control+F12). This is needed if encoders were removed, "
"as you may hear label for an encoder that no longer exists. This is "
"implemented as a variation of find predecessor algorithm."
msgstr ""
"* Actualiza la etiqueta del codificador e indica su posición a petición "
"(mediante un diálogo, que se activa pulsando ctrl+f12). Esto es necesario si "
"se han eliminado codificadores, ya que puedes oír la etiqueta de un "
"codificador que ya no existe. Esto se implementa como una variación del "
"algoritmo de búsqueda anterior."

#: ..\python_docs\spladdoninternals.py:782
msgid ""
"* Announces encoder columns. The base class can announce encoder position "
"(Control+NVDA+1) and label (Control+NVDA+2), while SAM can announce encoder "
"format, status and description and SPL and AltaCast allows one to hear "
"encoder format and transfer rate/connection status."
msgstr ""
"* Anuncia las columnas del codificador. La clase base puede verbalizar la "
"posición del codificador (ctrl+NVDA+1) y su etiqueta (ctrl+NVDA+2), mientras "
"que SAM puede verbalizar el formato del codificador, estado y descripción. "
"SPL y AltaCast permiten oír el formato del codificador y la velocidad de "
"transferencia / el estado de la conexión."

#: ..\python_docs\spladdoninternals.py:783
msgid ""
"* In add-on 7.0, a central configuration dialog for configuring encoder "
"settings for the selected encoder has been added. Press Alt+NVDA+0 or F12 to "
"open this dialog."
msgstr ""
"* En el complemento 7.0, se ha añadido un diálogo de configuración central "
"para configurar los ajustes del codificador seleccionado. Pulsa alt+NVDA+0 o "
"f12 para abrir este diálogo."

#: ..\python_docs\spladdoninternals.py:784
msgid ""
"### More and more threads: connection messages and background encoder "
"monitoring"
msgstr ""
"### Más y más hilos: mensajes de conexión y monitorización del codificador "
"en segundo plano"

#: ..\python_docs\spladdoninternals.py:785
msgid ""
"As we saw in a previous chapter, threads allow developers to let programs "
"perform certain tasks in the background. Even in encoder support, threads "
"are employed for various tasks, including connection message announcement "
"and background encoder monitoring."
msgstr ""
"Como vimos en un capítulo anterior, los hilos permiten a los desarrolladores "
"hacer que los programas realicen ciertas tareas en segundo plano. Incluso en "
"el soporte de codificadores, los hilos se emplean para diversas tareas, "
"incluyendo la verbalización del mensaje de conexión y la monitorización del "
"codificador en segundo plano."

#: ..\python_docs\spladdoninternals.py:786
msgid ""
"Each encoder overlay class (not the base encoder) includes dedicated "
"connection handling routines (reportConnectionStatus). Depending on how you "
"invoke this, it starts up as follows:"
msgstr ""
"Cada clase de superposición para cada codificador (y no el codificador base) "
"incluye procedimientos dedicados para la gestión de conexión "
"(reportConnectionStatus). Dependiendo de cómo los invoques, se pueden "
"iniciar como sigue:"

#: ..\python_docs\spladdoninternals.py:787
msgid ""
"* If background encoder monitoring is off and you press F9 to connect, NVDA "
"will run this routine in a separate thread. For SAM, this is checked right "
"after sending F9 to the application, and for SPL, this is done after "
"clicking \"connect\" from the encoder context menu (manipulates focus in the "
"process)."
msgstr ""
"* Si la monitorización del codificador en segundo plano está desactivada y "
"pulsas f9 para conectar, NVDA ejecutará este procedimiento en un hilo "
"separado. En SAM, se hace la comprobación justo después de enviar f9 a la "
"aplicación, y en SPL se hace después de hacer click en \"Connect\" desde el "
"menú de contexto del codificador (se manipula el foco en el proceso)."

#: ..\python_docs\spladdoninternals.py:788
msgid ""
"* If background encoder monitoring is on before pressing F9, the routine "
"will run from another thread when this setting is switched on. Then when you "
"press F9, NVDA knows that the background monitoring thread is active, thus "
"skipping the above step."
msgstr ""
"* Si la monitorización del codificador en segundo plano está activada antes "
"de pulsar f9, el procedimiento se ejecutará desde otro hilo cuando este "
"ajuste se active. Cuando pulses f9, NVDA ya sabe que el hilo de "
"monitorización en segundo plano está activo, por lo que se saltará el paso "
"de arriba."

#: ..\python_docs\spladdoninternals.py:789
msgid "The connection handling routine performs the following:"
msgstr "El procedimiento encargado de gestionar la conexión hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:790
msgid ""
"1. Locates status message for the encoder entry. For SAM, status message is "
"spread over two columns (child objects), and for SPL, transfer rate column "
"is consulted. This will be done as long as Studio and/or NVDA is live (that "
"is, if the thread is running)."
msgstr ""
"1. Ubica el mensaje de estado para la entrada del codificador. En Sam, el "
"mensaje de estado se reparte en dos columnas (objetos hijo), y en SPL se "
"consulta la columna de velocidad de transferencia. Esto se hará mientras "
"Studio y / o NVDA estén en ejecución (o lo que es lo mismo, si el hilo está "
"en ejecución)."

#: ..\python_docs\spladdoninternals.py:791
msgid ""
"2. Announces error messages if any and will try again after waiting a little "
"while (fraction of a second). If NVDA is told to not announce connection "
"status until the encoder in question is connected, connection reporter "
"thread will stop when an error message is seen."
msgstr ""
"2. Anuncia mensajes de error, si los hay, y prueba de nuevo tras esperar un "
"rato (fracciones de segundo). Si se indica a NVDA que no anuncie el estado "
"de conexión hasta que el codificador en cuestión esté conectado, el hilo "
"informador de conexión se detendrá cuando se vea un mensaje de error."

#: ..\python_docs\spladdoninternals.py:792
msgid "3. If connected, NVDA will play a tone, then:"
msgstr "3. Si está conectado, NVDA reproducirá un tono, y entonces:"

#: ..\python_docs\spladdoninternals.py:793
msgid "\t* Do nothing if not told to focus to studio nor play the next track."
msgstr ""
"\t* No hará nada si no se le indica que lleve el foco a Studio o reproduzca "
"la siguiente pista."

#: ..\python_docs\spladdoninternals.py:794
msgid ""
"\t* Focuses to studio and/or plays the next track if no tracks are playing "
"by calling onConnect method."
msgstr ""
"\t* Lleva el foco a Studio y / o reproduce la siguiente pista si no hay "
"pistas reproduciéndose llamando al método onConnect."

#: ..\python_docs\spladdoninternals.py:795
msgid ""
"4. For other messages, NVDA will periodically play a progress tone and "
"announce connection status so far as reported by the encoder (progress tones "
"will not be played if suppressed from encoder settings dialog)."
msgstr ""
"4. Para otros mensajes, NVDA reproducirá periódicamente un tono de progreso "
"y verbalizará el estado de la conexión tan pronto como lo informe el "
"codificador (los tonos de progreso no se reproducirán si se suprimen en el "
"diálogo de ajustes del codificador)."

#: ..\python_docs\spladdoninternals.py:796
msgid ""
"5. This loop repeats as long as this encoder is being monitored in the "
"background."
msgstr ""
"5. Este bucle se repite mientras el codificador esté siendo monitorizado en "
"segundo plano."

#: ..\python_docs\spladdoninternals.py:797
msgid "#### Monitoring multiple encoders with encoder registry"
msgstr ""
"#### Vigilancia de varios codificadores con el registro de codificadores"

#: ..\python_docs\spladdoninternals.py:798
msgid ""
"Sometimes it becomes necessary to monitor multiple encoders at once, "
"particularly if streaming to multiple servers or files. To handle this, "
"encoder connection monitoring threads are housed inside an encoders "
"registry, a dictionary that maps encoder ID's to connection reporter "
"threads. This is useful to direct NVDA to announce connection status for "
"multiple encoders one encoder at a time, and if this happens, NVDA will "
"prefix encoder status with the ID associated with the encoder in question."
msgstr ""
"A veces se hace necesario vigilar varios codificadores a la vez, "
"particularmente si se emite a distintos servidores o archivos. Para manejar "
"esto, los hilos de vigilancia de los codificadores se alojan en un registro "
"de codificadores, un diccionario que relaciona identificadores de "
"codificadores con hilos informantes de conexión. Esto es útil para hacer que "
"NVDA anuncie el estado de conexión de varios codificadores, uno cada vez, y "
"si esto sucede, NVDA prefijará el estado del codificador con el "
"identificador asociado del codificador en cuestión."

#: ..\python_docs\spladdoninternals.py:799
msgid "### Encoder-specific routines"
msgstr "### Procedimientos específicos del codificador"

#: ..\python_docs\spladdoninternals.py:800
msgid ""
"In addition to basic services, each encoder routine has its own goodies, "
"including:"
msgstr ""
"Además de los servicios básicos, cada procedimiento de codificación tiene "
"sus propias ventajas, incluyendo:"

#: ..\python_docs\spladdoninternals.py:801
msgid "For SAM encoders:"
msgstr "Para los codificadores SAM:"

#: ..\python_docs\spladdoninternals.py:802
msgid "* To disconnect, press F10."
msgstr "* Para desconectar, pulsa f10."

#: ..\python_docs\spladdoninternals.py:803
msgid ""
"* You can press Control+F9 or Control+F10 to connect or disconnect all "
"encoders (does not work well in recent SAM releases, according to my tests). "
"A workaround was developed to fix this problem (opens context menu and "
"activates the correct item on its own)."
msgstr ""
"* Puedes pulsar ctrl+f9 o ctrl+f10 para conectar y desconectar todos los "
"codificadores (no funciona bien en versiones recientes de SAM, según mis "
"pruebas). Se desarrolló un parche para solucionar este problema (abre el "
"menú contextual y activa el elemento correspondiente por sí mismo)."

#: ..\python_docs\spladdoninternals.py:804
msgid "For SPL encoder family (including AltaCast):"
msgstr "Para la familia de codificadores de SPL (incluyendo AltaCast):"

#: ..\python_docs\spladdoninternals.py:805
msgid ""
"* When you press Control+F9 to connect all encoders, NVDA does the following:"
msgstr ""
"* Cuando pulsas control+f9 para conectar todos los codificadores, NVDA hace "
"lo siguiente:"

#: ..\python_docs\spladdoninternals.py:806
msgid ""
"\t1. Locates \"connect\" button, and if it says \"Connect\", clicks it (obj."
"doAction)."
msgstr ""
"\t1. Ubica el botón conectar, y si está etiquetado como \"connect\", hace "
"clic en él (obj.doAction)."

#: ..\python_docs\spladdoninternals.py:807
msgid "\t2. Moves focus back to the entry (self.SetFocus)."
msgstr "\t2. Mueve el foco de vuelta a la entrada (self.setFocus)."

#: ..\python_docs\spladdoninternals.py:808
msgid ""
"* To disconnect, press TAB until you arrive at \"Disconnect\" button and "
"press SPACE."
msgstr ""
"* Para desconectar, pulsa tabulador hasta que llegues al botón \"Desconectar"
"\" y pulsa la barra espaciadora."

#: ..\python_docs\spladdoninternals.py:809
msgid "## Final notes and add-on development process overview"
msgstr ""
"## Notas finales y descripción del proceso de desarrollo de un complemento"

#: ..\python_docs\spladdoninternals.py:810
msgid ""
"Now that we've visited internals of StationPlaylist add-on, I'd like to give "
"you a tour of my lab where I develop this add-on. Along the way you'll learn "
"how an add-on is born, coded, tested, released and maintained."
msgstr ""
"Ahora que hemos visitado el interior del complemento StationPlaylist, me "
"gustaría hacerte un recorrido por mi laboratorio, donde desarrollo este "
"complemento. Durante el camino aprenderás cómo nace un complemento, se "
"codifica, se prueba, se publica y se mantiene."

#: ..\python_docs\spladdoninternals.py:811
msgid "### Lab setup, development equipment and software"
msgstr "### Preparación del laboratorio, equipamiento de desarrollo y software"

#: ..\python_docs\spladdoninternals.py:812
msgid ""
"For all my software development, I use two computers: a touchscreen laptop "
"and a desktop, both running Windows 10 and latest NVDA alpha snapshots. Both "
"also run Cygwin and/or Windows Subsystem for Linux (WSL, otherwise known as "
"BASH on Ubuntu on Windows)to run various command-line tools (Git, SCons, "
"etc.), and in case I need to compile NVDA from source code, installed Visual "
"Studio 2017 with latest update and other dependencies."
msgstr ""
"Para todos mis desarrollos de software, yo uso dos ordenadores: un portátil "
"con pantalla táctil y un sobremesa, ambos ejecutando Windows 10 y las "
"últimas versiones de desarrollo alpha de NVDA. Ambos también tienen Cygwin "
"y / o el subsistema de Windows para Linux (WSL, conocido de otra manera como "
"BASH en Ubuntu en Windows) para ejecutar varias herramientas de la línea de "
"órdenes (git, SCons, etc.), y en caso que necesite compilar NVDA desde el "
"código fuente, tengo instalado Visual Studio 2017 con la última "
"actualización y otras dependencias."

#: ..\python_docs\spladdoninternals.py:813
msgid ""
"In case of SPL add-on, I have different Studio versions installed: 5.11 on "
"my laptop and 5.20 on the desktop. This allows me to work on both versions "
"at once (both computers have the full source code of the add-on, though I "
"tend to write bug fixes on my laptop and experiment with new things on my "
"desktop)."
msgstr ""
"En el caso del complemento SPL, tengo diferentes versiones de Studio "
"instaladas: 5.11 en mi portátil y 5.20 en el sobremesa. Esto me permite "
"trabajar en ambas versiones de una vez (ambos ordenadores tienen el código "
"fuente completo del complemento, aunque tiendo a solucionar fallos en mi "
"portátil y experimentar con cosas nuevas en mi sobremesa)."

#: ..\python_docs\spladdoninternals.py:814
msgid "### Git: a \"smart\" source code manager"
msgstr "### Git: un gestor de código fuente inteligente"

#: ..\python_docs\spladdoninternals.py:815
msgid ""
"Like other NVDA developers and many add-on writers, I use Git for source "
"code management (contrary to its slogan, Git is very smart). This is a "
"distributed system, meaning a local repository contains the complete record "
"of how the source code is managed (no need to connect to a server to commit "
"and fetch updates). For example, using just my local copy of the SPL add-on "
"source code, I can view commit history and generate older add-on releases."
msgstr ""
"Al igual que los desarrolladores de NVDA y muchos creadores de complementos, "
"uso Git para gestionar el código fuente (contrariamente a su lema, Git es "
"muy inteligente). Se trata de un sistema distribuido, lo que significa que "
"un repositorio local contiene el registro completo de cómo se gestiona el "
"código fuente (sin necesidad de conectarse a un servidor para confirmar y "
"obtener actualizaciones). Por ejemplo, si uso simplemente mi copia local del "
"código fuente del complemento de SPL, puedo ver el historial de commits y "
"generar versiones antiguas del complemento."

#: ..\python_docs\spladdoninternals.py:816
msgid ""
"Another advantage of Git is extensive support for branches. A branch is a "
"development workflow separate from other branches. For example, NVDA screen "
"reader uses at least three branches for its workflow: alpha (master branch), "
"beta (beta branch) and rc (release candidate, used to build official "
"releases). SPL add-on uses this approach as well: there are at least two "
"branches in use, called master (renamed to main in 2021) and stable used for "
"ongoing development or release and maintenance, respectively (we'll come "
"back to branches in a second). With the advent of Test Drive program (see "
"below), a third branch named \"staging\" or \"next\" is used to gather all "
"work done on branches under one roof for testing purposes (in 2018, this has "
"changed significantly)."
msgstr ""
"Otra ventaja de Git es su extenso soporte para ramas. Una rama es un flujo "
"de desarrollo separado de otras ramas. Por ejemplo, el lector de pantalla "
"NVDA usa al menos tres ramas para su flujo de trabajo: alfa (rama master), "
"beta (rama beta) y rc (candidata a liberación, usada para construir "
"versiones oficiales). El complemento de SPL usa este enfoque así: hay al "
"menos dos ramas en uso, llamadas master (renombrada a main en 2021) y "
"stable, usadas para desarrollo activo y publicación y mantenimiento, "
"respectivamente (volveremos a las ramas en un segundo). Con la llegada del "
"programa de unidad de pruebas (mira debajo), se usa una tercera rama llamada "
"\"staging\" o \"next\" para recopilar todo el trabajo hecho en ramas bajo un "
"techo con propósitos de prueba (en 2018, esto ha cambiado "
"significativamente)."

#: ..\python_docs\spladdoninternals.py:817
msgid "### How an add-on feature is born"
msgstr "### Cómo nace una característica de un complemento"

#: ..\python_docs\spladdoninternals.py:818
msgid ""
"Let's go through a typical development process for an add-on feature by "
"looking at how broadcast profiles was developed (for more information on "
"broadcast profiles, refer to configuration management section above)."
msgstr ""
"Recorramos el proceso típico de desarrollo de una característica de un "
"complemento viendo cómo se desarrollaron los perfiles de emisión (para más "
"información sobre los perfiles de emisión, consulta la sección de gestión de "
"la configuración de arriba)."

#: ..\python_docs\spladdoninternals.py:819
msgid ""
"I started working on broadcast profiles in March 2015 while developing add-"
"on 5.0. This was a natural extension of add-on settings dialog: whereas this "
"dialog (and the configuration database it uses) only dealt with a single "
"profile, I thought it might be a good idea to allow multiple profiles to be "
"defined and to let the settings dialog respond to profile changes."
msgstr ""
"Comencé a trabajar en los perfiles de emisión en marzo de 2015 mientras "
"desarrollaba el complemento 5.0. Se trataba de una extensión natural del "
"diálogo de configuración del complemento: mientras que este cuadro de "
"diálogo (y la base de datos de configuración que usa) sólo se ocupa de un "
"único perfil, pensé que sería una buena idea permitir que se definan varios "
"perfiles y hacer que el diálogo de configuración reaccione ante el cambio de "
"perfiles."

#: ..\python_docs\spladdoninternals.py:820
msgid ""
"There was an important reason for writing this feature: Since NVDA supports "
"multiple configuration profiles and since some broadcasters were hosting "
"multiple shows, I thought it would be a good idea to implement a similar "
"feature in the SPL add-on. Thus, I envisioned broadcast profiles to be used "
"primarily by people hosting multiple shows, with each show defined as a "
"profile."
msgstr ""
"Había una razón importante para crear esta característica: ya que NVDA "
"soporta varios perfiles de configuración y ya que algunos locutores "
"presentan varios programas, pensé que sería una buena idea implementar una "
"característica similar en el complemento. Por lo tanto, preví que los "
"perfiles de emisión serían usados principalmente por gente que tuviera "
"varios programas, definiendo un perfil para cada programa."

#: ..\python_docs\spladdoninternals.py:821
msgid ""
"In March and April 2015, I started rewriting certain parts of add-on "
"configuration manager (splstudio.splconfig) in preparation for developing "
"broadcast profiles (now included as part of add-on 6.0). I started by "
"writing todo comments (where appropriate) describing what the future feature "
"should be like. I then modified initConfig and saveConfig (discussed in app "
"module sections), initially telling them to work with the default profile "
"(the one and only configuration map then), then I left it alone until add-on "
"5.0 was released in June 2015."
msgstr ""
"En marzo y abril de 2015, comencé a reescribir ciertas partes del gestor de "
"configuración del complemento (splstudio.splconfig) como preparación para "
"desarrollar los perfiles de emisión (incluidos ahora como parte del "
"complemento 6.0). Comencé anotando algunas tareas (donde correspondía) "
"describiendo cómo debería ser la característica futura. Después modifiqué "
"initConfig y saveConfig (expuestas en los artículos del módulo de "
"aplicación), diciéndoles inicialmente que trabajaran con el perfil "
"predeterminado (el único mapa de configuración por entonces), luego las dejé "
"solas hasta que se publicó el complemento 5.0 en junio de 2015."

#: ..\python_docs\spladdoninternals.py:822
msgid ""
"In June 2015, I opened a new branch (initially using the codename \"starfish"
"\") to house code related to broadcast profiles. Before any \"real\" code "
"was written, I studied NVDA source code dealing with configuration profiles "
"to learn more about how Jamie (James Teh from NV Access, now Mozilla) "
"implemented this feature. Once I understood how it worked, I copied, pasted "
"and changed the code to match the overall add-on code base (giving nV Access "
"the credit they deserve)."
msgstr ""
"En junio de 2015, abrí una nueva rama (usando inicialmente el nombre "
"\"starfish\") para alojar el código relacionado con los perfiles de emisión. "
"Antes de escribir cualquier código \"real\", estudié el código fuente de "
"NVDA relacionado con los perfiles de configuración para aprender más sobre "
"cómo Jamie (James Teh de NV Access, ahora en Mozilla) implementó esta "
"característica. Una vez entendí cómo funcionaba, copié, pegué y modifiqué el "
"código para que encajara con el del complemento (dando a NV Access el "
"crédito que merece)."

#: ..\python_docs\spladdoninternals.py:823
msgid ""
"One of the first things I had to decide was how to store profiles. I "
"experimented with using ConfigObj sections, one per profile, but this proved "
"to be problematic (a profile could be given the name of an existing "
"configuration map key). I then went back to NVDA source code to find out how "
"NV Access solved this problem (using separate ini files), implemented it, "
"and was met with another problem: transfering values between profiles. This "
"was resolved by specifying whether a setting was \"global\" (applies to all "
"profiles) or specific to a profile. Next came profile controls in the add-on "
"settings dialog and using choice events to set alarm values using values "
"from the selected profile."
msgstr ""
"Una de las primeras cosas que tenía que decidir era cómo almacenar los "
"perfiles. Experimenté usando secciones de ConfigOBJ, una por perfil, pero "
"resultó que daba problemas (se podía dar a un perfil el nombre de la clave "
"de un mapa existente). Entonces fui de vuelta al código fuente de NVDA para "
"saber cómo resolvió NV Access este problema (usando archivos ini separados), "
"lo implementé, y me encontré con otro problema: la transferencia de valores "
"entre perfiles. Esto lo resolví especificando si un ajuste era \"global"
"\" (se aplica a todos los perfiles) o específico de un perfil. Lo siguiente "
"que vino fueron los controles en el diálogo de configuración del complemento "
"y usar eventos de elección para establecer valores para la alarma usando los "
"valores del perfil seleccionado."

#: ..\python_docs\spladdoninternals.py:824
msgid ""
"The last thing I did before merging the broadcast profiles branch to master "
"branch in July was revising configuration error dialog and writing "
"documentation for broadcast profiles. Once the documentation was ready and "
"small issues were fixed after going through many rounds of testing (on my "
"own computer and from the profiles branch itself), broadcast profiles branch "
"was merged into master. But the development didn't stop there: thanks to "
"provisions I made, it was quite simple to implement instant switch profiles "
"(again it had issues which are now largely resolved)."
msgstr ""
"Lo último que hice antes de mezclar la rama de perfiles de emisión en la "
"rama master en julio fue revisar el diálogo de error de configuración y "
"escribir documentación para los perfiles de emisión. Una vez la "
"documentación estuvo lista y se solucionaron pequeños errores después de "
"hacer muchas rondas de pruebas (en mi propio ordenador y desde la rama de "
"perfiles), se mezcló la rama de perfiles de emisión en master. Pero el "
"desarrollo no se detuvo ahí: gracias a las previsiones que hice, fue "
"bastante simple implementar los perfiles de cambio instantáneo (de nuevo "
"hubo problemas que ya están de sobra resueltos)."

#: ..\python_docs\spladdoninternals.py:825
msgid ""
"### Dealing with threaded code: headaches during development of background "
"encoder monitoring feature"
msgstr ""
"### Trato con código en hilos: dolores de cabeza durante el desarrollo de la "
"característica de monitorización del codificador en segundo plano"

#: ..\python_docs\spladdoninternals.py:826
msgid ""
"You may recall our discussion of Cart Explorer and how it went through "
"extensive testing to arrive at the current state (this was a difficult code "
"segment). When it comes to difficulty, nothing beats multithreaded code, "
"especially if it involves multiple threads working in parallel (rather, "
"almost parallel), and I tasted this when writing background encoder monitor "
"(add-on 5.0). This involved tracking how many threads were running to make "
"sure no unnecessary threads were running, catching suttle errors and race "
"conditions (a connection attempt could run a thread without checking if the "
"encoder is being monitored) and so on. Thankfully, I went through a similar "
"set of problems a few months earlier when I struggled with library scan (add-"
"on 4.0), and that experience taught me to be careful with threads (and to "
"experience fewer headaches)."
msgstr ""
"Puedes recordar nuestra exposición sobre el explorador cart y cómo pasó unas "
"extensas pruebas hasta llegar a su estado actual (fue un segmento de código "
"difícil). Cuando hablamos de dificultad, nada supera al código multihilo, "
"especialmente si implica varios hilos trabajando en paralelo (bueno, casi en "
"paralelo). Yo saboreé esto al programar el monitor del codificador en "
"segundo plano (complemento 5.0). Esto implicó rastrear cuántos hilos estaban "
"ejecutándose para asegurarse de que no había hilos innecesarios, capturar "
"errores y condiciones de carrera (un intento de conexión podía lanzar un "
"hilo sin comprobar si el codificador estaba siendo monitorizado) y demás. "
"Afortunadamente, pasé por unos problemas similares unos meses atrás cuando "
"desarrollé el escaneo de biblioteca (complemento 4.0), y esa experiencia me "
"enseñó a tener cuidado con los hilos (y experimentar menos dolores de "
"cabeza)."

#: ..\python_docs\spladdoninternals.py:827
msgid "### Add-on development process"
msgstr "### El proceso de desarrollo del complemento"

#: ..\python_docs\spladdoninternals.py:828
msgid ""
"Follow me as I show you how a typical SPL add-on version is developed, "
"released and maintained:"
msgstr ""
"Sígueme mientras te muestro cómo se desarrolla, publica y mantiene una "
"versión típica del complemento para SPL:"

#: ..\python_docs\spladdoninternals.py:829
msgid ""
"1. Before starting work on the new add-on version, I write down some goals "
"the add-on should achieve, including feature ideas, user (your) suggestions "
"and so on. With changes to the process in 2017, a feature development may "
"span multiple versions."
msgstr ""
"1. Antes de comenzar a trabajar en la nueva versión del complemento, apunto "
"algunos objetivos que el complemento debería alcanzar, incluyendo ideas de "
"características, sugerencias del usuario (tuyas) y demás. Con los cambios "
"del proceso en 2017, el desarrollo de una característica puede hacerse a lo "
"largo de varias versiones."

#: ..\python_docs\spladdoninternals.py:830
msgid ""
"2. I then hold a conference call with add-on users to see what they think "
"about some ideas and gather feedback (these are also written down)."
msgstr ""
"2. A continuación hago una conferencia por llamada con usuarios del "
"complemento para ver qué piensan de algunas ideas y recopilar comentarios "
"(que también me apunto)."

#: ..\python_docs\spladdoninternals.py:831
msgid ""
"3. I then create separate branches for each feature in order to isolate  "
"code and not to break existing code."
msgstr ""
"3. Después creo ramas separadas para cada característica para aislar código "
"y no romper el código existente."

#: ..\python_docs\spladdoninternals.py:832
msgid ""
"4. Next, I write todo comments reminding myself as to what the feature "
"should be like, then I start working on it. As each feature is being "
"developed, I do mental simulations as to how you might use the feature under "
"development, such as possible errors, messages spoken and so on."
msgstr ""
"4. Después, escribo comentarios para recordarme a mí mismo cómo debería ser "
"la característica, luego empiezo a trabajar en ella. Según se va "
"desarrollando cada característica, hago simulaciones mentales sobre cómo "
"podrías usar la característica en desarrollo, posibles errores, mensajes "
"verbalizados y así."

#: ..\python_docs\spladdoninternals.py:833
msgid ""
"5. Once the feature is quite stable, I test the feature to uncover bugs and "
"to fill in the missing pieces. When it comes to testing, I test the new "
"feature branch on both of my computers running different versions of Studio "
"to make sure it works across versions (if not, I go back and modify the code "
"to recognize differences between Studio versions)."
msgstr ""
"5. Una vez la característica está bastante estable, la pruebo para descubrir "
"fallos y rellenar los huecos que faltan. Cuando pasa a pruebas, pruebo la "
"nueva rama de características en mis dos ordenadores, que ejecutan versiones "
"distintas de Studio, para asegurarme de que funciona entre versiones (si no, "
"vuelvo atrás y modifico el código para reconocer las diferencias entre "
"versiones de Studio)."

#: ..\python_docs\spladdoninternals.py:834
msgid ""
"6. Starting in fall 2015, I've merged development branches into a staging "
"branch for testing purposes. This branch is also used to generate try (Test "
"Drive program) builds so those who've signed up for early access program can "
"leave feedback (try builds are generated about once a week)."
msgstr ""
"6. Empezando a finales del 2015, he mezclado las ramas de desarrollo en una "
"única rama con propósitos de prueba. Esta rama también se usa para generar "
"compilaciones de prueba (programa de unidad de pruebas), así que todo el que "
"se ha registrado para el programa de acceso previo puede dejar comentarios "
"(las compilaciones de prueba se generan aproximadamente una vez a la semana)."

#: ..\python_docs\spladdoninternals.py:835
msgid ""
"7. After testing the feature for a while and if the feature is stable, I "
"merge the feature branch into master."
msgstr ""
"7. Después de probar la característica durante un rato y si esta es estable, "
"mezclo la rama de la característica en master."

#: ..\python_docs\spladdoninternals.py:836
msgid ""
"8. Every few weeks, I publish master branch snapshots to gather feedback "
"from users willing to test drive snapshots. With the advent of add-on "
"updates in add-on 7.0, one can update between snapshots or stable versions "
"(whichever branch one is using, the update check routine wil use that "
"branch; for example, if one is using master snapshots, updates will be "
"fetched from master branch only)."
msgstr ""
"8. Cada pocas semanas, publico versiones de desarrollo de la rama master "
"para recopilar comentarios de los usuarios que estén dispuestos a probar "
"versiones de desarrollo dirigidas. Con la llegada de las actualizaciones del "
"complemento en la versión 7.0, cualquiera puede actualizar entre versiones "
"estables o de prueba (la rama en uso será utilizada por el actualizador; por "
"ejemplo, si alguien usa las versiones de desarrollo master, las "
"actualizaciones sólo se recuperarán desde la rama master)."

#: ..\python_docs\spladdoninternals.py:837
msgid ""
"9. At some point, I set release target window for the next add-on version "
"(for 6.0, it was December 2015). This determines when feature freeze should "
"be and beta release window (for 6.0, beta 1 was released in October 2015). "
"Between feature freeze and the first beta release, I concentrate on code "
"refinements and bug fixes. This has changed significantly in 2017 (see "
"below)."
msgstr ""
"9. En algún momento, establezco la fecha de la publicación de la próxima "
"versión del complemento (para la versión 6.0, fue en diciembre del 2015). "
"Esto determina cuándo debería ser la congelación de características y la "
"fecha de liberación de la beta (para el 6.0, la beta 1 se publicó en octubre "
"del 2015). Entre la congelación de características y la primera liberación "
"beta, me concentro en refinar el código y arreglar fallos. Esto ha cambiado "
"significativamente en 2017 (mira más abajo)."

#: ..\python_docs\spladdoninternals.py:838
msgid ""
"10. After going through several beta cycles (typically two), I ask NVDA "
"community add-on reviewers to review my add-on code and request add-on "
"release during the release window (this is done by merging master branch "
"into stable branch)."
msgstr ""
"10. Después de hacer varios ciclos beta (generalmente dos), pido a los "
"revisores de la comunidad de NVDA que revisen el código de mi complemento y "
"pidan su publicación en las fechas apropiadas (esto se hace mezclando la "
"rama master en la rama stable)."

#: ..\python_docs\spladdoninternals.py:839
msgid ""
"11. Once the add-on version is released, subsequent maintenance versions "
"(localization updates, bug fixes, minor tweaks) will be released from the "
"stable branch, with the master branch containing the code for the next major "
"version."
msgstr ""
"11. Una vez se publica la versión del complemento, las siguientes versiones "
"de mantenimiento (actualización de traducciones, solución de fallos, "
"retoques menores) se liberarán desde la rama stable, con la rama master "
"conteniendo el código para la siguiente gran versión."

#: ..\python_docs\spladdoninternals.py:840
msgid ""
"12. Once the next version enters beta cycle, further maintenance releases "
"may or may not happen (an exception is long-term support release, described "
"below)."
msgstr ""
"12. Una vez la siguiente versión entra en el ciclo de betas, podría haber o "
"podría no haber más versiones de mantenimiento (una excepción son las "
"versiones de soporte extendido, descritas más abajo)."

#: ..\python_docs\spladdoninternals.py:841
msgid "#### Changes in 2017"
msgstr "#### Cambios en 2017"

#: ..\python_docs\spladdoninternals.py:842
msgid ""
"In late 2016, I and some users had a conference call regarding the future "
"direction of the add-on. During this call, participants felt that the add-on "
"now includes all the features people need, so it was decided to scale back "
"on features and focus on compatibility with new Studio releases. In the end, "
"it was decided that a version of the add-on to be released in 2017 will be "
"the final major version of this add-on, with future updates being byte-sized "
"chunks."
msgstr ""
"Ya entrado 2016, algunos usuarios y yo tuvimos una conferencia por llamada "
"relacionada con la dirección futura del complemento. Durante esta llamada, "
"los participantes sentían que el complemento ya incluye todas las funciones "
"que la gente necesita, por lo que se decidió dejar de escalar en "
"características y enfocarse en la compatibilidad con nuevas versiones de "
"Studio. Al final, se decidió que una versión del complemento que se "
"publicaría en 2017 sería la versión final principal de este complemento, con "
"las futuras actualizaciones siendo muy pequeñas."

#: ..\python_docs\spladdoninternals.py:843
msgid ""
"This decision also aligned with my other add-ons where new versions were "
"released every month or so, along with the fact that features are complete "
"for most add-ons. The new regular update schedule for SPL add-on was "
"implemented as of June 2017."
msgstr ""
"Esta decisión también se alineó con mis otros complementos, donde las nuevas "
"versiones se liberaban cada mes o así, junto al hecho de que las "
"características están completas en la mayoría de complementos. La nueva "
"programación regular de actualizaciones del complemento de SPL se implementó "
"en junio de 2017."

#: ..\python_docs\spladdoninternals.py:844
msgid "There were two more implications of this decision:"
msgstr "Esta decisión implicaba dos cosas más:"

#: ..\python_docs\spladdoninternals.py:845
msgid ""
"* No more waits: a new stable feature should not be held up for up to six "
"months if it is ready for the public, thus updates include both new features "
"and bug fixes."
msgstr ""
"* No más esperas: una nueva característica estable no debería retenerse "
"hasta dentro de seis meses si está lista para el público, y por tanto las "
"actualizaciones incluyen nuevas características y solución de fallos."

#: ..\python_docs\spladdoninternals.py:846
msgid ""
"* The Test Drive program (see below) should not be an exclusive thing "
"anymore, but an opt-in process, as I felt early feedback loop is crucial to "
"success of a product such as this add-on."
msgstr ""
"* El programa de pruebas dirigidas (mira más abajo) no debería ser algo "
"exclusivo nunca más, sino un proceso al que se pueda optar, ya que yo sentía "
"que el bucle de retroalimentación temprana es crucial para el éxito de un "
"producto como este complemento."

#: ..\python_docs\spladdoninternals.py:847
msgid "With this in mind, the following things were changed in 2017:"
msgstr "Con esto en mente, las siguientes cosas cambiaron en 2017:"

#: ..\python_docs\spladdoninternals.py:848
msgid ""
"* No more betas: the development branch (now called slow ring) is considered "
"live beta branch."
msgstr ""
"* No más betas: la rama de desarrollo (ahora llamada anillo lento) se "
"considera como rama de betas."

#: ..\python_docs\spladdoninternals.py:849
msgid ""
"* Anyone can switch to try build branch (called fast ring snapshots) "
"provided that they are willing to provide early feedback."
msgstr ""
"* Cualquiera puede cambiar a la rama de compilaciones de prueba (llamada "
"anillo rápido de instantáneas) suponiendo que estén interesados en "
"proporcionar retroalimentación temprana."

#: ..\python_docs\spladdoninternals.py:850
msgid ""
"* Long-term support updates are now tied to new major Studio releases. This "
"criteria was extended in late 2017 to include critical changes to NVDA (see "
"below)."
msgstr ""
"* Las actualizaciones de soporte extendido ahora están atadas a las nuevas "
"versiones principales de Studio. Este criterio se extendió entrado 2017 para "
"incluir cambios críticos en NVDA (mira más abajo)."

#: ..\python_docs\spladdoninternals.py:851
msgid "#### Further changes in 2018"
msgstr "#### Más cambios en 2018"

#: ..\python_docs\spladdoninternals.py:852
msgid ""
"In July 2018, NV Access announced changes to NVDA's release process in order "
"to make testing and integration easier. Prior to this, an NVDA feature was "
"incubated in the next snapshot for at least two weeks, and this meant having "
"to deal with increasing number of pull requests which sometimes produced "
"conflicts. To avoid this, and to let features come to master branch "
"directly, what used to be live beta (master) branch became \"alpha\" "
"snapshots. People who wanted more stability were moved to beta releases."
msgstr ""
"En julio de 2018, NV Access informó sobre cambios en el proceso de "
"liberación para facilitar la integración y las pruebas. Antes de eso, se "
"estaba incubando una nueva función de NVDA en la versión de desarrollo next "
"durante al menos dos semanas, y esto significaba tratar con el creciente "
"número de solicitudes de cambio que en ocasiones producían conflictos. Para "
"evitar esto, y hacer que las nuevas funciones vinieran a la rama master "
"directamente, lo que solía ser la rama de beta en vivo (master) se convirtió "
"en las versiones de desarrollo \"alpha\". Se movió a la gente que quería más "
"estabilidad a las versiones beta."

#: ..\python_docs\spladdoninternals.py:853
msgid ""
"On the SPL add-on side, Test Drive Fast and Slow ring builds have become "
"identical in late July 2018. I also felt that add-on development has slowed "
"down considerably, as well as preparing for the next long-term support "
"release (18.09), thus I felt an overhaul of Test Drive Program was in order."
msgstr ""
"Por parte del complemento para SPL, las compilaciones de los anillos lento y "
"rápido del programa de prueba se han vuelto idénticas a finales de agosto de "
"2018. He sentido también que el desarrollo del complemento se ha ralentizado "
"considerablemente mientras se preparaba la siguiente versión LTS (18.09) y, "
"por tanto, reacondicioné el programa de unidad de pruebas."

#: ..\python_docs\spladdoninternals.py:854
msgid ""
"Then in August 2018, I released Add-on Updater, a proof of concept add-on "
"that allows NVDA to check for add-on updates for all add-ons registered with "
"NVDA Community Add-ons website. In its early days, SPL add-on was excluded "
"because it interfered with Add-on Updater's own update check facility. In "
"reality, I generalized SPL add-on's update check code and transfered it to "
"the new Add-on Updater, hence almost identical internals."
msgstr ""
"Después, en agosto de 2018, publiqué Add-on Updater, un complemento que "
"actuaba como prueba de concepto que permite que NVDA busque actualizaciones "
"de todos los complementos registrados en el sitio web de complementos de la "
"comunidad. En sus primeros días, se excluyó el complemento de SPL porque "
"interfería con la propia función de búsqueda de actualizaciones de Add-on "
"Updater. En realidad, generalicé el código de búsqueda de actualizaciones "
"del complemento de SPL y lo transferí al nuevo Add-on Updater, por lo que "
"era casi idéntico por dentro."

#: ..\python_docs\spladdoninternals.py:855
msgid ""
"Given that my long-term goal is to let NVDA itself check for SPL add-on "
"updates, coupled with observations from above, I asked the community if it "
"would be better to change the nature of Test Drive Fast ring and to let Add-"
"on Updater check for all add-on updates. The community agreed, hence the "
"following changes were made in August 2018 prior to release of 18.09:"
msgstr ""
"Dado que mi objetivo a largo plazo es hacer que NVDA busque por sí mismo las "
"actualizaciones del complemento para SPL, además de las observaciones "
"anteriores, pregunté a la comunidad si sería mejor cambiar la naturaleza del "
"anillo rápido de la unidad de pruebas para que sea Add-on Updater el que "
"busque todas las actualizaciones. La comunidad estuvo deacuerdo, por lo que "
"se llevaron a cabo los siguientes cambios en agosto de 2018 antes de "
"publicar la versión 18.09:"

#: ..\python_docs\spladdoninternals.py:856
msgid ""
"* Test Drive Fast and Slow rings were combined into a single \"development\" "
"channel. Consequently, there is no more update channel selection capability, "
"with users encouraged to obtain the right releases from add-ons website. "
"This was extended in September 2018 to cover long-term support releases."
msgstr ""
"* Los anillos rápido y lento de la unidad de pruebas se combinaron en un "
"único canal de \"desarrollo\". Como consecuencia ya no existe la posibilidad "
"de elegir el canal de actualización, siendo los usuarios los encargados de "
"obtener la versión correcta desde la web de complementos. Esto se extendió "
"en septiembre de 2018 para cubrir las versiones de soporte extendido."

#: ..\python_docs\spladdoninternals.py:857
msgid ""
"* A new concept of \"pilot features\" replaced Test Drive Fast, configurable "
"via a checkbox and internal flags."
msgstr ""
"* Un nuevo concepto de \"funciones piloto\" reemplazó al anillo rápido de la "
"unidad de pruebas, configurable mediante una casilla de verificación e "
"indicadores internos."

#: ..\python_docs\spladdoninternals.py:858
msgid ""
"* New (risky) features under development will be enabled if pilot features "
"facility is turned on, otherwise content is identical to regular development "
"build."
msgstr ""
"* Las nuevas funciones (arriesgadas) en desarrollo se activarán si la opción "
"de funciones piloto se activa, en cualquier otro caso el contenido es "
"idéntico al de las versiones de desarrollo regulares."

#: ..\python_docs\spladdoninternals.py:859
msgid ""
"* Add-on update checking facility is now taken care of by Add-on Updater, "
"and in the future, to be done by NVDA itself. Consequently, add-on update "
"feature and the source code that controlled it has been removed in December "
"2018."
msgstr ""
"* La función de búsqueda de actualizaciones del complemento la lleva a cabo "
"Add-on Updater, y en el futuro, el propio NVDA. Como consecuencia, la "
"función de búsqueda de actualizaciones y el código fuente que la controlaba "
"se han eliminado en diciembre de 2018."

#: ..\python_docs\spladdoninternals.py:860
msgid "#### Long-term support release"
msgstr "#### Versión de soporte extendido"

#: ..\python_docs\spladdoninternals.py:861
msgid ""
"A typical add-on version is supported until the next add-on version is "
"released (currently several weeks to months). However, there are times when "
"an add-on version receives extended support (termed long-term support (LTS) "
"release). This happens if the next major version of Studio is released, a "
"version of Studio with user interface changes is released, or critical "
"changes are expected in future NVDA releases such as ending support for a "
"Windows version."
msgstr ""
"Una versión típica de un complemento se soporta hasta que se publica la "
"siguiente versión del complemento (actualmente varias semanas o meses). Sin "
"embargo, hay veces en las que una versión de un complemento recibe soporte "
"extendido (llamadas versiones lts). Esto pasa si se publica la siguiente "
"versión de Studio, se publica una versión de Studio con cambios en la "
"interfaz de usuario, o se esperan cambios críticos en versiones futuras de "
"NVDA tales como finalización de soporte para una versión de Windows."

#: ..\python_docs\spladdoninternals.py:862
msgid ""
"A LTS version is a major version or a major periodic release of the SPL add-"
"on with some notable differences:"
msgstr ""
"Una versión lts es una versión mayor o una versión periódica del complemento "
"de SPL con algunas diferencias destacables:"

#: ..\python_docs\spladdoninternals.py:863
msgid ""
"* Support duration: A LTS version is supported for at least twelve months."
msgstr ""
"* Duración del soporte: una versión LTS recibe soporte durante al menos doce "
"meses."

#: ..\python_docs\spladdoninternals.py:864
msgid ""
"* Features: A LTS version may contain some features from future add-on "
"releases provided that they can be safely backported."
msgstr ""
"* Características: una versión lts puede contener algunas características de "
"versiones futuras del complemento que pueden agregarse de forma segura."

#: ..\python_docs\spladdoninternals.py:865
msgid ""
"* Studio version supported: A LTS version is the last version to support the "
"oldest supported Studio version. This is designed to give people plenty of "
"time to upgrade to newer Studio releases."
msgstr ""
"* Versión soportada de Studio: una versión lts es la última versión en dar "
"soporte a la versión de Studio más antigua soportada. Esto se diseña así "
"para dar a la gente todo el tiempo posible para actualizarse a una nueva "
"versión de Studio."

#: ..\python_docs\spladdoninternals.py:866
msgid ""
"* Last version with old NVDA technology in use: in some cases, LTS releases "
"are made to support users of old NVDA releases. After the LTS release is "
"created, add-on source code will shift to using newer code from NVDA. This "
"criteria was first applied in 18.09 as a result of NVDA's end of support for "
"Windows XP, Vista and 7 without Service Pack 1, as well as transition to "
"Python 3."
msgstr ""
"* Última versión que usa tecnología de NVDA antigua: en algunos casos, las "
"versiones lts están hechas para dar soporte a usuarios de versiones antiguas "
"de NVDA. Después de crear la versión lts, el código fuente del complemento "
"cambiará para usar el código más reciente de NVDA. Este criterio se aplicó "
"primero a la versión 18.09 como resultado del fin de soporte de NVDA para "
"Windows XP, Vista y 7 sin Service Pack 1, así como para la transición a "
"Python 3."

#: ..\python_docs\spladdoninternals.py:867
msgid ""
"As of June 2021, the most recent LTS version is add-on 20.09.x (September "
"2020 to April 2021). Previous LTS releases have included 18.09.x (September "
"2018 to December 2019), 15.x (formerly 7.x until October 2016; October 2016 "
"to April 2018) and 3.x (September 2014 to June 2015). For example, add-on 3."
"x was maintained thus:"
msgstr ""
"A fecha de junio de 2021, la versión LTS más reciente es la 20.09.x (desde "
"septiembre de 2020 hasta abril de 2021). Entre las versiones LTS anteriores "
"se incluyen la 18.09.x (desde septiembre de 2018 a diciembre de 2019), la 15."
"x, conocida como 7.x hasta octubre de 2016 (de octubre de 2016 a abril de "
"2018). La versión lts anterior era la 3.x (de septiembre de 2014 a junio de "
"2015). Por ejemplo, el complemento 3.x se mantuvo de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:868
msgid "1. Add-on 3.0 was released in September 2014."
msgstr "1. El complemento 3.0 fue publicado en 2014."

#: ..\python_docs\spladdoninternals.py:869
msgid ""
"2. Add-on 3.5 (December 2014) could have been the last maintenance version "
"for add-on 3.x if it was not a LTS version."
msgstr ""
"2. El complemento 3.5 (diciembre de 2014) podría haber sido la última "
"versión de mantenimiento del complemento 3.x si no hubiera sido una versión "
"lts."

#: ..\python_docs\spladdoninternals.py:870
msgid ""
"3. When add-on 4.0 was released (January 2015), add-on 3.6 was released, "
"backporting some features from 4.0. Users were told that add-on 3.x will be "
"the last version to support Studio versions earlier than 5.00. From that "
"time on, add-on 3.x was taken off the stable branch and was moved to an "
"internal branch."
msgstr ""
"3. Cuando se publicó el complemento 4.0 (enero de 2015), se liberó el "
"complemento 3.6, que traía algunas características del 4.0. Se dijo a los "
"usuarios que el complemento 3.x sería el último en dar soporte a versiones "
"de Studio anteriores a la 5.00. A partir de entonces, el complemento 3.x se "
"trasladó desde la rama stable a una rama interna."

#: ..\python_docs\spladdoninternals.py:871
msgid ""
"4. When add-on 5.0 beta was released (May 2015), add-on 3.x (3.9 was "
"available then) entered end of support countdown (no more maintenance "
"releases)."
msgstr ""
"4. Cuando se publicó la beta del complemento 5.0 (mayo de 2015), el "
"complemento 3.x (3.9 por entonces) entró en la cuenta atrás de fin de "
"soporte (sin más versiones de mantenimiento)."

#: ..\python_docs\spladdoninternals.py:872
msgid ""
"5. A few weeks later, when add-on 5.0 came out (June 2015), add-on 3.x "
"became unsupported."
msgstr ""
"5. Unas semanas más tardes, cuando llegó el complemento 5.0 (junio de 2015), "
"el complemento 3.x se quedó sin soporte."

#: ..\python_docs\spladdoninternals.py:873
msgid "### Final thoughts"
msgstr "### Consideraciones finales"

#: ..\python_docs\spladdoninternals.py:874
msgid ""
"As I end this article on StationPlaylist Add-on Internals, I feel it is time "
"I reveal why my add-ons are free: it is because I love you users and as a "
"service for NVDA user and developer community (and in extension, to all "
"blind broadcasters using SPL Studio). What brings me joy as an add-on writer "
"is the fact that this add-on (and accompanying documentation) has made "
"impact in your lives and lives of listeners to your shows, as well as to "
"other NVDA users and developers around the world. Thank you users for your "
"continued support and feedback, and I promise once again that all my add-on "
"code (including SPL add-on) will be free and anyone is welcome to study and "
"improve upon it."
msgstr ""
"Según termino este artículo sobre los interiores del complemento de "
"StationPlaylist Studio, siento que es el momento de que revele por qué mis "
"complementos son gratuitos: es porque amo a los usuarios como un servicio "
"para la comunidad de usuarios y desarrolladores de NVDA (y en extensión, a "
"todos los locutores que usan SPL Studio). Lo que me trae alegría como "
"escritor de complementos es el hecho de que este complemento (y la "
"documentación que lo acompaña) haya impactado en vuestras vidas y las vidas "
"de los oyentes de vuestros programas, así como a otros usuarios y "
"desarrolladores de NVDA por todo el mundo. Gracias a vosotros, usuarios, por "
"vuestro soporte continuo y vuestros comentarios, prometo una vez más que "
"todo el código de mis complementos (incluido el complemento de SPL) será "
"libre y cualquiera es bienvenido para estudiarlo y mejorarlo."

#: ..\python_docs\spladdoninternals.py:875
msgid ""
"For add-on writers looking for quality add-on documentation, I hope this "
"series gave you an inspiration as to how to write amazing documentation in "
"your future projects. For people new to add-on writing or for those "
"interested in writing an add-on, I hope this Add-ons Internals series served "
"as a handy resource for your projects, and in extension, gave you an idea as "
"to how certain NVDA functions work. If you'd like to reference this "
"documentation or use it as a blueprint, you are more than welcome to do so. "
"Thank you community add-on reviewers for your continued support and reviews."
msgstr ""
"Para creadores de complementos que buscan documentación de calidad, espero "
"que este artículo os haya inspirado para escribir buena documentación en "
"vuestros proyectos futuros. Para la gente nueva en el desarrollo de "
"complementos o para aquellos interesados en desarrollar un complemento, "
"espero que este artículo de complementos de NVDA vistos por dentro haya "
"servido como un recurso útil para vuestros proyectos, y extensión, os haya "
"dado una idea de cómo funcionan ciertas funciones de NVDA. Si queréis hacer "
"referencia a esta documentación o usarla como un modelo, os invito a "
"hacerlo. Gracias a los revisores de la comunidad de complementos por vuestro "
"soporte continuo y vuestras revisiones."

#: ..\python_docs\spladdoninternals.py:876
msgid "### Important notices and credits"
msgstr "### Avisos importantes y créditos"

#: ..\python_docs\spladdoninternals.py:877
msgid ""
"I'd like to thank StationPlaylist staff for continued collaboration with "
"screen reader users in regards to accessibility of Studio. A special thanks "
"goes to Jamie Teh from NV Access and Geoff Shang (original add-on author) "
"for giving me and others a foundation for future goodies. As always, the "
"biggest thanks goes to you, the users of SPL add-on for your continued "
"feedback and teaching me new things about studio."
msgstr ""
"Me gustaría dar las gracias al personal de StationPlaylist Studio por su "
"colaboración continua con usuarios de lectores de pantalla en cuanto a la "
"accesibilidad de Studio. Va un agradecimiento especial para Jamie Teh de NV "
"Access y Geoff Shang (el autor original del complemento) por darme a mí y a "
"otros una base de la que partir. Y como siempre, el mayor agradecimiento es "
"para vosotros, los usuarios del complemento para SPL, por vuestros continuos "
"comentarios y por enseñarme cosas nuevas sobre Studio."

#: ..\python_docs\spladdoninternals.py:878
msgid ""
"Source code notice: to protect copyrights, parts of Studio API has not been "
"documented. Also, source code discussed throughout this series may change as "
"future add-on versions are developed."
msgstr ""
"Aviso del código fuente: para proteger los derechos de copia, no se han "
"documentado algunas partes de la api de Studio. Además, el código fuente "
"expuesto a lo largo de este artículo puede cambiar según se desarrollen "
"versiones futuras del complemento."

#: ..\python_docs\spladdoninternals.py:879
msgid ""
"Copyrights: StationPlaylist Studio, Track Tool and StationPlaylist Encoders "
"are copyright StationPlaylist.com. NonVisual Desktop Access is copyright "
"2006-2021 NV access Limited (released under GPL). SAM Encoders is copyright "
"Spatial Audio. Microsoft Windows and Windows API are copyright Microsoft "
"Corporation. Python is copyright Python Software Foundation. StationPlaylist "
"add-on for NVDA is copyright 2011, 2013-2021 Geoff Shang, Joseph Lee and "
"others (released under GPL). Other products mentioned are copyrighted by "
"owners of these products (licenses vary)."
msgstr ""
"Derechos de copia: StationPlaylist Studio, la herramienta de pista y los "
"codificadores de StationPlaylist tienen copyright de StationPlaylist.com. "
"NonVisual Desktop Access tiene copyright 2006-2021 de NV access Limited "
"(liberado bajo la GPL). Los codificadores SAM tienen copyright de Spatial "
"Audio. Microsoft Windows y la API de Windows tienen copyright de Microsoft "
"Corporation. Python tiene copyright de la Python Software Foundation. El "
"complemento StationPlaylist Studio para NVDA tiene copyright 2011, 2013-2021 "
"de Geoff Shang, Joseph Lee y otros (liberado bajo la GPL). Otros productos "
"mencionados tienen copyright de sus respectivos propietarios (las licencias "
"varían)."

#: ..\python_docs\spladdoninternals.py:880
msgid "## References"
msgstr "## Referencias"

#: ..\python_docs\spladdoninternals.py:881
msgid ""
"1. JAWS scripts for StationPlaylist Studio (Hartgen Consultancy): http://www."
"hartgen.org/studio.html"
msgstr ""
"1. Scripts de JAWS para StationPlaylist Studio (Hartgen Consultancy): http://"
"www.hartgen.org/studio.html"

#: ..\python_docs\spladdoninternals.py:882
msgid ""
"2. Window-Eyes app for StationPlaylist (Jeff Bishop/AI Squared): https://www."
"gwmicro.com/App_Central/Apps/App_Details/index.php?"
"scriptid=1268&readMore&media=print"
msgstr ""
"2. Aplicación de Window-Eyes para StationPlaylist (Jeff Bishop/AI Squared): "
"https://www.gwmicro.com/App_Central/Apps/App_Details/index.php?"
"scriptid=1268&readMore&media=print"

#: ..\python_docs\spladdoninternals.py:883
msgid ""
"3. Plug-in (Wikipedia): https://en.wikipedia.org/wiki/Plug-in_(computing)"
msgstr ""
"3. Plug-in (Wikipedia): https://en.wikipedia.org/wiki/Plug-in_(computing)"

#: ..\python_docs\spladdoninternals.py:884
msgid ""
"4. Application Programming Interface (Wikipedia): https://en.wikipedia.org/"
"wiki/Application_programming_interface"
msgstr ""
"4. Application Programming Interface (Wikipedia): https://en.wikipedia.org/"
"wiki/Application_programming_interface"

#: ..\python_docs\spladdoninternals.py:885
msgid ""
"5. Python 2.7.13 documentation overview (Python Software Foundation): "
"https://docs.python.org/2/"
msgstr ""
"5. Descripción de la documentación de Python 2.7.13 (Python Software "
"Foundation): https://docs.python.org/2/"

#: ..\python_docs\spladdoninternals.py:886
msgid "6. Handle (Wikipedia): https://en.wikipedia.org/wiki/Handle_(computing)"
msgstr ""
"6. Handle (Wikipedia): https://en.wikipedia.org/wiki/Handle_(computing)"

#: ..\python_docs\spladdoninternals.py:887
msgid ""
"7. What is a Windows handle (Stack Overflow): http://stackoverflow.com/"
"questions/902967/what-is-a-windows-handle"
msgstr ""
"7. Qué es un manejador de Windows (Stack Overflow): http://stackoverflow.com/"
"questions/902967/what-is-a-windows-handle"

#: ..\python_docs\spladdoninternals.py:888
msgid ""
"8. FindWindow (user32.dll) reference (Windows API): https://msdn.microsoft."
"com/en-us/library/windows/desktop/ms633499(v=vs.85).aspx"
msgstr ""
"8. Referencia de FindWindow (user32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms633499(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:889
msgid ""
"9. SendMessage (user32.dll) reference (Windows API): https://msdn.microsoft."
"com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx"
msgstr ""
"9. Referencia de SendMessage (user32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:890
msgid ""
"10. NVDA Developer Guide (NV Access): http://www.nvaccess.org/files/nvda/"
"documentation/developerGuide.html"
msgstr ""
"10. Guía del desarrollador de NVDA (NV Access): http://www.nvaccess.org/"
"files/nvda/documentation/developerGuide.html"

#: ..\python_docs\spladdoninternals.py:891
msgid ""
"11. OpenProcess (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms684320(v=vs.85).aspx"
msgstr ""
"11. Referencia de OpenProcess (kernel32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms684320(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:892
msgid "12. wxPython online docs: http://www.wxpython.org/onlinedocs.php"
msgstr ""
"12. Documentación en línea de wxPython: http://www.wxpython.org/onlinedocs."
"php"

#: ..\python_docs\spladdoninternals.py:893
msgid ""
"13. Higher order functions (How do you make a higher order function): http://"
"effbot.org/pyfaq/how-do-you-make-a-higher-order-function-in-python.htm"
msgstr ""
"13. Funciones de alto nivel (cómo hacer una función de alto nivel): http://"
"effbot.org/pyfaq/how-do-you-make-a-higher-order-function-in-python.htm"

#: ..\python_docs\spladdoninternals.py:894
msgid ""
"14. Time (Python documentation, Python Software Foundation): https://docs."
"python.org/2/library/time.html"
msgstr ""
"14. Time (Documentación de Python, Python Software Foundation): https://docs."
"python.org/2/library/time.html"

#: ..\python_docs\spladdoninternals.py:895
msgid ""
"15. GetTimeFormat (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/dd318130(v=vs.85).aspx"
msgstr ""
"15. Referencia de GetTimeFormat (kernel32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/dd318130(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:896
msgid "16. Event loop (Wikipedia): https://en.wikipedia.org/wiki/Event_loop"
msgstr ""
"16. Bucle de eventos (Wikipedia): https://en.wikipedia.org/wiki/Event_loop"

#: ..\python_docs\spladdoninternals.py:897
msgid ""
"17. Event-driven programming (Wikipedia): https://en.wikipedia.org/wiki/"
"Event-driven_programming"
msgstr ""
"17. Programación dirigida por eventos (Wikipedia): https://en.wikipedia.org/"
"wiki/Event-driven_programming"

#: ..\python_docs\spladdoninternals.py:898
msgid ""
"18. Sinclair, Rob. Microsoft Active Accessibility architecture, Microsoft "
"Developer Network, August 2000. https://msdn.microsoft.com/en-us/library/"
"ms971310.aspx"
msgstr ""
"18. Sinclair, Rob. Arquitectura de Microsoft Active Accessibility, Microsoft "
"Developer Network, Agosto del 2000. https://msdn.microsoft.com/en-us/library/"
"ms971310.aspx"

#: ..\python_docs\spladdoninternals.py:899
msgid ""
"19. UI Automation Overview, Microsoft Developer Network. https://msdn."
"microsoft.com/en-us/library/ms747327(v=vs.110).aspx"
msgstr ""
"19. Descripción de UI Automation, Microsoft Developer Network. https://msdn."
"microsoft.com/en-us/library/ms747327(v=vs.110).aspx"

#: ..\python_docs\spladdoninternals.py:900
msgid ""
"20. Java Access Bridge overview, Java SE Desktop Accessibility, Oracle. "
"http://www.oracle.com/technetwork/articles/javase/index-jsp-136191.html"
msgstr ""
"20. Descripción de Java Access Bridge, Java SE Desktop Accessibility, "
"Oracle. http://www.oracle.com/technetwork/articles/javase/index-jsp-136191."
"html"

#: ..\python_docs\spladdoninternals.py:901
msgid ""
"21. Introduction to OOP (Object-Oriented Programming) with Python, "
"Voidspace. http://www.voidspace.org.uk/python/articles/OOP.shtml"
msgstr ""
"21. Introducción a la POO (programación orientada a objetos) con Python, "
"Voidspace. http://www.voidspace.org.uk/python/articles/OOP.shtml"

#: ..\python_docs\spladdoninternals.py:902
#, python-format
msgid ""
"22. Non-Programmer's Tutorial for Python 3/Intro to Object Oriented "
"Programming in Python 3 - Wikibooks. https://en.wikibooks.org/wiki/Non-"
"Programmer%27s_Tutorial_for_Python_3/"
"Intro_to_Object_Oriented_Programming_in_Python_3"
msgstr ""
"22. Tutorial de no programadores para Python 3/Introducción a la "
"programación orientada a objetos en Python 3 - Wikibooks. https://en."
"wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_3/"
"Intro_to_Object_Oriented_Programming_in_Python_3"

#: ..\python_docs\spladdoninternals.py:903
msgid ""
"23. Method Resolution Order, The History of Python, june 23, 2010. http://"
"python-history.blogspot.com/2010/06/method-resolution-order.html"
msgstr ""
"23. Orden de resolución de métodos, la historia de Python, 23 de junio de "
"2010. http://python-history.blogspot.com/2010/06/method-resolution-order.html"

#: ..\python_docs\spladdoninternals.py:904
msgid ""
"24. List View, Microsoft Developer Network: https://msdn.microsoft.com/en-us/"
"library/windows/desktop/bb774737(v=vs.85).aspx"
msgstr ""
"24. Vista de lista, Microsoft Developer Network: https://msdn.microsoft.com/"
"en-us/library/windows/desktop/bb774737(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:905
msgid ""
"25. List View Messages, Microsoft Developer Network: https://msdn.microsoft."
"com/en-us/library/windows/desktop/ff485961(v=vs.85).aspx"
msgstr ""
"25. Mensajes de vista de lista, Microsoft Developer Network: https://msdn."
"microsoft.com/en-us/library/windows/desktop/ff485961(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:906
msgid ""
"26. List View Item structure, Microsoft Developer Network: https://msdn."
"microsoft.com/en-us/library/windows/desktop/bb774760(v=vs.85).aspx"
msgstr ""
"26. Estructura de un elemento de una vista de lista, Microsoft Developer "
"Network: https://msdn.microsoft.com/en-us/library/windows/desktop/"
"bb774760(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:907
msgid ""
"27. VirtualAllocEx (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/aa366890(v=vs.85).aspx"
msgstr ""
"27. Referencia de VirtualAllocEx (kernel32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/aa366890(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:908
msgid ""
"28. VirtualFreeEx (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/aa366894(v=vs.85).aspx"
msgstr ""
"28. Referencia de VirtualFreeEx (kernel32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/aa366894(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:909
msgid ""
"29. WriteProcessMemory (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms681674(v=vs.85).aspx"
msgstr ""
"29. Referencia de WriteProcessMemory (kernel32.dll) (Windows API): https://"
"msdn.microsoft.com/en-us/library/windows/desktop/ms681674(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:910
msgid ""
"30. ReadProcessMemory (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx"
msgstr ""
"30. Referencia de ReadProcessMemory (kernel32.dll) (Windows API): https://"
"msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:911
msgid ""
"31. Ctypes (Python documentation, Python Software Foundation): https://docs."
"python.org/2/library/ctypes.html"
msgstr ""
"31. Ctypes (Documentación de Python, Python Software Foundation): https://"
"docs.python.org/2/library/ctypes.html"

#: ..\python_docs\spladdoninternals.py:912
msgid ""
"32. Thread (Wikipedia): https://en.wikipedia.org/wiki/Thread_(computing)"
msgstr ""
"32. Thread (Wikipedia): https://en.wikipedia.org/wiki/Thread_(computing)"

#: ..\python_docs\spladdoninternals.py:913
msgid ""
"33. Multi-core processor (wikipedia): https://en.wikipedia.org/wiki/Multi-"
"core_processor"
msgstr ""
"33. Procesadores de múltiples núcleos (wikipedia): https://en.wikipedia.org/"
"wiki/Multi-core_processor"

#: ..\python_docs\spladdoninternals.py:914
msgid ""
"34. Multi-core introduction, Intel Developer Zone, March 5, 2012: https://"
"software.intel.com/en-us/articles/multi-core-introduction"
msgstr ""
"34. Introducción al multinúcleo, zona de desarrolladores de Intel, 5 de "
"marzo de 2012: https://software.intel.com/en-us/articles/multi-core-"
"introduction"

#: ..\python_docs\spladdoninternals.py:915
msgid ""
"35. Intel Core I7-5960X specifications (Intel ARK): http://ark.intel.com/"
"products/82930/Intel-Core-i7-5960X-Processor-Extreme-Edition-20M-Cache-up-"
"to-3_50-GHz"
msgstr ""
"35. Especificaciones de Intel Core I7-5960X (Intel ARK): http://ark.intel."
"com/products/82930/Intel-Core-i7-5960X-Processor-Extreme-Edition-20M-Cache-"
"up-to-3_50-GHz"

#: ..\python_docs\spladdoninternals.py:916
msgid ""
"36. Intel Xeon E7-8895V3 specifications (Intel ARK): http://ark.intel.com/"
"products/84689/Intel-Xeon-Processor-E7-8895-v3-45M-Cache-2_60-GHz"
msgstr ""
"36. Especificaciones de Intel Xeon E7-8895V3 (Intel ARK): http://ark.intel."
"com/products/84689/Intel-Xeon-Processor-E7-8895-v3-45M-Cache-2_60-GHz"

#: ..\python_docs\spladdoninternals.py:917
msgid ""
"37. Global Interpreter Lock (Python Wiki): https://wiki.python.org/moin/"
"GlobalInterpreterLock"
msgstr ""
"37. Global Interpreter Lock (Python Wiki): https://wiki.python.org/moin/"
"GlobalInterpreterLock"

#: ..\python_docs\spladdoninternals.py:918
msgid ""
"38. Threading (Python documentation, Python Software Foundation): https://"
"docs.python.org/2/library/threading.html"
msgstr ""
"38. Threading (Documentación de Python, Python Software Foundation): https://"
"docs.python.org/2/library/threading.html"

#: ..\python_docs\spladdoninternals.py:919
msgid ""
"39. Multiprocessing (Python documentation, Python Software Foundation): "
"https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing"
msgstr ""
"39. Multiprocessing (Documentación de Python, Python Software Foundation): "
"https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing"

#: ..\python_docs\spladdoninternals.py:920
msgid ""
"40. Comma-separated values (Wikipedia): https://en.wikipedia.org/wiki/Comma-"
"separated_values"
msgstr ""
"40. Valores separados por coma (Wikipedia): https://en.wikipedia.org/wiki/"
"Comma-separated_values"

#: ..\python_docs\spladdoninternals.py:921
msgid ""
"41. RFC 4180 (Common Format and MIME Type for Comma-Separated Values (CSV) "
"Files), Internet Engineering Task Force: https://tools.ietf.org/html/rfc4180"
msgstr ""
"41. RFC 4180 (formato común y tipo MIME para archivos de valores separados "
"por coma (CSV)), Internet Engineering Task Force: https://tools.ietf.org/"
"html/rfc4180"

#: ..\python_docs\spladdoninternals.py:922
msgid ""
"42. Import or export text (.txt or .csv) files, Microsoft Office Support for "
"Microsoft Excel: https://support.office.com/en-za/article/Import-or-export-"
"text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba"
msgstr ""
"42. Importar o exportar texto (archivos .txt or .csv), soporte de Microsoft "
"Office para Microsoft Excel: https://support.office.com/en-za/article/Import-"
"or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba"

#: ..\python_docs\spladdoninternals.py:923
msgid ""
"43. CSV (Python documentation, Python Software Foundation): https://docs."
"python.org/2/library/csv.html"
msgstr ""
"43. CSV (Documentación de Python, Python Software Foundation): https://docs."
"python.org/2/library/csv.html"

#: ..\python_docs\spladdoninternals.py:924
msgid "44. Cache (Wikipedia): https://en.wikipedia.org/wiki/Cache_(computing)"
msgstr "44. Caché (Wikipedia): https://en.wikipedia.org/wiki/Cache_(computing)"

#: ..\python_docs\spladdoninternals.py:925
msgid ""
"45. Os (Python documentation, Python Software Foundation): https://docs."
"python.org/2/library/os.html"
msgstr ""
"45. Os (Documentación de Python, Python Software Foundation): https://docs."
"python.org/2/library/os.html"

#: ..\python_docs\spladdoninternals.py:926
msgid ""
"46. Configparser (Python documentation, Python Software Foundation): https://"
"docs.python.org/2/library/configparser.html"
msgstr ""
"46. Configparser (Documentación de Python, Python Software Foundation): "
"https://docs.python.org/2/library/configparser.html"

#: ..\python_docs\spladdoninternals.py:927
msgid ""
"47. ConfigObj documentation: http://www.voidspace.org.uk/python/configobj."
"html"
msgstr ""
"47. Documentación de ConfigObj: http://www.voidspace.org.uk/python/configobj."
"html"

#: ..\python_docs\spladdoninternals.py:928
msgid ""
"48. Validate module documentation: http://www.voidspace.org.uk/python/"
"validate.html"
msgstr ""
"48. Documentación del módulo Validate: http://www.voidspace.org.uk/python/"
"validate.html"

#: ..\python_docs\spladdoninternals.py:929
msgid ""
"49. Spin control (wx.SpinCtrl) documentation (WXPython): http://wxpython.org/"
"Phoenix/docs/html/SpinCtrl.html"
msgstr ""
"49. Documentación de Spin control (wx.SpinCtrl) (WXPython): http://wxpython."
"org/Phoenix/docs/html/SpinCtrl.html"

#: ..\python_docs\spladdoninternals.py:930
msgid ""
"50. SetForegroundWindow (user32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms633539(v=vs.85).aspx"
msgstr ""
"50. Referencia de SetForegroundWindow (user32.dll) (Windows API): https://"
"msdn.microsoft.com/en-us/library/windows/desktop/ms633539(v=vs.85).aspx"

#~ msgid ""
#~ "1. Checks if you are indeed focused on a track item, and if not, it'll "
#~ "say \"not a track\"."
#~ msgstr ""
#~ "1. Comprueba si tienes el foco en un elemento de lista y, si no es así, "
#~ "NVDA dirá \"No es una pista\"."

#~ msgid ""
#~ "* Announces stream labels (if defined) via reportFocus method. In "
#~ "contrast with the Studio track item version, an encoder's reportFocus "
#~ "routine:"
#~ msgstr ""
#~ "* Verbalización de etiquetas de flujo (si están definidas) mediante el "
#~ "método reportFocus. En contraste con la versión del elemento de pista de "
#~ "Studio, una función reportFocus de un codificador:"

#~ msgid ""
#~ "\t1. Locates stream labels for the current encoder (the configuration map "
#~ "stores stream labels as dictionaries (sections), with each dictionary "
#~ "representing the encoder type, key is the encoder position and the value "
#~ "is the label; each encoder, when told to look up stream labels, will "
#~ "consult its own labels dictionary)."
#~ msgstr ""
#~ "\t1. Ubica las etiquetas de flujo del codificador actual (el mapa de "
#~ "configuración almacena las etiquetas de flujo como diccionarios "
#~ "(secciones), donde en cada diccionario se representa el tipo de "
#~ "codificador, la clave es la posición del codificador y el valor es la "
#~ "etiqueta; cada codificador, al pedirle que busque las etiquetas de flujo, "
#~ "consultará su propio diccionario de etiquetas)."

#~ msgid ""
#~ "\t2. If a label is found, NVDA will announce the label (in braille, "
#~ "surrounded by parentheses)."
#~ msgstr ""
#~ "\t2. Si se encuentra una etiqueta, NVDA la anunciará (en braille la "
#~ "rodeará con paréntesis)."

#~ msgid ""
#~ "In 2018, this was simplified by use of SysListView32 routines directly."
#~ msgstr ""
#~ "En 2018, esto se simplificó usando directamente los procedimientos de "
#~ "SysListView32."

#~ msgid ""
#~ "There are two times where a \"live\" profile switching will occur: "
#~ "activation or deactivation of instant switch profile, and when it is time "
#~ "to switch to a time-based profile."
#~ msgstr ""
#~ "Hay dos ocasiones en las que puede dispararse un cambio de perfil "
#~ "automático: al activar o desactivar un perfil de cambio instantáneo, o "
#~ "cuando es hora de cambiar a un perfil basado en tiempo."

#~ msgid ""
#~ "\t9. Prepares routines used by time-based profile switching facility by "
#~ "loading triggers map and checking if NVDA should switch to the next "
#~ "profile (this is done if the show associated with the given profile "
#~ "hasn't ended yet). See time-based profile section for details."
#~ msgstr ""
#~ "\t9. Se preparan los procedimientos usados por la característica de "
#~ "cambio de perfil basado en tiempo cargando un mapa de disparadores y "
#~ "comprobando si NVDA debería cambiar al siguiente perfil (esto se hace si "
#~ "el programa asociado con el perfil dado no ha terminado todavía). Mira la "
#~ "sección de perfiles basados en tiempo para más detalles."

#~ msgid ""
#~ "\t10. Encoder settings file is loaded, and if ConfigObj throws errors, "
#~ "encoder settings will be reset to defaults."
#~ msgstr ""
#~ "\t10. Se carga el archivo de ajustes del codificador, y si ConfigObj "
#~ "lanza errores, los ajustes del codificador se restablecen por defecto."

#~ msgid ""
#~ "When you press Alt+NVDA+1 or Alt+NVDA+2 to open end of track or song "
#~ "intro alarm dialogs, the dialog will display two controls:"
#~ msgstr ""
#~ "Cuando pulses NVDA+alt+1 o NVDA+alt+2 para abrir los diálogos de alarma "
#~ "de fin de pista o introducción de canción, el diálogo mostrará dos "
#~ "controles:"

#~ msgid ""
#~ "In reality, a single dialog (splconfui.AlarmsCenter class) presents these "
#~ "two alarm dialogs (there are two additional dialogs, covered in the next "
#~ "section). The type of dialog to be shown is controled by an integer which "
#~ "denotes which dialog text to present. The process is outlined below:"
#~ msgstr ""
#~ "En realidad, un único diálogo (clase splconfui.AlarmsCenter) presenta "
#~ "estos dos diálogos de alarma (hay dos diálogos adicionales, cubiertos en "
#~ "la próxima sección). El tipo de diálogo a mostrar viene controlado por un "
#~ "entero que indica qué texto presentar en el diálogo. El proceso viene "
#~ "descrito a continuación:"

#~ msgid ""
#~ "1. Just before the dialog opens, checks if another dialog or the add-on "
#~ "settings dialog is opened, and if so, NVDA will ask you to close the "
#~ "previously opened dialog first."
#~ msgstr ""
#~ "1. Antes de que el diálogo se abra, se comprueba si otro diálogo o el "
#~ "diálogo de configuración del complemento está abierto, y si es así, NVDA "
#~ "te pedirá que cierres el diálogo previamente abierto primero."

#~ msgid ""
#~ "2. Tells NVDA that an alarm dialog is opened. This is meant to prevent "
#~ "the same dialog from being opened repeatedly."
#~ msgstr ""
#~ "2. Se le dice a NVDA que hay un diálogo de alarma abierto. Esto se hace "
#~ "para evitar que se abra el mismo diálogo repetidamente."

#~ msgid ""
#~ "3. After the dialog is dismissed (either a new value is set or you click "
#~ "Cancel), NVDA clears the alarm opened flag, thereby letting other dialogs "
#~ "to be shown. "
#~ msgstr ""
#~ "3. Después de cerrar el diálogo (bien porque se establece un nuevo valor "
#~ "o se pulsa en cancelar), NVDA limpia el indicador de alarma abierta, "
#~ "permitiendo que otros diálogos se muestren. "

#~ msgid "* Routines for navigating and announcing various columns."
#~ msgstr "* Procedimientos para verbalizar y navegar por diversas columnas."

#~ msgid ""
#~ "The contents of the base track item class (appModules.splstudio."
#~ "SPLTrackItem) are as follows:"
#~ msgstr ""
#~ "Los contenidos de la clase base de elemento de pista (appModules."
#~ "splstudio.SPLTrackItem) son los siguientes:"

#~ msgid ""
#~ "* initOverlayClass: This is run when the track item is first encountered. "
#~ "This method checks if Track Dial (see below) is active, and if so, "
#~ "assigns left and right arrow keys to Track Dial functions."
#~ msgstr ""
#~ "* initOverlayClass: se ejecuta cuando se encuentra por primera vez un "
#~ "elemento de pista. Este método comprueba si el dial de pista (mira más "
#~ "abajo) está activo, y si es así, asigna las flechas izquierda y derecha a "
#~ "las funciones del dial de pista."

#~ msgid ""
#~ "* Track column navigation: Various methods and scripts used by Track Dial "
#~ "and friends are defined, including announcing column information, "
#~ "handling leftmost column and so on. Add-on 8.0 adds Columns Explorer "
#~ "routines, and 17.04 adds vertical column navigation support."
#~ msgstr ""
#~ "* Navegación por columnas de pista: se definen diversos métodos y scripts "
#~ "usados por el dial de pista y sus amigos, incluyendo verbalización de "
#~ "información de la columna, identificación de la columna más a la "
#~ "izquierda y demás. El complemento 8.0 añade los procedimientos del "
#~ "explorador de columnas, y el 17.04 añade soporte de navegación vertical "
#~ "por columnas."

#~ msgid ""
#~ "Studio track item class for 5.0x (appModules.splstudio."
#~ "SPLStudioTrackItem) adds:"
#~ msgstr ""
#~ "La clase de elemento de pista de Studio para la versión 5.0x (appModules."
#~ "splstudio.SPLStudioTrackItem) añade:"

#~ msgid ""
#~ "In addition, Studio 5.10 track item (appModules.splstudio."
#~ "SPLStudio510TrackItem) includes a script to announce changed state when "
#~ "SPACE is pressed (this is done by speaking and/or brailling track name "
#~ "(obj.name))."
#~ msgstr ""
#~ "Además, el elemento de pista de Studio 5.10 (appModules.splstudio."
#~ "SPL510TrackItem) incluye un script para verbalizar el cambio de estado "
#~ "cuando se pulsa espacio (esto se hace hablando y / o mostrando en braille "
#~ "el nombre de pista (obj.name))."

#~ msgid ""
#~ "* Define and remove stream labels. This is done via stream labels dialog "
#~ "(F12) that'll make sure you entered a label (if not, the encoder position "
#~ "is removed from the encoder-specific stream labels dictionary)."
#~ msgstr ""
#~ "* Definición y eliminación de etiquetas de flujo. Esto se hace mediante "
#~ "el diálogo de etiquetas de flujo (f12) que se asegurará de que has "
#~ "introducido una etiqueta (si no, la posición del codificador se elimina "
#~ "del diccionario específico de etiquetas de flujo del codificador)."

#~ msgid ""
#~ "* 1 through 0 (6 for studio 5.0x): Columns Explorer (discussed earlier). "
#~ "Unlike other commands in this set, this routine uses Windows API only."
#~ msgstr ""
#~ "* Números del 1 al 0 (6 en Studio 5.0x): explorador de columnas (expuesto "
#~ "anteriormente). Al contrario que otras órdenes de este conjunto, este "
#~ "procedimiento usa sólo la api de Windows."

#~ msgid "### Studio app module versus SPL Utilities global plugin"
#~ msgstr ""
#~ "### Comparación del módulo de aplicación de Studio y la extensión global "
#~ "de utilidades de SPL"

#~ msgid "### SPL Utilities package contents"
#~ msgstr "### Contenidos del paquete de utilidades de SPL"

#~ msgid "The SPL Utilities global plugin consists of the following modules:"
#~ msgstr ""
#~ "La extensión global de utilidades de SPL consta de los siguientes módulos:"

#~ msgid ""
#~ "* Main plugin code (__init__.py), containing essential global routines "
#~ "such as SPL Controller (described below) and a procedure to focus to "
#~ "Studio window upon request. This module defines constants used by Studio "
#~ "to receive messages, a function to focus to Studio window and the global "
#~ "plugin class containing definitions for SPL Controller layer commands."
#~ msgstr ""
#~ "* Código principal de la extensión (__init__.py), que contiene "
#~ "procedimientos globales esenciales como el controlador de SPL (descrito "
#~ "debajo) y un procedimiento para enfocar la ventana de Studio a petición. "
#~ "Este módulo define constantes usadas por Studio para recibir mensajes, "
#~ "una función para llevar el foco a la ventana de Studio y la clase de "
#~ "extensión global que contiene definiciones para las órdenes de la capa "
#~ "del controlador de SPL."

#~ msgid ""
#~ "* E: If you tell NVDA to monitor one or more encoders in the background, "
#~ "this command will announce number of encoders being monitored (see the "
#~ "next aritlce on the format of this message)."
#~ msgstr ""
#~ "* E: si pides a NVDA que monitorice uno o más codificadores en segundo "
#~ "plano, esta orden verbalizará la cantidad de codificadores monitorizados "
#~ "(mira el siguiente artículo para conocer el formato de este mensaje)."

#~ msgid "### Conclusion"
#~ msgstr "### Conclusión"

#~ msgid ""
#~ "The routines discussed above (SPL Controller and the command to switch to "
#~ "Studio window) is one of the two pillars of the SPL Studio Utilities "
#~ "global plugin (the other is encoder support). With these routines, it "
#~ "became possible to perform playback operations without focusing to "
#~ "studio, and you can switch to Studio window from anywhere, anytime. This "
#~ "\"other side\" of the lgobal plugin is discussed below, and after that, "
#~ "we'll conclude with an interview with the maintainer of the add-on to "
#~ "learn about how he (I) develop new add-on features."
#~ msgstr ""
#~ "Los procedimientos explicados arriba (el controlador de SPL y la orden "
#~ "para pasar a la ventana de Studio) constituyen uno de los dos pilares de "
#~ "la extensión global de utilidades de SPL (el otro es el soporte del "
#~ "codificador). Con estos procedimientos, se hizo posible realizar "
#~ "operaciones de reproducción sin llevar el foco a Studio y pasar a Studio "
#~ "desde cualquier parte, en cualquier momento. Visitaremos el \"otro lado\" "
#~ "de la historia de esta extensión global en el siguiente artículo del "
#~ "complemento de Studio para NVDA visto por dentro, y después de eso, "
#~ "concluiremos con una entrevista con el responsable del mantenimiento del "
#~ "complemento para aprender cómo él (yo) desarrolla nuevas características "
#~ "del complemento."

#~ msgid ""
#~ "Note: this section is subject to change in the near future due to ongoing "
#~ "encoder support migration work."
#~ msgstr ""
#~ "Nota: esta sección está sujeta a cambios en el futuro cercano debido a la "
#~ "migración en progreso del soporte de codificadores."

#~ msgid ""
#~ "2. Announces error messages if any and will try again after waiting a "
#~ "little while (fraction of a second)."
#~ msgstr ""
#~ "2. Verbaliza mensajes de error si los hay y lo intenta otra vez después "
#~ "de esperar un ratito (una fracción de segundo)."

#~ msgid "### A place to start: reader questions and definitions"
#~ msgstr "### Un lugar en el que empezar: preguntas del lector y definiciones"

#~ msgid ""
#~ "I'm sure some readers might ask, \"doesn't writing articles on software "
#~ "internals require programming knowledge?\" Yes and no. Yes, as you may "
#~ "need some basic exposure to programming such as what a variable is, "
#~ "conditional execution and so forth. On the flip side, you don't have to "
#~ "be a programmer to write about internal workings of an add-on (the basic "
#~ "requirement is passion for teaching and a hope for users to learn "
#~ "something new). Same could be said about reading this article: you may "
#~ "need some exposure to programming, but you don't have to be a programmer "
#~ "to follow along."
#~ msgstr ""
#~ "Estoy seguro de que algunos lectores se preguntarán: \"¿Es que no se "
#~ "necesitan conocimientos de programación a la hora de escribir artículos "
#~ "que hablan del interior de un software?\". Sí y no. Sí, porque puedes "
#~ "necesitar algún concepto de programación como saber qué es una variable, "
#~ "ejecución condicional y demás. Por otro lado, no tienes que ser "
#~ "programador para escribir sobre el funcionamiento interno de un "
#~ "complemento (el requisito básico es la pasión por enseñar y la esperanza "
#~ "de que los usuarios aprendan algo nuevo). Lo mismo se puede decir sobre "
#~ "leer este artículo: puedes necesitar algunas nociones de programación, "
#~ "pero no tienes que ser un programador para seguirlo."

#~ msgid ""
#~ "Another question might be, \"will this article teach me all there is to "
#~ "it when writing an add-on of my own?\" Yes and no. Yes, as you'll learn "
#~ "how add-on writers think when it comes to taking care of their add-ons "
#~ "and get a glimpse into add-on development processes. On the other side of "
#~ "the coin is scope of this article - this article does not serve as a "
#~ "definitive guide on add-on writing (there are documentation, linked at "
#~ "the end of this article that'll give you some basic overview). If you are "
#~ "familiar with add-on development and/or NVDA screen reader development "
#~ "and source code, you'll have slightly easier time understanding this "
#~ "article. I tried my best to make it easy for users to understand "
#~ "(although I do have to include some technical details)."
#~ msgstr ""
#~ "Otra pregunta podría ser: \"¿Me enseñará este artículo todo lo que debo "
#~ "saber para escribir mi propio complemento?\". Sí y no. Sí, porque "
#~ "aprenderás cómo piensan los desarrolladores de complementos a la hora de "
#~ "crearlos y mantenerlos y echarás un vistazo a los procesos de desarrollo. "
#~ "En la otra cara de la moneda está el ámbito de este artículo - este "
#~ "artículo no es una guía definitiva de desarrollo de complementos (hay "
#~ "documentación, al final de este artículo, que te dará una introducción "
#~ "básica). Si estás acostumbrado al desarrollo de complementos y/o el "
#~ "desarrollo del lector de pantalla NVDA y su código fuente, lo tendrás más "
#~ "fácil para entender este artículo. He intentado hacerlo lo más fácil "
#~ "posible para que lo entiendan los usuarios (aunque he tenido que incluir "
#~ "algunos detalles técnicos)."

#~ msgid "Some definitions:"
#~ msgstr "Algunas definiciones:"

#~ msgid ""
#~ "* Add-on: An add-on is a module for a program that adds additional "
#~ "features or changes the behavior of a program (3)."
#~ msgstr ""
#~ "* Complemento: un complemento es un módulo para un programa que añade "
#~ "funciones adicionales o cambia el comportamiento del programa (3)."

#~ msgid ""
#~ "* API: Application Programming Interface, a set of specifications for "
#~ "programmers for using services offered by a program such as modules, "
#~ "functions and documentation (4). One of the most well-known API's is "
#~ "Python and its documentation (5)."
#~ msgstr ""
#~ "* API: interfaz de programación de aplicaciones, un conjunto de "
#~ "especificaciones para los programadores para usar servicios ofrecidos por "
#~ "un programa, como módulos, funciones y documentación (4). Una de las apis "
#~ "más conocidas es Python y su documentación (5)."

#~ msgid ""
#~ "With some basics out of the way, let's dive into SPL add-on internals "
#~ "(you should download the add-on source code, which can be found at "
#~ "https://github.com/josephsl/stationplaylist)."
#~ msgstr ""
#~ "Con algunos conceptos básicos ya aclarados, buceemos en el interior del "
#~ "complemento SPL (deberías descargar el código fuente del complemento, que "
#~ "puede encontrarse en https://github.com/josephsl/stationplaylist)."

#~ msgid "For SPL encoders:"
#~ msgstr "Para los codificadores SPL:"
