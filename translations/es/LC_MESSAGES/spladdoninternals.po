# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR ORGANIZATION
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2018-10-24 23:03+Hora de verano romance\n"
"PO-Revision-Date: 2018-10-24 23:04+0200\n"
"Last-Translator: José Manuel Delicado <jmdaweb@hotmail.com>\n"
"Language-Team: \n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: pygettext.py 1.5\n"
"X-Generator: Poedit 2.2\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ..\python_docs\spladdoninternals.py:3
msgid "# NVDA Add-on internals: StationPlaylist Studio"
msgstr "# Complementos de NVDA vistos por dentro: StationPlaylist Studio"

#: ..\python_docs\spladdoninternals.py:4
msgid "Author: Joseph Lee"
msgstr "Autor: Joseph Lee"

#: ..\python_docs\spladdoninternals.py:5
msgid "Based on StationPlaylist Studio Add-on for NvDA 18.09"
msgstr "Basado en el complemento StationPlaylist Studio 18.09 para NVDA"

#: ..\python_docs\spladdoninternals.py:6
msgid "## 2018 Preface and notes"
msgstr "## Prólogo y notas de 2018"

#: ..\python_docs\spladdoninternals.py:7
msgid ""
"This guide has gone through many revisions, style changes, and updated to "
"include features in latest add-on releases. When first published in 2015, it "
"was done as a series of blog posts. Now in 2018, edits are ongoing to remove "
"traces of old style and update this guide to reflect add-on features as of "
"2018."
msgstr ""
"Esta guía ha pasado por muchas revisiones, cambios de estilo, y se ha "
"actualizado para incluir características de las últimas versiones del "
"complemento. Cuando se publicó por primera vez en 2015, se elaboró como una "
"serie de entradas de blog. Ahora en 2018, se está editando para eliminar las "
"huellas del estilo anterior y actualizándose para reflejar las últimas "
"características del 2018."

#: ..\python_docs\spladdoninternals.py:8
msgid ""
"Also in 2018, the scope of the add-on has expanded to cover StationPlaylist "
"Creator and Track Tool. For the most part, this guide will still cover "
"StationPlaylist Studio alone, but there are important changes made in recent "
"releases that'll ask us to consider other programs in StationPlaylist suite. "
"In particular, trakc item class inheritance hierarchy has changed so many "
"column navigation commands are available when dealing with tracks across SPL "
"apps."
msgstr ""
"En 2018 también se ha expandido el ámbito del complemento para cubrir "
"StationPlaylist Creator y la herramienta de pista. En su mayor parte, esta "
"guía todavía cubrirá StationPlaylist Studio únicamente, pero hay cambios "
"importantes que se han hecho en las versiones más recientes que nos harán "
"plantearnos añadir otros programas de la suite StationPlaylist. En "
"particular, la jerarquía de herencia de la clase de elemento de pista ha "
"cambiado, por lo que muchas órdenes de navegación por columnas están "
"disponibles al tratar con pistas en las aplicaciones de SPL."

#: ..\python_docs\spladdoninternals.py:9
msgid "## Introduction"
msgstr "## Introducción"

#: ..\python_docs\spladdoninternals.py:10
msgid ""
"If you are a radio broadcaster, you might be accustomed to activities "
"involved when producing a show. This may include playlist selection, "
"scheduling break notes, responding to requests, monitoring listener count "
"and encoding status and so on. To assist a broadcaster, a broadcast "
"automation program is used, and one of the popular apps is called "
"StationPlaylist Studio."
msgstr ""
"Si eres locutor de radio, podrías estar acostumbrado a las actividades "
"involucradas al producir un programa. Aquí se pueden incluir la selección de "
"la lista de reproducción, programación de notas de interrupción, respuesta a "
"peticiones, monitorización del número de oyentes y estado de la "
"codificación, entre otras. Para asistir a un locutor, se usa un programa de "
"automatización de la emisión, y uno de los más populares se llama "
"StationPlaylist Studio."

#: ..\python_docs\spladdoninternals.py:11
msgid ""
"In NVDA Add-on Internals: StationPlaylist Studio, we'll learn about what "
"Studio (and other SPL suite of apps) is and how the NVDA add-on works. You "
"don't have to install or use the NVDA add-on to understand the ins and outs "
"of this powerful add-on (using the add-on might help you better appreciate "
"the defth of this material; for fuller experience, it is handy to have the "
"add-on source code in front of you as you navigate this article). So let's "
"get started by learning more about SPL Studio."
msgstr ""
"En Complementos de NVDA vistos por dentro: StationPlaylist Studio, "
"aprenderemos qué es Studio (y la suite de aplicaciones de SPL) y cómo "
"funciona este complemento de NVDA. No tienes que instalar o utilizar este "
"potente complemento para entender sus peculiaridades, (usar el complemento "
"podría ayudarte a apreciar la importancia de este material; para una "
"experiencia más completa, es útil que tengas el código fuente del "
"complemento ante ti mientras navegas por este artículo). Ahora, empecemos "
"aprendiendo más sobre SPL Studio."

#: ..\python_docs\spladdoninternals.py:12
msgid "### Introducing StationPlaylist app suite and the NVDA add-on"
msgstr ""
"### Presentación de la suite de aplicaciones de StationPlaylist y el "
"complemento para NVDA"

#: ..\python_docs\spladdoninternals.py:13
msgid ""
"[StationPlaylist suite](www.stationplaylist.com) is a collection of programs "
"to help broadcasters plan, run, and do related activities around "
"broadcasting. The apps consist of Studio, Creator, Track Tool and others."
msgstr ""
"[La suite de StationPlaylist](www.stationplaylist.com) es una colección de "
"programas para ayudar a los locutores a planear, ejecutar y hacer "
"actividades relacionadas con la emisión. Las aplicaciones constan de Studio, "
"Creator, la herramienta de pista y otras."

#: ..\python_docs\spladdoninternals.py:14
msgid ""
"StationPlaylist Studio is a broadcast automation software that helps "
"broadcasters schedule trakcs, play jingles and more. It includes support for "
"break notes, hourly playlist, track tagging and comes with tools to manage "
"track playback such as setting track intros. In studio 5.00 and later, it "
"includes its own stream encoder."
msgstr ""
"StationPlaylist Studio es un software de automatización de emisiones que "
"ayuda a los locutores a planificar pistas, reproducir jingles y más. Incluye "
"soporte para notas de interrupción, listas de reproducción por cada hora, "
"etiquetado de pistas y viene con herramientas para gestionar la reproducción "
"de pistas, como establecer la introducción de pista. En Studio 5.00 y "
"posteriores, se incluye un codificador de flujos propio."

#: ..\python_docs\spladdoninternals.py:15
msgid ""
"StationPlaylist Creator is mostly used for planning a show and designing "
"playlists to be used by Studio. It can be used to define spot groups, custom "
"track categories and more."
msgstr ""
"StationPlaylist Creator se usa mayoritariamente para planificar un programa "
"y diseñar listas de reproducción para que las use Studio. Puede usarse para "
"definir grupos de spots, categorías personalizadas de pista y más."

#: ..\python_docs\spladdoninternals.py:16
msgid ""
"StationPlaylist Track Tool is mainly used for managing tracks. It is often "
"employed to define introductions, cue points and other properties of tracks."
msgstr ""
"La herramienta de pista de StationPlaylist se usa principalmente para "
"gestionar pistas. Con frecuencia se emplea para definir introducciones, "
"puntos clave y otras propiedades de las pistas."

#: ..\python_docs\spladdoninternals.py:17
msgid ""
"Is Studio suite accessible? Surprisingly, yes. It is possible to use app "
"features without using screen reader scripts and add-ons. However, there are "
"times when a broadcaster would use scripts, such as announcing status "
"changes, monitoring track intros and endings, enhanced support for encoders "
"and so on, and NVDA add-on for StationPlaylist Studio (usually refered to as "
"SPL) accomplishes this well."
msgstr ""
"¿Es la suite de Studio accesible? Sorprendentemente, sí. Es posible utilizar "
"las funciones de Studio sin usar scripts para lectores de pantalla y "
"complementos. Sin embargo, hay veces en las que un locutor usaría scripts, "
"como el anunciado de cambios de estado, monitorización de inicio y fin de "
"pistas, soporte mejorado para codificadores y demás, y el complemento de "
"NVDA para StationPlaylist Studio (al que nos referiremos normalmente como "
"SPL) resuelve todo esto bien."

#: ..\python_docs\spladdoninternals.py:18
msgid "### Studio add-on: a history"
msgstr "### Complemento para Studio: una historia"

#: ..\python_docs\spladdoninternals.py:19
msgid ""
"In 2011, Geoff Shang, a seasoned blind broadcaster, started working on SPL "
"Studio add-on. This early version (numbered 0.01) was developed to let NVDA "
"announce various status changes such as automation toggle and so on. This "
"initial version, co-developed by James Teh (a former lead developer of NVDA "
"screen reader) was considered a quick project, and further development "
"ceased until 2013."
msgstr ""
"En 2011, Geoff Shang, un locutor ciego experimentado, comenzó a trabajar en "
"el complemento para SPL Studio. Esta versión temprana (numerada como 0.01) "
"fue desarrollada para hacer que NVDA verbalizara diversos cambios de estado, "
"como la alternancia de automatización y así. Esta versión inicial, co-"
"desarrollada con James Teh (uno de los principales desarrolladores del "
"lector de pantalla NVDA) se consideró como un proyecto rápido, y el "
"desarrollo cesó hasta 2013."

#: ..\python_docs\spladdoninternals.py:20
msgid ""
"In 2013, I (Joseph Lee) received several emails regarding NVDA's support for "
"SPL Studio with a request for someone to write an add-on for it. As I was "
"still new to add-on development then (this was after I developed Control "
"Usage Assistant and GoldWave), I decided to take on this challenge in order "
"to learn more Python and to practice what I learned in computer science labs "
"at UC Riverside. I first downloaded the existing add-on (0.01) and installed "
"Studio 5.01 on my computer to learn more about this program and to gather "
"suggestions from SPL users. After little over a month of development and "
"preview releases, I released Studio add-on 1.0 in January 2014."
msgstr ""
"En 2013, yo (Joseph Lee) recibí varios correos relacionados con el soporte "
"de NVDA para SPL Studio con una petición de que alguien escribiera un "
"complemento para él. Como todavía era nuevo en el desarrollo de complementos "
"(esto vino después de que desarrollara Control Usage Assistant y GoldWave), "
"decidí aceptar este reto para aprender más sobre Python y practicar lo "
"aprendido en los laboratorios de ciencias de la computación en UC Riverside. "
"Primero descargué el complemento existente (0.01) e instalé Studio 5.01 en "
"mi ordenador para aprender más sobre este programa y recopilar sugerencias "
"de otros usuarios de SPL. Después de un mes de desarrollo y versiones de "
"prueba, liberé el complemento para Studio 1.0 en enero de 2014."

#: ..\python_docs\spladdoninternals.py:21
msgid ""
"Most of the early versions (1.x, 2.x, 3.x, released throughout 2014) were "
"mostly quick projects that bridged the gap between NVDA and other screen "
"readers (Brian Hartgen's JAWS scripts were my inspiration and have studied "
"documentation for Jeff Bishop's Window-Eyes scripts). These early versions, "
"supporting Studio 4.33 and later, were also used to fix bugs encountered by "
"Studio users - for instance, a broadcaster posted  a YouTube video "
"explaining how NVDA was not reading edit fields, which was fixed early on. "
"Later releases (4.x, 5.x, 6.x, released throughout 2015), further bridged "
"the gap with other screen readers and introduced unique features (for "
"instance, add-on 5.0 introduced a configuration dialog, and 6.0 introduced "
"concept of a broadcast profile). In late 2016, seeing that some of my add-"
"ons were using year.month scheme for versioning, I decided to switch SPL to "
"follow this model after receiving comments from the NVDA community. As of "
"time of writing, add-on 18.08 just hit the air."
msgstr ""
"La mayoría de las primeras versiones (1.x, 2.x, 3.x, publicadas a lo largo "
"de 2014) fueron principalmente proyectos rápidos que reducían la brecha "
"entre NVDA y otros lectores de pantalla (los scripts para JAWS de Brian "
"Hartgen fueron mi fuente de inspiración y he estudiado la documentación de "
"los scripts para Window Eyes creados por Jeff Bishop). Estas primeras "
"versiones, que daban soporte a Studio 4.33 y versiones posteriores, se "
"utilizaron también para solucionar fallos encontrados por usuarios de Studio "
"- por ejemplo, un locutor subió un vídeo a YouTube explicando que NVDA no "
"estaba leyendo los cuadros de edición, cosa que se solucionó rápidamente. "
"Las siguientes versiones (4.x, 5.x, 6.x, publicadas a lo largo de 2015), "
"profundizaron en reducir las diferencias con otros lectores de pantalla e "
"introdujeron características únicas (por ejemplo, el complemento 5.0 vino "
"con un diálogo de configuración, y el 6.0 introdujo el concepto de perfil de "
"emisión). Ya avanzado 2016, viendo que algunos de mis complementos estaban "
"adoptando el esquema año.mes para las versiones, decidí cambiar SPL para que "
"siguiera este modelo tras recibir comentarios de la comunidad de NVDA. En el "
"momento en que escribo este artículo, la versión 18.08 de este complemento "
"acaba de ser liberada."

#: ..\python_docs\spladdoninternals.py:22
msgid ""
"Highlights of past major releases and subsequent maintenance releases "
"include:"
msgstr ""
"Lo reseñable de las versiones pasadas principales y de mantenimiento es lo "
"siguiente:"

#: ..\python_docs\spladdoninternals.py:23
msgid "* 1.x: Initial release, added end of track alarm and other features."
msgstr ""
"* 1.x: versión inicial, añadida alarma de fin de pista y otras "
"características."

#: ..\python_docs\spladdoninternals.py:24
msgid "* 2.x: Track Finder and better routines to recognize Studio versions."
msgstr ""
"* 2.x: buscador de pista y procedimientos mejores para reconocer versiones "
"de Studio."

#: ..\python_docs\spladdoninternals.py:25
msgid ""
"* 3.x: first long-term support (LTS) release, Cart Explorer, support for SAM "
"Encoder and no need to stay on the encoder window during connection "
"attempts. This was the last version to support Studio 4.33."
msgstr ""
"* 3.x: primera versión de soporte extendido (lts), explorador de Cart, "
"soporte para el codificador SAM y eliminación de la necesidad de permanecer "
"en la ventana del codificador durante los intentos de conexión. Esta fue la "
"última versión que dio soporte a Studio 4.33."

#: ..\python_docs\spladdoninternals.py:26
msgid "* 4.x: Library scan, support for SPL encoder and studio 5.10."
msgstr ""
"* 4.x: escaneo de biblioteca, soporte para el codificador de SPL y Studio "
"5.10."

#: ..\python_docs\spladdoninternals.py:27
msgid "* 5.x: Track Dial, dedicated configuration dialog."
msgstr "* 5.x: dial de pista, diálogo de configuración dedicado."

#: ..\python_docs\spladdoninternals.py:28
msgid ""
"* 6.x: Broadcast profiles, metadata streaming, column search and "
"announcement reordering."
msgstr ""
"* 6.x: perfiles de emisión, flujo de metadatos, búsqueda de columnas y "
"reordenado de verbalizaciones."

#: ..\python_docs\spladdoninternals.py:29
msgid ""
"* 7.x: second LTS release, add-on updates, time-based profile switching, "
"Track Columns Explorer and others. This is the last version to support "
"Studio 5.01. Renamed to 15.x in late 2016."
msgstr ""
"* 7.x: segunda versión lts, actualizaciones del complemento, cambio de "
"perfiles basado en tiempo, explorador de columnas de pista y otros. Esta es "
"la última versión que da soporte a Studio 5.01. Se renombró a 15.x ya "
"entrado el 2016."

#: ..\python_docs\spladdoninternals.py:30
msgid ""
"* 16.10 (formerly 8.0): Columns explorer for Track Tool, selective data "
"resets."
msgstr ""
"* 16.10 (también conocida como 8.0): explorador de columnas para la "
"herramienta de pista, restablecimientos selectivos de datos."

#: ..\python_docs\spladdoninternals.py:31
msgid ""
"* 17.04 (formerly 9.0: vertical column navigation, playlist snapshots, "
"support for Studio 5.20."
msgstr ""
"* 17.04 (conocida como 9.0): navegación vertical por columnas, instantáneas "
"de listas de reproducción, soporte para Studio 5.20."

#: ..\python_docs\spladdoninternals.py:32
msgid ""
"* 17.08 (10.0: listener request notification, column header announcement "
"suppression. This is the last major version, with subsequent versions using "
"continuous delivery."
msgstr ""
"* 17.08 (10.0): notificación de solicitud de oyente, supresión de la "
"verbalización de cabeceras de columna. Esta es la última versión principal, "
"con las siguientes versiones usando entrega continua."

#: ..\python_docs\spladdoninternals.py:33
msgid ""
"* 17.12: end of support for old Windows releases, add-on settings "
"reorganization, extension points."
msgstr ""
"* 17.12: fin de soporte para versiones antiguas de Windows, reorganización "
"de los ajustes del complemento, puntos de extensión."

#: ..\python_docs\spladdoninternals.py:34
msgid ""
"* 18.06: responding to recent NVDA features, playlist transcripts, wxPython "
"4 support, partial playlist snapshots, expanding the scope of the add-on."
msgstr ""
"* 18.06: respuesta ante nuevas características de NVDA, transcripción de "
"listas de reproducción, soporte para WXPython 4, instantáneas parciales de "
"la lista de reproducción, expansión del ámbito del complemento."

#: ..\python_docs\spladdoninternals.py:35
msgid ""
"* 18.09: third LTS release, add-on settings panels, checkable list, wxPython "
"4."
msgstr ""
"* 18.09: tercera versión LTS, paneles de configuración del complemento, "
"lista con casillas de verificación, WXPython 4."

#: ..\python_docs\spladdoninternals.py:36
msgid ""
"Throughout this article, you'll get a chance to see how the add-on works, "
"design philosophy and how the add-on is being developed, with glimpses into "
"the past and future. My hope is that this add-on internals article would be "
"a valuable reference for users and developers - for users to see the inner "
"workings of this add-on, and for developers to use this add-on as an example "
"of how an add-on is planned, implemented, tested, released and maintained."
msgstr ""
"A lo largo de este artículo, tendrás una oportunidad para ver cómo funciona "
"el complemento, la filosofía de diseño y cómo se desarrolla el complemento, "
"con vistas al pasado y al futuro. Espero que este artículo de complementos "
"vistos por dentro sea una referencia valiosa para usuarios y desarrolladores "
"- para los usuarios, que vean los trabajos internos de este complemento, y "
"para los desarrolladores, que usen este complemento como un ejemplo a la "
"hora de planear, implementar, probar, publicar y mantener un complemento."

#: ..\python_docs\spladdoninternals.py:37
msgid ""
"To download the add-on, go to http://addons.nvda-project.org/addons/"
"StationPlaylist.en.html."
msgstr ""
"Para descargar el complemento, ve a la sección de complementos que se "
"encuentra en nuestra web."

#: ..\python_docs\spladdoninternals.py:38
msgid ""
"## Design, code layout, layer sets and importance of Studio API and Studio "
"window handle"
msgstr ""
"## Diseño, estructura del código, conjuntos de capas e importancia de la api "
"de Studio y el manejador de ventana de Studio"

#: ..\python_docs\spladdoninternals.py:39
msgid "### A place to start: reader questions and definitions"
msgstr "### Un lugar en el que empezar: preguntas del lector y definiciones"

#: ..\python_docs\spladdoninternals.py:40
msgid ""
"I'm sure some readers might ask, \"doesn't writing articles on software "
"internals require programming knowledge?\" Yes and no. Yes, as you may need "
"some basic exposure to programming such as what a variable is, conditional "
"execution and so forth. On the flip side, you don't have to be a programmer "
"to write about internal workings of an add-on (the basic requirement is "
"passion for teaching and a hope for users to learn something new). Same "
"could be said about reading this article: you may need some exposure to "
"programming, but you don't have to be a programmer to follow along."
msgstr ""
"Estoy seguro de que algunos lectores se preguntarán: \"¿Es que no se "
"necesitan conocimientos de programación a la hora de escribir artículos que "
"hablan del interior de un software?\". Sí y no. Sí, porque puedes necesitar "
"algún concepto de programación como saber qué es una variable, ejecución "
"condicional y demás. Por otro lado, no tienes que ser programador para "
"escribir sobre el funcionamiento interno de un complemento (el requisito "
"básico es la pasión por enseñar y la esperanza de que los usuarios aprendan "
"algo nuevo). Lo mismo se puede decir sobre leer este artículo: puedes "
"necesitar algunas nociones de programación, pero no tienes que ser un "
"programador para seguirlo."

#: ..\python_docs\spladdoninternals.py:41
msgid ""
"Another question might be, \"will this article teach me all there is to it "
"when writing an add-on of my own?\" Yes and no. Yes, as you'll learn how add-"
"on writers think when it comes to taking care of their add-ons and get a "
"glimpse into add-on development processes. On the other side of the coin is "
"scope of this article - this article does not serve as a definitive guide on "
"add-on writing (there are documentation, linked at the end of this article "
"that'll give you some basic overview). If you are familiar with add-on "
"development and/or NVDA screen reader development and source code, you'll "
"have slightly easier time understanding this article. I tried my best to "
"make it easy for users to understand (although I do have to include some "
"technical details)."
msgstr ""
"Otra pregunta podría ser: \"¿Me enseñará este artículo todo lo que debo "
"saber para escribir mi propio complemento?\". Sí y no. Sí, porque aprenderás "
"cómo piensan los desarrolladores de complementos a la hora de crearlos y "
"mantenerlos y echarás un vistazo a los procesos de desarrollo. En la otra "
"cara de la moneda está el ámbito de este artículo - este artículo no es una "
"guía definitiva de desarrollo de complementos (hay documentación, al final "
"de este artículo, que te dará una introducción básica). Si estás "
"acostumbrado al desarrollo de complementos y/o el desarrollo del lector de "
"pantalla NVDA y su código fuente, lo tendrás más fácil para entender este "
"artículo. He intentado hacerlo lo más fácil posible para que lo entiendan "
"los usuarios (aunque he tenido que incluir algunos detalles técnicos)."

#: ..\python_docs\spladdoninternals.py:42
msgid "Some definitions:"
msgstr "Algunas definiciones:"

#: ..\python_docs\spladdoninternals.py:43
msgid ""
"* Add-on: An add-on is a module for a program that adds additional features "
"or changes the behavior of a program (3)."
msgstr ""
"* Complemento: un complemento es un módulo para un programa que añade "
"funciones adicionales o cambia el comportamiento del programa (3)."

#: ..\python_docs\spladdoninternals.py:44
msgid ""
"* API: Application Programming Interface, a set of specifications for "
"programmers for using services offered by a program such as modules, "
"functions and documentation (4). One of the most well-known API's is Python "
"and its documentation (5)."
msgstr ""
"* API: interfaz de programación de aplicaciones, un conjunto de "
"especificaciones para los programadores para usar servicios ofrecidos por un "
"programa, como módulos, funciones y documentación (4). Una de las apis más "
"conocidas es Python y su documentación (5)."

#: ..\python_docs\spladdoninternals.py:45
msgid ""
"With some basics out of the way, let's dive into SPL add-on internals (you "
"should download the add-on source code, which can be found at https://github."
"com/josephsl/stationplaylist)."
msgstr ""
"Con algunos conceptos básicos ya aclarados, buceemos en el interior del "
"complemento SPL (deberías descargar el código fuente del complemento, que "
"puede encontrarse en https://github.com/josephsl/stationplaylist)."

#: ..\python_docs\spladdoninternals.py:46
msgid "### Overall design and source code layout"
msgstr "### Diseño general y del código fuente"

#: ..\python_docs\spladdoninternals.py:47
msgid ""
"StationPlaylist Studio add-on for NVDA consists of three app modules and a "
"global plugin. Because Studio comes with Track Tool for managing tracks, the "
"add-on includes an app module for Track Tool in addition to the main app "
"module for Studio, as well as an app module for StationPlaylist Creator."
msgstr ""
"El complemento de NVDA para StationPlaylist Studio consta de tres módulos de "
"aplicación y una extensión global. Ya que Studio viene con la herramienta de "
"pista para gestionar pistas, el complemento incluye un módulo de aplicación "
"para la herramienta de pista además del módulo de aplicación principal para "
"Studio, así como un módulo de aplicación para StationPlaylist Creator."

#: ..\python_docs\spladdoninternals.py:48
msgid ""
"The overall design is that of a partnership between the main Studio app "
"module and the Studio Utilities (SPLUtils) global plugin. Studio app module "
"performs things expected from scripts such as responding to key presses, "
"announcing status information, configuration management and so forth, while "
"the global plugin is responsible for running Studio commands from anywhere "
"and for encoder support (the add-on supports SAM and SPL encoders). In "
"reality, the global plugin is subordinate to the app module, as the app "
"module controls overall functionality of the add-on and because the global "
"plugin requires Studio to be running to unlock some features (here, unlock "
"means using layer commands and encoder support)."
msgstr ""
"El diseño general es una relación entre el módulo de aplicación principal de "
"Studio y la extensión global de utilidades de Studio (SPLUtils). El módulo "
"de aplicación de Studio hace cosas que se esperan de los scripts, como "
"reaccionar a pulsaciones de teclado, anunciar información de estado, gestión "
"de configuración y todo eso, mientras que la extensión global es responsable "
"de ejecutar órdenes de Studio desde cualquier sitio y del soporte de los "
"codificadores (el complemento soporta los codificadores SAM y SPL). En "
"realidad, la extensión global es subordinada del módulo de aplicación, ya "
"que el módulo de aplicación controla la funcionalidad general del "
"complemento y la extensión global necesita que Studio esté en funcionamiento "
"para desbloquear algunas funciones (aquí, desbloquear significa usar la capa "
"de órdenes y el soporte de codificadoresÇ)."

#: ..\python_docs\spladdoninternals.py:49
msgid "The source code consists of:"
msgstr "El código fuente consta de:"

#: ..\python_docs\spladdoninternals.py:50
msgid ""
"* appModules: This folder contains the main splstudio (app module) package "
"and the app modules for Track Tool and Creator."
msgstr ""
"* appModules: esta carpeta contiene el paquete (módulo de aplicación) "
"principal splstudio y los módulos de aplicación para la herramienta de pista "
"y Creator."

#: ..\python_docs\spladdoninternals.py:51
msgid ""
"* The SPL Studio package consists of various modules, which include __init__ "
"(main app module and track item classes), configuration manager and user "
"interfaces (splconfig and splconfui) and miscellaneous services (splmisc) as "
"well as support modules and various wave files used by the add-on."
msgstr ""
"* El paquete SPL Studio consta de varios módulos, en los que se incluyen "
"__init__ (módulo de aplicación principal y clases de elemento de pista), el "
"gestor de configuraciones y las interfaces de usuario (splconfig y "
"splconfui) y servicios misceláneos (splmisc), así como módulos de soporte y "
"diversos archivos wav usados por el complemento."

#: ..\python_docs\spladdoninternals.py:52
msgid ""
"* The main app module file is divided into sections. First, the overlay "
"classes for track items are defined, then comes the app module, further "
"divided into four sections: fundamental methods (constructor, events and "
"others), time commands (end of track, broadcaster time, etc.), other "
"commands (track Finder, cart explorer and others) and SPL Assistant layer. "
"This allows me to identify where a bug is coming from and to add features in "
"appropriate sections."
msgstr ""
"* El archivo del módulo de aplicación principal está dividido en secciones. "
"Primero, se definen las clases de superposición para elementos de pista, "
"después viene el módulo de aplicación, dividido en cuatro secciones: métodos "
"fundamentales (constructor, eventos y otros), órdenes de tiempo (fin de "
"pista, tiempo del locutor, etc.), otras órdenes (buscador de pista, "
"explorador Cart y otros) y la capa de SPL Assistant. Esto me permite "
"identificar de dónde viene un fallo y añadir características en las "
"secciones apropiadas."

#: ..\python_docs\spladdoninternals.py:53
msgid ""
"* globalPlugins: This folder contains SPLStudioUtils package, which consists "
"of __init__ (main plugin and SPL Controller layer) and encoder support "
"module."
msgstr ""
"* globalPlugins: esta carpeta contiene el paquete SPLStudioUtils, que consta "
"de __init__ (extensión principal y capa del controlador de SPL) y el módulo "
"de soporte del codificador."

#: ..\python_docs\spladdoninternals.py:54
msgid "### Design philosophy"
msgstr "### Filosofía del diseño"

#: ..\python_docs\spladdoninternals.py:55
msgid ""
"When I set out to write the add-on in 2013, I put forth certain things the "
"add-on should adhere to, including:"
msgstr ""
"Cuando me puse a escribir el complemento en 2013, Puse en marcha ciertas "
"cosas que el complemento debe cumplir, incluyendo:"

#: ..\python_docs\spladdoninternals.py:56
msgid ""
"* Consistency: The add-on should have a consistent interface and command "
"structure. Interface includes various GUI's such as add-on configuration "
"dialog. For layer commands, I tried using native Studio command assignments."
msgstr ""
"* Consistencia: el complemento debería tener una interfaz y estructura de "
"órdenes consistente. La interfaz incluye varias GUI's como el diálogo de "
"configuración del complemento. Para las órdenes de capa, intenté usar la "
"asignación de órdenes nativa de Studio."

#: ..\python_docs\spladdoninternals.py:57
msgid ""
"* Extensibility: The add-on should be organized and written in such a way "
"that permits easy extensibility, hence the app module and the global plugin "
"were divided into submodules, with each of them being a specialist of some "
"kind (such as configuration management)."
msgstr ""
"* Extensibilidad: el complemento debería estar organizado y escrito de tal "
"manera que permita una fácil extensibilidad, y por esto el módulo de "
"aplicación y la extensión global se dividieron en submódulos, cada uno de "
"ellos especializado en una cosa concreta (como la gestión de la "
"configuración)."

#: ..\python_docs\spladdoninternals.py:58
msgid ""
"* Separation of concerns: Coupled with extensibility, this allowed me to "
"provide just needed commands at the right time, which resulted in two layer "
"command sets (explained below)."
msgstr ""
"* Separación de conceptos: junto con la extensibilidad, esto me permitió "
"proporcionar las órdenes necesarias en el momento adecuado, lo que resultó "
"en dos capas de conjuntos de órdenes (se explica más abajo)."

#: ..\python_docs\spladdoninternals.py:59
msgid ""
"* Easy to follow source code: Although some may say excessive documentation "
"is a noise, I believe it is important for a developer to understand how a "
"function or a module came about. Also, I have used and read user guides for "
"other screen reader scripts to better understand how a feature worked and "
"come up with some enhancements to a point where I found some major bugs with "
"JAWS scripts (one of them, which I hope Brian patched by now is microphone "
"alarm where the alarm would go off despite the fact that microphone was "
"turned off before alarm timeout has expired)."
msgstr ""
"* Código fuente fácil de seguir: aunque algunos puedan decir que la "
"documentación excesiva es ruido, creo que para un desarrollador es "
"importante entender cómo y por qué vino una función o módulo. También he "
"usado y leído guías de usuario de scripts para otros lectores de pantalla "
"para entender mejor cómo funcionaba una característica y hacerle algunas "
"mejoras en puntos donde encontraba fallos graves, como con los scripts para "
"JAWS (uno de ellos, que espero que Bryan haya parcheado por ahora, es la "
"alarma de micrófono, donde la alarma se apagaría a pesar del hecho que el "
"micrófono ya estaba apagado antes de que acabara la cuenta atrás de la "
"alarma)."

#: ..\python_docs\spladdoninternals.py:60
msgid ""
"* Unique feature labels: One way to stand out was to give features "
"interesting names. For instance, during add-on 3.0 development, I decided to "
"give cart learn mode a name that better reflects what the feature does: Cart "
"Explorer to explore cart assignments. Same could be set about NVDA's "
"implementation of enhanced arrow keys (called Track Dial, as the feature is "
"similar to flipping a dial on a remote control)."
msgstr ""
"* Etiquetas únicas de características: una manera de destacar el complemento "
"fue dar nombres interesantes a las características. Por ejemplo, durante el "
"desarrollo del complemento 3.0, decidí dar al modo de aprendizaje de cart un "
"nombre que reflejara mejor lo que hace esa función: explorador Cart para "
"explorar las asignaciones de Cart. Lo mismo podría hacerse con la "
"implementación de NVDA de las teclas de flecha mejoradas (llamada dial de "
"pista, ya que esta función es similar a girar una ruleta en un mando a "
"distancia)."

#: ..\python_docs\spladdoninternals.py:61
msgid ""
"* Extensive collaboration and feedback cycle between users and developers: I "
"believed that the real stars of the show were not the add-on code files, but "
"broadcasters who'll use various add-on features. Because of this, I worked "
"with users early on, and their continued feedback shapes future add-on "
"releases. This collaboration and feedback cycle also helped me (the add-on "
"author) understand how the add-on was used and to plan future features to "
"meet the needs of broadcasters who may use this add-on in various scenarios "
"(a good example is broadcast profiles, as you'll see in add-on configuration "
"section)."
msgstr ""
"* Extenso ciclo de colaboración y retroalimentación entre usuarios y "
"desarrolladores: yo creía que las auténticas estrellas del espectáculo no "
"eran los archivos de código del complemento, sino los locutores que usarían "
"diversas características del complemento. Por ello, trabajé con los usuarios "
"desde bien temprano, y sus comentarios continuos dan forma a las versiones "
"futuras del complemento. Este ciclo de colaboración y retroalimentación "
"también me ayudó a mí (el autor del complemento) a entender cómo se usaba el "
"complemento y a planear futuras características para satisfacer las "
"necesidades de los locutores que pueden usar este complemento en diversos "
"escenarios (un buen ejemplo son los perfiles de emisión, como verás en la "
"sección de configuración del complemento)."

#: ..\python_docs\spladdoninternals.py:62
msgid "### Why two layer sets?"
msgstr "### ¿Por qué dos capas de conjuntos?"

#: ..\python_docs\spladdoninternals.py:63
msgid ""
"When I first sat down to design the add-on, I knew I had to write both an "
"app module and a global plugin (to perform Studio commands from anywhere), "
"which led to defining two layer command sets for specific purposes:"
msgstr ""
"Cuando al principio me senté a diseñar el complemento, ya sabía que tendría "
"que escribir un módulo de aplicación y una extensión global (para ejecutar "
"órdenes de Studio desde cualquier sitio), lo que llevó a definir dos capas "
"de conjuntos de órdenes con propósitos específicos:"

#: ..\python_docs\spladdoninternals.py:64
msgid ""
"* SPL Assistant: This layer command set is available in the app module and "
"is intended to obtain status information and to manage app module features. "
"I called this Assistant because this layer serves as an assistant to a "
"broadcaster in reading various status information. More details can be found "
"later in this article."
msgstr ""
"* Asistente de SPL: esta capa de conjunto de órdenes está disponible en el "
"módulo de aplicación y está pensada para obtener información de estado y "
"para gestionar las características del módulo de aplicación. La llamé "
"asistente porque esta carpa sirve como el asistente de un locutor al leer "
"diversa información de estado. Se pueden encontrar más detalles más adelante "
"en este artículo."

#: ..\python_docs\spladdoninternals.py:65
msgid ""
"* SPL Controller: This layer is for the global plugin and performs Studio "
"commands from anywhere. I called this \"controller\" because it controls "
"various functions of Studio from other programs. More details will be "
"provided below."
msgstr ""
"* Controlador de SPL: esta capa es para la extensión global y ejecuta "
"órdenes de Studio desde cualquier parte. La llamé \"controlador\" porque "
"controla varias funciones de Studio desde otros programas. Más abajo se "
"darán más detalles."

#: ..\python_docs\spladdoninternals.py:66
msgid ""
"In the early days, I enforced this separation, but in add-on 6.0, it is "
"possible to invoke SPL Assistant layer by pressing the command used to "
"invoke SPL Controller. In add-on 7.0, it is possible for SPL Assistant to "
"emulate commands from other screen reader scripts, and the mechanics of it "
"is covered later in this article."
msgstr ""
"En los primeros días reforcé esta separación, pero en el complemento 6.0 es "
"posible invocar la capa del asistente de SPL pulsando la orden que se usa "
"para invocar al controlador de SPL. En el complemento 7.0, es posible para "
"el asistente de SPL emular órdenes de scripts para otros lectores de "
"pantalla, y los mecanismos que lo permiten se cubren más adelante en este "
"artículo."

#: ..\python_docs\spladdoninternals.py:67
msgid "### The \"magic\" behind layer commands"
msgstr "### La \"magia\" tras las órdenes de capa"

#: ..\python_docs\spladdoninternals.py:68
msgid ""
"In order for layer commands to work, I borrowed code from another add-on: "
"Toggle and ToggleX by Tyler Spivey. Toggle/ToggleX allows one to toggle "
"various formatting announcement settings via a layer command set. It works "
"like this:"
msgstr ""
"Para que las órdenes de capa funcionaran, tomé prestado código de otro "
"complemento: Toggle y ToggleX, de Tyler Spivey. Toggle / ToggleX permite "
"alternar varios ajustes de verbalización de formato a través de un conjunto "
"de capa de órdenes. Trabaja de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:69
msgid ""
"* Dynamic Command:script binding and removal: It is possible to bind "
"gestures dynamically via bindGesture/bindGestures method for an app module "
"or a global plugin (bindGesture binds a single command to a script, whereas "
"bindGestures binds commands to scripts from a gestures map or another "
"container). To remove gesture map dynamically, the main/layer gestures combo "
"was cleared, then the main gestures were bound."
msgstr ""
"* Orden dinámica: asociación y eliminación de script: es posible asociar "
"gestos dinámicamente a través del método bindGesture / bindGestures para un "
"módulo de aplicación o una extensión global (bindGesture asocia una única "
"orden a un script, mientras que bindGestures asocia órdenes a scripts desde "
"un mapa de gestos u otro contenedor). Para eliminar el mapa de gestos "
"dinámicamente, se limpiaba la combinación de gestos principales / de capa, y "
"después se asociaban los gestos principales."

#: ..\python_docs\spladdoninternals.py:70
msgid ""
"* Use of two or more gesture maps in the app module/global plugin: Normally, "
"an app module or a global plugin that accepts keyboard input uses a single "
"gestures map (called __gestures; a map is another term for dictionaries or "
"associative array where there is a value tied to a key). But in order for "
"layers to work, a second gestures map was provided to store layer commands "
"(command and the bound script of the form \"command\":\"script\")."
msgstr ""
"* Uso de dos o más mapas de gestos en el módulo de aplicación / extensión "
"global: normalmente, un módulo de aplicación o extensión global que que "
"acepta entrada por teclado usa un mapa de gestos único (llamado __gestures; "
"un mapa es otro término para diccionarios o arrays asociativos donde hay un "
"valor asociado a una clave). Pero para que las capas funcionen, se ofrecía "
"un segundo mapa de gestos para almacenar las órdenes de capa (la orden y el "
"script asociado de la forma \"orden\":\"script\")."

#: ..\python_docs\spladdoninternals.py:71
msgid ""
"* Wrapped functions: Tyler used \"wraps\" decorator from functools to wrap "
"how \"finally\" function is called from within the layer set (this was "
"needed to remove bindings for layer commands after they are done). Also, a "
"custom implementation of getScript function (app module/global plugin) was "
"used to return either the main script of the layer version depending on "
"context."
msgstr ""
"* Funciones envueltas: Tyler usaba el decorador \"wraps\" de functools para "
"encapsular cómo se llama a la función \"finalmente\" en el conjunto de capa "
"(esto era necesario para eliminar asociaciones de órdenes de capa después de "
"ejecutarse). Además, se usó una implementación personalizada de la función "
"getScript (módulo de aplicación / extensión global) para devolver el script "
"principal de la versión de la capa dependiendo del contexto."

#: ..\python_docs\spladdoninternals.py:72
msgid "A typical layer command execution is as follows:"
msgstr "La ejecución típica de las órdenes de capa es como sigue:"

#: ..\python_docs\spladdoninternals.py:73
msgid ""
"1. First, assign a command to a layer (entry) command (add-on 2.0 and later; "
"add-on 1.x used NVDA+Grave for SPL Controller and Control+NVDA+Grave for the "
"Assistant layer; removed in 2.0 to prevent conflicts with language-specific "
"gestures)."
msgstr ""
"1. Primero, se asigna una orden a una capa (entrada) orden (complemento 2.0 "
"y posterior; el complemento 1.x usaba NVDA+` para el controlador de SPL y "
"ctrl+NVDA+` para la capa del asistente; se eliminó en la 2.0 para prevenir "
"conflictos con gestos específicos del idioma)."

#: ..\python_docs\spladdoninternals.py:74
msgid ""
"2. You press the layer entry command. This causes the app module/global "
"plugin to perform the following:"
msgstr ""
"2. Pulsas la orden de entrada de la capa. Esto causa que el módulo de "
"aplicación o extensión global haga lo siguiente:"

#: ..\python_docs\spladdoninternals.py:75
msgid ""
"\t1. Layer conditions are checked. Until add-on 6.x, the app module wanted "
"to see if you are in the Playlist Viewer (relaxed in add-on 7.0), and for "
"the global plugin, checks if Studio is running."
msgstr ""
"\t1. Se comprueban las condiciones de capa. Hasta el complemento 6.x, el "
"módulo de aplicación quería ver si estabas en el visor de listas de "
"reproducción (se relajó en el complemento 7.0), y para la extensión global, "
"comprueba si Studio está en ejecución."

#: ..\python_docs\spladdoninternals.py:76
msgid ""
"\t2. Sets a flag telling NVDA that the Assistant/Controller layer is active."
msgstr ""
"\t2. Se establece un indicador para decirle a NVDA que la capa del "
"asistente / controlador está activa."

#: ..\python_docs\spladdoninternals.py:77
msgid ""
"\t3. Adds gestures for the layer set to the main gestures map via "
"bindGestures function. In case of screen reader emulation in SPL Assistant, "
"the appropriate gestures map is selected."
msgstr ""
"\t3. Se añaden los gestos del conjunto de la capa al mapa principal de "
"gestos a través de la función bindGestures. En el caso de la emulación de "
"lector de pantalla en el asistente de SPL, se selecciona el mapa apropiado "
"de gestos."

#: ..\python_docs\spladdoninternals.py:78
msgid ""
"3. You press a command in the layer set (such as A from Assistant to hear "
"automation status, or press A to turn automation on if using SPL Controller "
"layer). Depending on how the layer script is implemented, it either calls "
"Studio API (for SPL Controller layer and for some Assistant commands) or "
"simulates object navigation to fetch needed information (Assistant layer). "
"In the app module, for performance reasons, the object is cached. More "
"details on mechanics of this procedure in subsequent sections."
msgstr ""
"3. Pulsas una orden en el conjunto de la capa (como la A de asistente para "
"oír el estado de la automatización, o la A para activar la automatización si "
"se usa la capa del controlador de SPL). Dependiendo de cómo esté "
"implementado el script de capa, llama a la api de Studio (para la capa de "
"controlador de SPL y algunas órdenes del asistente) o bien simula navegación "
"de objetos para recuperar la información necesaria (capa del asistente). En "
"el módulo de aplicación, por razones de rendimiento, el objeto se mete en "
"caché. Hay más detalles de los mecanismos de este procedimiento en las "
"siguientes secciones."

#: ..\python_docs\spladdoninternals.py:79
msgid ""
"4. After the layer command is done, it calls \"finish\" function (app module/"
"global plugin) to perform clean up actions such as:"
msgstr ""
"4. Después de que se haya hecho la orden de capa, se llama a la función "
"\"finish\" (módulo de aplicación / extensión global) para realizar acciones "
"de limpieza tales como:"

#: ..\python_docs\spladdoninternals.py:80
msgid "\t* Clears layer flags."
msgstr "\t* Limpiar los indicadores de capa."

#: ..\python_docs\spladdoninternals.py:81
msgid ""
"\t* Removes the \"current\" gestures (main gestures and layer commands) and "
"reassigns it to the main gestures map (this is dynamic binding removal)."
msgstr ""
"\t* eliminar los gestos \"actuales\" (gestos principales y gestos de capa) y "
"reasignarlos al mapa principal de gestos (esto se llama eliminación dinámica "
"de asociaciones)."

#: ..\python_docs\spladdoninternals.py:82
msgid ""
"\t* Performs additional actions depending on context (for example, if Cart "
"Explorer was in use)."
msgstr ""
"\t* Realizar acciones adicionales dependiendo del contexto (por ejemplo, si "
"el explorador cart estaba en uso)."

#: ..\python_docs\spladdoninternals.py:83
msgid "### The importance of Studio window handle and Studio API"
msgstr ""
"### La importancia del manejador de ventana de Studio y la api de Studio"

#: ..\python_docs\spladdoninternals.py:84
msgid ""
"In order to use services offered by Studio, one has to use Studio API, which "
"in turn requires one to keep an eye on window handle to Studio (in Windows "
"API, a window handle (just called handle) is a reference to something, such "
"as a window, a file, connection routines and so on). This is important if "
"one wishes to perform Studio commands from other programs (Studio uses "
"messages to communicate with the outside program in question via user32."
"dll's SendMessage function)."
msgstr ""
"Para usar los servicios que ofrece Studio, se debe utilizar la api de "
"Studio, que básicamente necesita que tengamos vigilado el manejador de "
"ventana de Studio (en la api de Windows, un manejador de ventana "
"(simplemente llamado manejador) es una referencia a algo, como a una "
"ventana, un archivo, procedimientos de conexión y así sucesivamente). Es "
"importante si se desean ejecutar órdenes de Studio desde otros programas "
"(Studio usa mensajes para comunicarse con el programa externo en cuestión "
"mediante la función SendMessage de user32.dll)."

#: ..\python_docs\spladdoninternals.py:85
#, fuzzy
#| msgid ""
#| "Starting from add-on 7.0, one of the activities the app module performs "
#| "when started (besides announcing the version of Studio you are using) is "
#| "to look for the handle to Studio's main window until it is found (this is "
#| "done via a thread which calls user32.dll's FindWindowA (not FindWindowW) "
#| "function every second), and once found, the app module caches this "
#| "information for later use. A similar check is performed by SPL Controller "
#| "command, as without this, SPL Controller is useless (as noted earlier). "
#| "Because of the prominence of the Studio API and the window handle, one of "
#| "the first things I do whenver new versions of Studio is released is to "
#| "ask for the latest Studio API and modify the app module and/or global "
#| "plugin accordingly."
msgid ""
"Starting from add-on 7.0, one of the activities the app module performs when "
"started (besides announcing the version of Studio you are using) is to look "
"for the handle to Studio's main window until it is found (this is done via a "
"thread which calls user32.dll's FindWindowW (FindWindowA until late 2018 as "
"explained below) function every second), and once found, the app module "
"caches this information for later use. A similar check is performed by SPL "
"Controller command, as without this, SPL Controller is useless (as noted "
"earlier). Because of the prominence of the Studio API and the window handle, "
"one of the first things I do whenver new versions of Studio is released is "
"to ask for the latest Studio API and modify the app module and/or global "
"plugin accordingly."
msgstr ""
"Desde el complemento 7.0, una de las actividades que realiza el módulo de "
"aplicación cuando se inicia (además de verbalizar la versión de Studio que "
"estás usando) es buscar el manejador de la ventana principal de Studio hasta "
"que lo encuentra (esto se hace mediante un hilo que llama a la función "
"FindWindowA (y no FindWindowW) de user32.dll cada segundo), y una vez que lo "
"encuentra, el módulo de aplicación guarda esta información para uso futuro. "
"El controlador SPL realiza una comprobación similar, ya que sin el "
"manejador, el controlador de SPL es inútil (como se ha explicado antes). "
"Debido a la importancia de la api de Studio y el manejador de ventana, una "
"de las primeras cosas que hago cada vez que se publica una nueva versión de "
"Studio es pedir la última api de Studio y modificar ell módulo de aplicación "
"y / o la extensión global en consecuencia."

#: ..\python_docs\spladdoninternals.py:86
msgid "#### FindWindowA versus FindWindowW"
msgstr ""

#: ..\python_docs\spladdoninternals.py:87
msgid ""
"In the old days of Windows (1990's), programs were not ready to support "
"Unicode when Windows itself did. To support programs that are not Unicode-"
"aware, Microsoft defined two versions of a given Windows API function. For "
"example, there were two versions of FindWindow function, the difference "
"being the final character as follows:"
msgstr ""

#: ..\python_docs\spladdoninternals.py:88
msgid "* A: ANSI version meant for legacy programs (e.g. FindWindowA)."
msgstr ""

#: ..\python_docs\spladdoninternals.py:89
msgid "* W: Widechar (Unicode) character version (e.g. FindWindowW)."
msgstr ""

#: ..\python_docs\spladdoninternals.py:90
msgid ""
"In reality, programs call FindWindow function, and the appropriate \"version"
"\" was chosen based on overall character representation macro as specified "
"by the program. For example, if the program was unicode-aware, when "
"FindWindow is called, Windows internally calls FindWindowW."
msgstr ""

#: ..\python_docs\spladdoninternals.py:91
msgid ""
"Until 2018, Studio app module and other components of the add-on called "
"FindWindowA due to the fact that, in Python 2, a string is a read-only array "
"of ANSI characters. Python 3 (and if a string is prefixed with \"u\" in "
"Python 2) uses immutable array of Unicode characters for strings. "
"Internally, NVDA expects Unicode strings for the function that wraps "
"FindWindow function (located in winUser module), thus mimicking Python 3 "
"behavior. Studio add-on adopted FindWindowW behavior in late 2018, but the "
"wrapper provided by NVDA is not used due to incorrect error checking "
"behavior in NVDA (if window handle is 0 (NULL), success error is raised, "
"which goes against specifications from Windows API)."
msgstr ""

#: ..\python_docs\spladdoninternals.py:92
msgid "## Life of the SPL app module"
msgstr "## Vida del módulo de aplicación de SPL"

#: ..\python_docs\spladdoninternals.py:93
msgid ""
"Note: For the rest of this article, you'll see some portions of the source "
"code to let you better understand how something works (mostly pseudo code "
"will be provided). Also, certain things will require explaining how NVDA "
"Core (the screen reader itself) works (so you'll learn several things at "
"once)."
msgstr ""
"Nota: durante el resto de este artículo, verás algunas porciones del código "
"fuente para hacerte entender mejor cómo funciona algo (mayoritariamente se "
"proporcionará pseudocódigo). Además, para algunas cosas será necesario "
"explicar cómo funciona el núcleo de NVDA (el lector de pantalla en sí) (por "
"lo que aprenderás muchas cosas de una vez)."

#: ..\python_docs\spladdoninternals.py:94
msgid "### SPL Studio app module and friends: design and code overview"
msgstr ""
"### Módulo de aplicación de SPL Studio y amigos: descripción del diseño y "
"del código"

#: ..\python_docs\spladdoninternals.py:95
msgid ""
"As noted previously, the SPL Studio app module (splstudio/__init__.py) and "
"friends (other app modules) consists of several sections. These include "
"(from top to bottom):"
msgstr ""
"Como se ha indicado antes, el módulo de aplicación de SPL Studio (splstudio/"
"__init__.py) consta de varias secciones. Estas incluyen (de arriba a abajo):"

#: ..\python_docs\spladdoninternals.py:96
msgid ""
"* Imports: Many modules from Python packages and from NVDA screen reader are "
"imported here, including IAccessible controls support, configuration manager "
"and so on."
msgstr ""
"* Importaciones: aquí se importan muchos módulos de diversos paquetes Python "
"y del lector de pantalla NVDA, incluyendo soporte para controles de "
"IAccessible, gestor de configuración y así sucesivamente."

#: ..\python_docs\spladdoninternals.py:97
msgid ""
"* Layer command wrapper: I talked about how layer commands work in a "
"previous chapter, and the \"finally\" function at the top is the one that "
"makes this possible."
msgstr ""
"* Envoltura de orden de capa: ya dije en un capítulo anterior cómo "
"funcionaban las órdenes de capa, y la función \"finally\" al principio es la "
"que hace esto posible."

#: ..\python_docs\spladdoninternals.py:98
msgid ""
"* Few helper functions and checks: This includes a flag specifying minimum "
"version of Studio needed, the cached value for Studio window handle (SPLWin) "
"and place holders for threads such as microphone alarm timer (more on this "
"in threads section). This section also includes helper functions such as "
"\"messageSound\" (displays a message on a braille display and plays a wave "
"file) and other helper functions."
msgstr ""
"* Unas pocas comprobaciones y funciones auxiliares: aquí se incluye un "
"indicador que especifica la mínima versión de Studio requerida, el valor "
"almacenado para el manejador de ventana de Studio (SPLWin), y referencias "
"para hilos como el temporizador de alarma del micrófono (más sobre esto en "
"la sección de hilos). Esta sección también incluye funciones auxiliares como "
"\"messageSound\" (muestra un mensaje en una pantalla Braille y reproduce un "
"archivo wav) y otras funciones auxiliares."

#: ..\python_docs\spladdoninternals.py:99
msgid ""
"* Track item overlay classes: three classes are defined for various "
"purposes. The first is a base class that provides commands and services "
"across Studio and other apps, while other two classes provide support for "
"Playlist Viewer items in Studio 5.0x and 5.1x, respectivley. We'll come back "
"to these objects later."
msgstr ""
"* Clases de superposición del elemento de pista: se definen tres clases con "
"diversos propósitos. La primera es una clase base que proporciona órdenes y "
"servicios a través de Studio y otras aplicaciones, mientras que las otras "
"dos clases proporcionan soporte para el visor de elementos de lista de "
"reproducción en Studio 5.0x y 5.1x, respectivamente. Volveremos a estos "
"objetos más tarde."

#: ..\python_docs\spladdoninternals.py:100
msgid ""
"* App module class: This is the core of not only the app module, but the "
"entire add-on package. The app module class (appModules.splstudio.AppModule) "
"is further divided into sections as described in add-on design chapter."
msgstr ""
"* Clase del módulo de aplicación: este es el núcleo no sólo del módulo de "
"aplicación, sino del paquete del complemento entero. La clase del módulo de "
"aplicación (appModules.splstudio.AppModule) está a su vez dividida en "
"secciones como se describe en el capítulo de diseño del complemento."

#: ..\python_docs\spladdoninternals.py:101
msgid ""
"For Studio's colleagues (Creator and Track Tool), they consist of sections "
"listed above except layer command wrapper, and track item classes are "
"simplified."
msgstr ""
"Los compañeros de Studio (Creator y herramienta de pista) se explican en las "
"secciones listadas arriba excepto la capa de envoltura de órdenes, y se han "
"simplificado las clases de elemento de pista."

#: ..\python_docs\spladdoninternals.py:102
msgid ""
"Let's now tour the lifecycle of the app module object in question: before "
"and during app module initialization, activities performed while the app "
"module is active, death and add-on updates."
msgstr ""
"Recorramos ahora el ciclo de vida del objeto del módulo de aplicación en "
"cuestión: antes y durante la inicialización del módulo de aplicación, "
"actividades realizadas mientras el módulo de aplicación está activo, muerte "
"y actualizaciones del complemento."

#: ..\python_docs\spladdoninternals.py:103
msgid "### Before birth: NVDA's app module import routines"
msgstr ""
"### Antes de nacer: procedimientos de importación del módulo de aplicación "
"de NVDA"

#: ..\python_docs\spladdoninternals.py:104
msgid ""
"Before we go any further, it is important for you to understand how NVDA "
"loads various app modules. This routine, available from source/"
"appModuleHandler.py (NVDA Core), can be summarized as follows:"
msgstr ""
"Antes de que profundicemos más, es importante que entiendas cómo carga NVDA "
"distintos módulos de aplicación. Este procedimiento, disponible en source/"
"appModuleHandler.py (núcleo de NVDA) puede resumirse de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:105
msgid ""
"1. If a new process (program) runs, NVDA will try to obtain the process ID "
"(PID) for the newly loaded process."
msgstr ""
"1. Si se ejecuta un nuevo proceso (programa), NVDA intentará obtener el "
"identificador de proceso (PID) para el proceso recién cargado."

#: ..\python_docs\spladdoninternals.py:106
msgid ""
"2. Next, NVDA will look for an app module matching the name of the "
"executable for the newly created process. It looks in various places, "
"including source/appModules, userConfigDirectory/appModules and addonname/"
"appModules, then resorting to the default app module if no app module with "
"the given name is found."
msgstr ""
"2. A continuación, NVDA buscará un módulo de aplicación que encaje con el "
"nombre del ejecutable del proceso recién creado. Mira en varios lugares, "
"entre ellos source/appModules, directorio de configuración de usuario/"
"appModules y complemento/appModules, luego vuelve al módulo de aplicación "
"por defecto si no encuentra ningún módulo de aplicación con el nombre "
"especificado."

#: ..\python_docs\spladdoninternals.py:107
msgid ""
"3. Next, NVDA will attempt to use Python's built-in __import__ function to "
"load the app module, raising errors if necessary. No errors means the app "
"module is ready for use."
msgstr ""
"3. Después, NVDA intentará usar la función __import__ integrada en Python "
"para cargar el módulo de aplicación, lanzando errores si es necesario. Si no "
"hay errores significa que el módulo de aplicación está listo para usarse."

#: ..\python_docs\spladdoninternals.py:108
msgid ""
"4. Once the newly loaded module is ready, NVDA will instantiate appModule."
"AppModule class (make it available). If a constructor (__init__ method) is "
"defined, Python (not NVDA) will call the app module constructor (more on "
"this below)."
msgstr ""
"4. Una vez esté listo el módulo recién cargado, NVDA instanciará la clase "
"appModule.AppModule (la pondrá disponible). Si se define un constructor "
"(método __init__), Python (y no NVDA) llamará al constructor del módulo de "
"aplicación (más sobre esto debajo)."

#: ..\python_docs\spladdoninternals.py:109
msgid ""
"In case the app module's AppModule class has a constructor defined, Python "
"will follow directions specified in the constructor. Just prior to "
"performing app module specific constructor routines, it is important to call "
"the constructor for the default app module first as in the following code:"
msgstr ""
"En caso de que la clase AppModule del módulo de aplicación tenga un "
"constructor definido, Python seguirá las órdenes especificadas en ese "
"constructor. Antes de hacer los procedimientos de inicialización específicos "
"del módulo de aplicación, es importante llamar primero al constructor del "
"módulo de aplicación por defecto como en el siguiente código:"

#: ..\python_docs\spladdoninternals.py:110
msgid "\tdef __init__(self, *args, **kwargs):"
msgstr "\tdef __init__(self, *args, **kwargs):"

#: ..\python_docs\spladdoninternals.py:111
msgid "\t\tsuper(AppModule, self).__init__(*args, **kwargs)"
msgstr "\t\tsuper(AppModule, self).__init__(*args, **kwargs)"

#: ..\python_docs\spladdoninternals.py:112
msgid ""
"This is a must because the default app module constructor performs important "
"activities, including:"
msgstr ""
"Esto es obligatorio porque el constructor del módulo de aplicación por "
"defecto realiza actividades importantes, incluyendo:"

#: ..\python_docs\spladdoninternals.py:113
msgid ""
"1. The default app module constructor will call another base constructor "
"(this time, it is baseObject.ScriptableObject, containing gestures support "
"among other important properties)."
msgstr ""
"1. El constructor del módulo de aplicación por defecto llamará a otro "
"constructor base (en esta ocasión, se trata de baseObject.ScriptableObject, "
"que contiene soporte de gestos entre otras propiedades importantes)."

#: ..\python_docs\spladdoninternals.py:114
msgid ""
"2. Initializes various properties, such as PID (process ID), app module name "
"(if defined), application name and the handle to the app in question via "
"kernel32.dll's OpenProcess function (XP/Server 2003 and Vista/Server 2008 "
"and later requires different arguments)."
msgstr ""
"2. Inicializa diversas propiedades, como PID (identificador de proceso), "
"nombre del módulo de aplicación (si está definido), nombre de la aplicación "
"y manejador hacia la aplicación en cuestión mediante la función OpenProcess "
"de kernel32.dll (XP/Server 2003 y Vista/Server 2008 y posterior necesitan "
"argumentos distintos)."

#: ..\python_docs\spladdoninternals.py:115
msgid ""
"3. Lastly, the constructor initializes process injection handle and helper "
"binding handle in case such routines are required."
msgstr ""
"3. Por último, el constructor inicializa el manejador de inyección de "
"proceso y el manejador de asociación auxiliar en caso de que se necesiten "
"estos procedimientos."

#: ..\python_docs\spladdoninternals.py:116
msgid "### Birth: app module construction"
msgstr "### Nacimiento: construcción del módulo de aplicación"

#: ..\python_docs\spladdoninternals.py:117
msgid ""
"Certain app module add-ons shipts with an app module with a constructor "
"define, and SPL Studio is one of them; in 2018, constructors were added to "
"Creator and Track Tool for various purposes. After calling the base "
"constructor as described above, SPL app module's constructor (__init__ "
"method that runs when the app module starts) does the following:"
msgstr ""
"Ciertos complementos con módulos de aplicación vienen con un módulo de "
"aplicación con un constructor definido, y SPL Studio es uno de ellos; en "
"2018, se añadieron constructores a Creator y a la herramienta de pista con "
"diversos propósitos. Después de llamar al constructor base como se describe "
"arriba, el constructor del módulo de aplicación de SPL (método __init__ que "
"se ejecuta cuando se inicia el módulo de aplicación) hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:118
#, fuzzy
#| msgid ""
#| "1. Checks whether a supported version of Studio is running, and if not, "
#| "raises RuntimeError exception, preventing you from using the app module "
#| "while an unsupported version of Studio is in use (as of add-on 7.0, you "
#| "need to use Studio 5.00 and later)."
msgid ""
"1. Checks whether a supported version of Studio is running, and if not, "
"raises RuntimeError exception, preventing you from using the app module "
"while an unsupported version of Studio is in use (as of add-on 17.04, you "
"need to use Studio 5.10 and later)."
msgstr ""
"1. Comprueba si se está ejecutando una versión soportada de Studio, y si no "
"es así, se lanza una excepción RuntimeError, impidiendo que uses el módulo "
"de aplicación mientras esté en uso una versión no soportada de Studio (a "
"partir del complemento 7.0, es necesario usar Studio 5.00 o posterior)."

#: ..\python_docs\spladdoninternals.py:119
msgid ""
"2. Unless silenced by `globalVars.appArgs.minimal` being True, NVDA "
"announces, \"Using SPL Studio version 5.01\" if Studio 5.01 is in use (of "
"course, NVDA will say 5.10 when Studio 5.10 is in use). This is done via ui."
"message function (part of NVDA Core) which lets you hear spoken messages or "
"read the message on a braille display. In reality, ui.message function calls "
"two functions serially (one after the other): speech.speakMessage (speaking "
"something via a synthesizer) and braille.handler.message (brailling messages "
"on a braille display if connected)."
msgstr ""
"2. A menos que se silencie poniendo `globalVars.appArgs.minimal` a True, "
"NVDA verbaliza \"Usando SPL Studio versión 5.01\" si Studio 5.01 está en uso "
"(por supuesto, NVDA dirá 5.10 cuando Studio 5.10 esté en uso). Esto se hace "
"mediante la función ui.message (parte del núcleo de NVDA), que te permite "
"oír mensajes hablados o leer el mensaje en una pantalla braille. En "
"realidad, la función ui.message llama en serie a dos funciones (una después "
"de la otra): speech.speakMessage (hablando algo mediante un sintetizador) y "
"braille.handler.message (mostrando mensajes en una pantalla braille si hay "
"alguna conectada)."

#: ..\python_docs\spladdoninternals.py:120
#, fuzzy
#| msgid ""
#| "3. Next, add-on settings and related subsystems are initialized by "
#| "calling splconfig.initialize(). For add-on 6.x and 7.x, the first four "
#| "steps are performed by the init (formerly initConfig) function itself, "
#| "while in 8.0 it is handled by SPLConfig ConfigHub class constructor. Add-"
#| "on 17.10 changes this significantly (see the next section). This is done "
#| "as follows:"
msgid ""
"3. Next, add-on settings and related subsystems are initialized by calling "
"splconfig.initialize(). For add-on 6.x and 7.x, the first four steps are "
"performed by the init (formerly initConfig) function itself, while in 8.0 it "
"is handled by SPLConfig ConfigHub class constructor. Add-on 17.10 changes "
"this significantly, and in 18.07 and later, some steps are skipped if "
"another STudio app is in use (see the next few sections). This is done as "
"follows:"
msgstr ""
"3. A continuación, se inicializan los ajustes del complemento y los "
"subsistemas relacionados llamando a splconfig.initialize(). Para los "
"complementos 6.x y 7.x, se hacen los cuatro primeros pasos en la misma "
"función init (conocida como initConfig), mientras que en el 8.0 se encarga "
"de esto el constructor de la clase SPLConfig. El complemento 17.10 cambia "
"esto de forma significativa (mira la siguiente sección). Esto se hace de la "
"siguiente manera:"

#: ..\python_docs\spladdoninternals.py:121
msgid ""
"\t1. For add-on 6.x and 7.x, loads a predefined configuration file named "
"userConfigPath/splstudio.ini. In add-on 6.0 and later, this is known as "
"\"normal profile). In add-on 6.x and 7.x, this is done by calling splconfig."
"unlockConfig() function that handles configuration validation via ConfigObj "
"and Validator, and in 8.0 and later, this is part of SPLConfig constructor. "
"In add-on 17.10 and later, this step will not take place if NVDA is told to "
"use an in-memory config, and in 18.07 and later, any SPL app module that "
"opens SPLConfig (splconfig.openConfig) will register its app name to "
"indicate which app is starting."
msgstr ""
"\t1. Para los complementos 6.x y 7.x, se carga un archivo de configuración "
"predefinido llamado rutaAjustesDeUsuario/splconfig.ini. En el complemento "
"6.0 y versiones posteriores, esto se conoce como \"perfil normal\". En los "
"complementos 6.x y 7.x, esto se hace llamando a la función splconfig."
"unlockConfig(), que se encarga de la validación de la configuración mediante "
"ConfigObj y Validator, y en el 8.0 y posteriores, esto es parte del "
"constructor de SPLConfig. En el complemento 17.10 y posteriores, este paso "
"no tendrá lugar si decimos a NVDA que utilice configuración en memoria, y en "
"la versión 18.07 y posteriores, cualquier módulo de aplicación de SPL que "
"abra SPLConfig (splconfig.openConfig) registrará el nombre de la aplicación "
"para indicar qué aplicación se está iniciando."

#: ..\python_docs\spladdoninternals.py:122
msgid ""
"\t2. For add-on 6.0 and later, loads broadcast profiles from addonDir/"
"profiles folder. These are .ini files and are processed just like the normal "
"profile except that global settings are pulled in from the normal profile. "
"In add-on 8.0, just like normal profile, this is done when constructing "
"SPLConfig object. In add-on 17.10 and later, if the add-on is told to use "
"normal profile only, this step will not occur."
msgstr ""
"\t2. Para el complemento 6.0 y posteriores, se cargan los perfiles de "
"emisión desde la carpeta rutaDelComplemento/profiles. Son archivos .ini y se "
"procesan como se hace con el perfil normal salvo porque los ajustes globales "
"se toman desde el perfil normal. En el complemento 8.0, al igual que con el "
"perfil normal, esto se hace al construir el objeto SPLConfig. En el "
"complemento 17.10 y posteriores, si decimos al complemento que use solamente "
"el perfil normal, no se hará este paso."

#: ..\python_docs\spladdoninternals.py:123
msgid ""
"\t3. Each profile is then appended to a record keeper container (splconfig."
"SPLConfigPool for 6.x and 7.x, splconfig.SPLConfig.profiles in 8.0 and "
"later). Then the active profile is set and splconfig.SPLConfig (user "
"configuration map) is set to the first profile in the configuration pool "
"(normal profile; for add-on 5.x and earlier or if only normal profile is to "
"be used (17.10 and later), there is (or will be) just one profile so append "
"step is skipped)."
msgstr ""
"\t3. A continuación, cada perfil se anexa a un contenedor encargado de los "
"registros (splconfig.SPLConfigPool para 6.x y 7.x, splconfig.SPLConfig."
"profiles en 8.0 y posteriores). Después se establece el perfil activo y "
"splconfig.SPLConfig (mapa de configuración del usuario) se establece al "
"primer perfil en el contenedor de configuración (perfil normal; para el "
"complemento 5.x y anteriores o si sólo va a usarse el perfil normal (17.10 y "
"posteriores), hay (o habrá) simplemente un perfil, por lo que el paso de "
"anexar se omite)."

#: ..\python_docs\spladdoninternals.py:124
msgid ""
"\t4. Starting from add-on 7.0 and enhanced in 17.10, unless saving settings "
"to disk is prohibited or in-memory config is requested, Normal profile "
"dictionary (not others) is cached. This is useful in keeping a record of "
"settings loaded from disk versus run-time configuration and is employed when "
"comparing values when saving profiles. See profile caching section in "
"broadcast profiles for details and reasons."
msgstr ""
"\t4. Empezando con el complemento 7.0 y mejorándolo en 17.10, a menos que "
"guardar los ajustes en disco esté prohibido o se solicite la configuración "
"en memoria, el diccionario del perfil normal (y no otros) se guarda. Esto es "
"útil para conservar un registro de ajustes cargados de disco contra la "
"configuración en tiempo de ejecución, y se emplea al comparar valores al "
"guardar perfiles. Mira la sección de guardado de perfiles en perfiles de "
"emisión para más detalles y razones."

#: ..\python_docs\spladdoninternals.py:125
msgid ""
"\t5. Starting from add-on 18.08,. if NVDA supports it, SPLConfig will listen "
"to config save action so add-on settings can be saved when config save "
"command (Control+NvDA+C) is invoked."
msgstr ""
"\t5. Comenzando con el complemento 18.08, si NVDA lo soporta, SPLConfig "
"escuchará la acción de guardar configuración para guardar los ajustes del "
"complemento cuando se invoque la orden para guardar la configuración (control"
"+NVDA+c)."

#: ..\python_docs\spladdoninternals.py:126
msgid ""
"\t6. If an instant profile is defined (a cached instant profile name is "
"present), the instant profile variable is set accordingly."
msgstr ""
"\t6. Si se define un perfil instantáneo (hay presente un nombre de perfil "
"instantáneo en la caché) se establece de forma apropiada la variable de "
"perfil instantáneo."

#: ..\python_docs\spladdoninternals.py:127
msgid ""
"\t7. If errors were found, NVDA either displays an error dialog (5.x and "
"earlier) or a status dialog (6.0 and later) detailing the error in question "
"and what NVDA has done to faulty profiles. This can range from applying "
"default values to some settings to resetting everything to defaults (the "
"latter will occur if validator reports that all settings in the normal "
"profile are invalid or ConfigObj threw parse errors, commonly seen when file "
"content doesn't make sense)."
msgstr ""
"\t7. Si se encuentran errores, NVDA muestra un diálogo de error (5.x y "
"anteriores) o bien un diálogo de estado (6.0 y posteriores) detallando el "
"error en cuestión y lo que ha hecho NVDA a los perfiles fallidos. Esto puede "
"pasar por aplicar valores por defecto a algunos ajustes para restablecer los "
"ajustes por defecto (lo último ocurrirá si el validador informa de que todos "
"los ajustes en el perfil normal son inválidos o configObj lanzó errores de "
"interpretación, vistos comúnmente cuando el contenido del archivo no tiene "
"sentido)."

#: ..\python_docs\spladdoninternals.py:128
#, fuzzy
#| msgid ""
#| "\t8. In add-on 7.0, add-on update facility is initialized (splupdate."
#| "initialize). among other things, the initialization routine loads update "
#| "check metadata. We'll meet add-on update routines (housed in splstudio/"
#| "splupdate.py) later in this article."
msgid ""
"\t8. In add-on 7.0, add-on update facility is initialized (splupdate."
"initialize). among other things, the initialization routine loads update "
"check metadata. In 2018, update initialization is done as part of app module "
"constructor. We'll meet add-on update routines (housed in splstudio/"
"splupdate.py) later in this article."
msgstr ""
"\t8. En el complemento 7.0, se inicializa la característica de "
"actualizaciones (splupdate.initialize). Entre otras cosas, el procedimiento "
"de inicialización carga los metadatos de búsqueda de actualizaciones. "
"Encontraremos los procedimientos de actualización del complemento (alojados "
"en splstudio/splupdate.py) más adelante en este artículo."

#: ..\python_docs\spladdoninternals.py:129
msgid ""
"\t9. Prepares routines used by time-based profile switching facility by "
"loading triggers map and checking if NVDA should switch to the next profile "
"(this is done if the show associated with the given profile hasn't ended "
"yet). See time-based profile section for details."
msgstr ""
"\t9. Se preparan los procedimientos usados por la característica de cambio "
"de perfil basado en tiempo cargando un mapa de disparadores y comprobando si "
"NVDA debería cambiar al siguiente perfil (esto se hace si el programa "
"asociado con el perfil dado no ha terminado todavía). Mira la sección de "
"perfiles basados en tiempo para más detalles."

#: ..\python_docs\spladdoninternals.py:130
msgid ""
"\t10. Encoder settings file is loaded, and if ConfigObj throws errors, "
"encoder settings will be reset to defaults."
msgstr ""
"\t10. Se carga el archivo de ajustes del codificador, y si ConfigObj lanza "
"errores, los ajustes del codificador se restablecen por defecto."

#: ..\python_docs\spladdoninternals.py:131
msgid ""
"\t11. In add-on 8.0, track comments are loaded (if any). See track items "
"section for details."
msgstr ""
"\t11. En el complemento 8.0, se cargan los comentarios de pista (si los "
"hay). Mira la sección de elementos de pista para más detalles."

#: ..\python_docs\spladdoninternals.py:132
msgid ""
"\t12. Although not part of the init routine, starting from 17.12, various "
"modules register one or more functions for action notifications. See "
"extension points section for details."
msgstr ""
"\t12. Aunque no es parte del procedimiento de inicialización, empezando con "
"el complemento 17.12, diversos módulos registran una o más funciones para "
"notificaciones de acción. Mira la sección de puntos de extensión para más "
"detalles."

#: ..\python_docs\spladdoninternals.py:133
msgid ""
"4. Starting with NVDA 2015.3, it became possible for an app module to "
"request NVDA to monitor certain events for certain controls even if the app "
"is not being used. This is done by calling eventHandler.requestEvents "
"function with three arguments: process ID, window class for the control in "
"question and the event to be monitored. For earlier versions of NVDA "
"(checked via built-in hasattr function), this step is skipped, and "
"background status monitor flag is then set accordingly. We'll discuss event "
"handling throughout this article."
msgstr ""
"4. Empezando con NVDA 2015.3, es posible para un módulo de aplicación "
"pedirle a NVDA que monitorice ciertos eventos para ciertos controles incluso "
"si no se está usando la app. Esto se hace llamando a la función eventHandler."
"requestEvents con tres argumentos: identificador del proceso, clase de "
"ventana para el control en cuestión y el evento a monitorizar. Para "
"versiones más antiguas de NVDA (comprobadas mediante la función incorporada "
"hasattr), se salta este paso, y el indicador de monitorización del estado en "
"segundo plano se establece de forma apropiada. Hablaremos del procesamiento "
"de eventos a lo largo de este artículo."

#: ..\python_docs\spladdoninternals.py:134
msgid ""
"5. Next, GUI subsystem is initialized (NVDA uses wxPython). This routine "
"adds an entry in NVDA's preferences menu entitled \"SPL Studio Settings\", "
"the add-on configuration dialog."
msgstr ""
"5. Después, se inicializa el subsistema gráfico (NVDA usa WXPython). Este "
"procedimiento añade una entrada en el menú de preferencias de NVDA, titulada "
"\"Ajustes de SPL Studio\", el diálogo de configuración del complemento."

#: ..\python_docs\spladdoninternals.py:135
msgid ""
"6. As described above, the app module will look for the window handle for "
"the Studio app. In order to avoid this routine consuming resources and "
"making NVDA not responsive, this is done in a separate thread. The thread "
"performs the following:"
msgstr ""

#: ..\python_docs\spladdoninternals.py:136
msgid ""
"\t1. Studio window handle is searched via a loop. If Studio exits for "
"whatever reason, an event flag is raised by the app module, causing this "
"thread to exit."
msgstr ""

#: ..\python_docs\spladdoninternals.py:137
msgid ""
"\t2. If the handle is found, its value is recorded in a flag found in base "
"services module (splbase)."
msgstr ""

#: ..\python_docs\spladdoninternals.py:138
#, fuzzy
#| msgid ""
#| "7. If the app module is told to announce status of metadata streaming and "
#| "connect to predefined URL's, NVDA will do it at this point. This is done "
#| "in the same function that looks for the Studio handle. In order to "
#| "announce status messages as the last announcement after connecting to "
#| "metadata servers, Studio app module places ui.message in the event queue "
#| "to be handled by NVDA (queueHandler.queueFunction). More on internals of "
#| "metadata announcement and related components in the SPL Assistant chapter."
msgid ""
"\t3. If the app module is told to announce status of metadata streaming and "
"connect to predefined URL's, NVDA will do it at this point provided that "
"Studio's playlist viewer (discussed later) is loaded. In order to announce "
"status messages as the last announcement after connecting to metadata "
"servers, Studio app module places ui.message in the event queue to be "
"handled by NVDA (queueHandler.queueFunction). More on internals of metadata "
"announcement and related components in the SPL Assistant chapter."
msgstr ""
"7. Si le decimos al módulo de aplicación que verbalice el estado del flujo "
"de metadatos y conexión a URLs predefinidas, NVDA hará todo eso en este "
"punto. Esto se hace en la misma función que busca el manejador de Studio. "
"Para verbalizar mensajes de estado como últimos mensajes después de conectar "
"a los servidores de metadatos, el módulo de aplicación de Studio sitúa ui."
"message en la cola de eventos para que sea procesada por NVDA (queueHandler."
"queueFunction). Hay más información sobre el interior de la verbalización de "
"metadatos y sus componentes relacionados en el capítulo del asistente de SPL."

#: ..\python_docs\spladdoninternals.py:139
#, fuzzy
#| msgid ""
#| "8. In add-on 7.0, if automatic update check is enabled, update check "
#| "timer is started."
msgid ""
"7. In add-on 7.0, if automatic update check is enabled, update check timer "
"is started."
msgstr ""
"8. En el complemento 7.0, si está activada la búsqueda automática de "
"actualizaciones, se inicia el temporizador asociado."

#: ..\python_docs\spladdoninternals.py:140
msgid "#### Changes introduced in 17.10 due to volatile configuration flags"
msgstr ""
"#### Cambios introducidos en 17.10 debido a indicadores de configuración "
"volátil"

#: ..\python_docs\spladdoninternals.py:141
msgid ""
"In add-on 17.10, several internal flags and associated command-line switches "
"are introduced to control how the add-on settings are loaded and treated. "
"Presence of these flags will significantly alter the way settings are loaded "
"and saved. These flags should be used when instructed by the add-on "
"developer, as they are used for troubleshooting or experimenting purposes."
msgstr ""
"En el complemento 17.10, se introducen varios indicadores internos y "
"argumentos de línea de órdenes asociados para controlar cómo se cargan y se "
"tratan los ajustes del complemento. La presencia de estos indicadores "
"alterará significativamente la forma en que se cargan y guardan los ajustes. "
"Estos indicadores deberían usarse cuando lo indique el desarrollador del "
"complemento, ya que su propósito es experimentar o solucionar problemas."

#: ..\python_docs\spladdoninternals.py:142
msgid "The flags are as follows:"
msgstr "Los indicadores son los siguientes:"

#: ..\python_docs\spladdoninternals.py:143
msgid ""
"1. Do not save changes to disk (configNoSave/--spl-confignosave): all "
"profiles (including broadcast profiles) will be loaded from disk but changes "
"will not be saved. With this flag turned on, profile caching will not occur, "
"including normal profile."
msgstr ""
"1. No guardar cambios a disco (configNoSave/--spl-confignosave): todos los "
"perfiles (incluyendo los perfiles de emisión) se cargarán desde disco, pero "
"sus cambios no se guardarán. Con este indicador activado, la conservación de "
"perfiles no ocurrirá, incluso para el perfil normal."

#: ..\python_docs\spladdoninternals.py:144
msgid ""
"2. Load normal profile only (normalProfileOnly/--spl-confignormalonly): "
"broadcast profiles will not be used, including ability to create new "
"profiles and using time-based profile switching (see time-based profiles "
"section for details). Combining this with configIsVolatile flag effectively "
"makes normal profile a read-only config store."
msgstr ""
"2. Cargar solamente el perfil normal (normalProfileOnly/--spl-"
"confignormalonly): no se usarán perfiles de emisión, desactivando incluso la "
"capacidad de crear nuevos perfiles y usar cambios de perfil basados en "
"tiempo (mira la sección de perfiles basados en tiempo para más detalles). "
"Combinando este indicador con configIsVolatile, el perfil normal se "
"convierte de forma efectiva en un almacén de configuración de sólo lectura."

#: ..\python_docs\spladdoninternals.py:145
msgid ""
"3. Use in-memory config (configInMemory/--spl-configinmemory): only normal "
"profile will be used, but instead of loading settings from disk, an in-"
"memory version with default settings applied will be used with no caching at "
"all."
msgstr ""
"3. Usar configuración en memoria (configInMemory/--spl-configinmemory): sólo "
"se usará el perfil normal, pero en lugar de cargar los ajustes desde disco, "
"se usará una versión en memoria con los ajustes por defecto aplicados y la "
"conservación no funcionará del todo."

#: ..\python_docs\spladdoninternals.py:146
msgid ""
"Using flags that specify the use of normal profile only will restrict "
"ability to create new broadcast profiles."
msgstr ""
"Usar indicadores que especifiquen la utilización solamente del perfil normal "
"restringirá la habilidad de crear nuevos perfiles de emisión."

#: ..\python_docs\spladdoninternals.py:147
msgid ""
"#### Changes introduced in 18.07 to handle add-on settings from apps other "
"than Studio"
msgstr ""
"#### Cambios introducidos en 18.07 para procesar opciones del complemento "
"desde aplicaciones distintas a Studio"

#: ..\python_docs\spladdoninternals.py:148
msgid ""
"Because Columns Explorer (see the corresponding section below) is used in "
"Studio, Creator and Track Tool, it became necessary to change how add-on "
"settings are loaded and managed outside of Studio. Instead of splconfig."
"initialize calling SPLConfig constructor directly, it will call splconfig."
"openConfig function that will call the constructor (if needed) and add the "
"app name to a list of active SPL components. If this is done with add-on "
"settings already loaded, no construction activity will take place."
msgstr ""
"Como el explorador de columnas se usa en Studio, Creator y la herramienta de "
"pista (lee la sección correspondiente a continuación), se hizo necesario "
"cambiar la forma de cargar y gestionar la configuración del complemento "
"fuera de Studio. En vez de llamar directamente al constructor de SPLConfig "
"en splconfig.initialize, se llama a la función splconfig.openConfig, que "
"llamará al constructor (si es necesario) y añadirá el nombre de la "
"aplicación a una lista de componentes de SPL. Si esto se hace con los "
"ajustes del complemento ya cargados, no tendrá lugar ninguna actividad de "
"construcción."

#: ..\python_docs\spladdoninternals.py:149
msgid ""
"In app modules for Creator and Track Tool, the constructor will call "
"splconfig.openConfig to perform the above activity. When the app module "
"terminates (see below), splconfig.closeConfig will be called to unregister "
"the component that is being terminated, and if no SPL components are active, "
"add-on settings will be gone from memory."
msgstr ""
"En los módulos de aplicación de Creator y la herramienta de pista, el "
"constructor llamará a splconfig.openConfig para realizar la actividad "
"explicada arriba. Cuando el módulo de aplicación finaliza (mira más abajo), "
"se llamará a splconfig.closeConfig para eliminar del registro el componente "
"que finaliza, y si no hay componentes de SPL activos, las opciones del "
"complemento se irán de la memoria."

#: ..\python_docs\spladdoninternals.py:150
msgid "### Life of the app module: events, commands and output"
msgstr "### Vida del módulo de aplicación: eventos, órdenes y salida"

#: ..\python_docs\spladdoninternals.py:151
msgid ""
"Once the Studio app module is ready, you can then move to Studio window and "
"perform activities such as:"
msgstr ""
"Una vez el módulo de Studio está listo, puedes moverte a la ventana de "
"Studio y realizar actividades como estas:"

#: ..\python_docs\spladdoninternals.py:152
msgid ""
"* Press commands, and NVDA will respond by either opening a dialog or "
"speaking what it did."
msgstr ""
"* Pulsar órdenes, y NVDA responderá abriendo un diálogo o bien diciendo lo "
"que ha hecho."

#: ..\python_docs\spladdoninternals.py:153
msgid ""
"* Announce status changes such as microphone status. The length and format "
"of these messages (and other add-on messages) are controlled by message "
"verbosity flag (in case verbosity is set to advanced, NVDA will shorten "
"these announcements, which comes from a messages pool). A special case is "
"announcing artist and title of the currently playing track automatically, "
"for which object navigation is employed. This is necessary due to a broken "
"option in Studio itself."
msgstr ""
"* Verbalizar cambios de estado, como estado del micrófono. La longitud y "
"formato de estos mensajes (y otros mensajes del complemento) están "
"controlados por el indicador de verbosidad de mensajes (en el caso de que la "
"verbosidad se establezca en avanzada, NVDA acortará estos anuncios, que "
"vienen de un contenedor de mensajes). Un caso especial es la verbalización "
"automática de título y artista de la pista que se está reproduciendo "
"actualmente, para el que se emplea navegación por objetos. Esto es necesario "
"por culpa de una opción rota en el propio Studio."

#: ..\python_docs\spladdoninternals.py:154
msgid "* Find tracks."
msgstr "* Buscar pistas."

#: ..\python_docs\spladdoninternals.py:155
msgid ""
"* Examine information in columns via Track Dial and/or Columns Explorer "
"(Track Dial was deprecated in 2017)."
msgstr ""
"* Examinar la información en columnas mediante el dial de pista y / o el "
"explorador de columnas (el dial de pista quedó obsoleto en 2017)."

#: ..\python_docs\spladdoninternals.py:156
msgid "* Listen to progress of a library scan in the background."
msgstr ""
"* Escuchar el progreso de escaneado de una biblioteca en segundo plano."

#: ..\python_docs\spladdoninternals.py:157
msgid "* Perform SPL Assistant gestures."
msgstr "* Realizar gestos del asistente de SPL."

#: ..\python_docs\spladdoninternals.py:158
msgid ""
"* For 6.0 and later, manage broadcast profiles (we'll talk about broadcast "
"profiles in configuration management section)."
msgstr ""
"* Para 6.0 y posteriores, gestionar perfiles de emisión (hablaremos de los "
"perfiles de emisión en la sección de gestión de la configuración)."

#: ..\python_docs\spladdoninternals.py:159
msgid ""
"* For 17.12 and later, respond to actions such as broadcast profile switches."
msgstr ""
"* Para 17.12 y posteriores, responder ante acciones como cambios de perfil "
"de emisión."

#: ..\python_docs\spladdoninternals.py:160
msgid "For Creator and Track Tool, it will let you review column data."
msgstr ""
"En Creator y la herramienta de pista, te permitirá revisar los datos de una "
"columna."

#: ..\python_docs\spladdoninternals.py:161
msgid "#### Extension points"
msgstr "#### Puntos de extensión"

#: ..\python_docs\spladdoninternals.py:162
msgid ""
"Introduced in NVDA 2017.4, an extension point is a notification system from "
"NVDA that tells modules and functions to perform tasks when something "
"happens. For example, the braille subsystem will load a different braille "
"display if different configuration profiles specify this change, or a speech "
"synthesizer can filter certain text from spoken messages before announcing "
"it to users."
msgstr ""
"Introducido en NVDA 2017.4, un punto de extensión es un sistema de "
"notificaciones de NVDA que dice a los módulos y funciones que realicen "
"tareas cuando algo ocurra. Por ejemplo, el subsistema braille cargará una "
"pantalla braille diferente si los perfiles de configuración especifican este "
"cambio, o un sintetizador de voz puede filtrar cierto texto de los mensajes "
"hablados antes de verbalizarlos a los usuarios."

#: ..\python_docs\spladdoninternals.py:163
msgid "There are three extension point types:"
msgstr "Hay tres tipos de puntos de extensión:"

#: ..\python_docs\spladdoninternals.py:164
msgid ""
"* Action: a function can wait for something to happen, such as change of "
"profiles, loading and saving settings and others, and act accordingly once "
"an action takes place."
msgstr ""
"* Acción: una función puede esperar a que ocurra algo, como un cambio de "
"perfiles, que se cargue o guarde la configuración y otros, y actuar en "
"consecuencia cuando una de estas acciones tiene lugar."

#: ..\python_docs\spladdoninternals.py:165
msgid ""
"* Decider: A data processor inside a script or a function can tell NVDA to "
"continue processing data, such as passing a keystroke to remote system."
msgstr ""
"* Decisión: un procesador de datos dentro de un script o una función puede "
"decirle a NVDA que continúe procesando datos, tales como enviar una "
"pulsación de teclas a un sistema remoto."

#: ..\python_docs\spladdoninternals.py:166
msgid ""
"* Filter: a speech processor can add, change, or remove texts before letting "
"synthesizers announce the would-be spoken text."
msgstr ""
"* Filtro: un procesador de voz puede añadir, cambiar o eliminar textos antes "
"de dejar que los sintetizadores verbalicen el texto que debería ser "
"verbalizado."

#: ..\python_docs\spladdoninternals.py:167
msgid ""
"In Studio add-on, actions are used to notify modules of some action such as "
"when Studio exits, broadcast profile switches and so on. There are two "
"actions defined (in splactions module):"
msgstr ""
"En el complemento de Studio, las acciones se usan para notificar a los "
"módulos de alguna acción, como cuando salimos de Studio, cambia el perfil de "
"emisión y así sucesivamente. Hay dos acciones definidas (en el módulo "
"splactions):"

#: ..\python_docs\spladdoninternals.py:168
msgid ""
"* Broadcast profile switch: notifies microphone alarm thread and metadata "
"streaming configuration to switch streams or turn off the alarm (see below "
"for details)."
msgstr ""
"* Cambio de perfil de emisión: notifica al hilo de alarma del micrófono y a "
"la configuración del flujo de metadatos para que cambie los flujos o apague "
"la alarma (mira más abajo para más detalles)."

#: ..\python_docs\spladdoninternals.py:169
msgid ""
"* Studio exiting: tells add-on dialogs to close without saving settings."
msgstr ""
"* Saliendo de Studio: indica a los diálogos del complemento que se cierren "
"sin guardar los ajustes."

#: ..\python_docs\spladdoninternals.py:170
msgid "### Death: termination routines"
msgstr "### Muerte: procedimientos de finalización"

#: ..\python_docs\spladdoninternals.py:171
msgid ""
"While using Studio add-on, you can stop using the add-on in various ways, "
"including exiting or restarting NVDA, turning off your computer or logging "
"off or closing Studio or other SPL app. Just like initialization routines, "
"the Studio app module has specific directions to follow when add-on is "
"closed."
msgstr ""
"Mientras se usa el complemento de Studio, puedes dejar de usar este "
"complemento de varias maneras, que incluyen salir o reiniciar NVDA, apagar "
"tu ordenador o cerrar sesión, o cerrar Studio o una de sus aplicaciones "
"relacionadas. Al igual que pasa con los procedimientos de inicialización, el "
"módulo de aplicación de Studio tiene instrucciones que seguir cuando el "
"complemento se cierra."

#: ..\python_docs\spladdoninternals.py:172
msgid ""
"Here is a list of steps Studio app module performs when it is about to leave "
"this world:"
msgstr ""
"Aquí hay una lista de pasos que sigue el módulo de aplicación de Studio "
"cuando está a punto de abandonar este mundo:"

#: ..\python_docs\spladdoninternals.py:173
msgid ""
"1. The \"terminate\" method is called. Just like the startup (constructor) "
"routine, this method first calls the terminate method defined in the default "
"app module, which closes handles and performs other closing routines."
msgstr ""
"1. Se llama al método \"terminate\". Al igual que el procedimiento de "
"inicialización (constructor), este método primero llama al método terminate "
"definido en el módulo de aplicación por defecto, que cierra manejadores y "
"realiza otros procedimientos de cierre."

#: ..\python_docs\spladdoninternals.py:174
msgid ""
"2. Calls splconfig.terminate() function to save add-on settings and perform "
"shutdown routines for some features. This function goes through following "
"steps in add-on 7.0:"
msgstr ""
"2. Se llama a la función splconfig.terminate() para guardar los ajustes del "
"complemento y realizar tareas de apagado de algunas características. Esta "
"función sigue los siguientes pasos en el complemento 7.0:"

#: ..\python_docs\spladdoninternals.py:175
msgid ""
"\t1. In add-on 7.0, if update check timer is running, the timer is told to "
"stop, and update metadata is copied back to normal profile."
msgstr ""
"\t1. En el complemento 7.0, si el temporizador de búsqueda de "
"actualizaciones está funcionando, recibe la orden de detenerse, y se copian "
"los metadatos de actualización de vuelta en el perfil normal."

#: ..\python_docs\spladdoninternals.py:176
msgid ""
"\t2. Starting with add-on 18.07, active SPL component is unregistered via "
"splconfig.closeConfig function. If there are other components running, the "
"below steps will not occur, otherwise add-on settings will be closed."
msgstr ""
"\t2. Empezando con el complemento 18.07, se elimina el componente activo del "
"registro mediante la función splconfig.closeConfig. Si hay otros componentes "
"en ejecución, los siguientes pasos no ocurrirán, y en cualquier otro caso "
"las opciones del complemento se cerrarán."

#: ..\python_docs\spladdoninternals.py:177
msgid ""
"\t3. Unless disabled through flags in 17.10, profiles are saved (beginning "
"with normal profile) to disk if and only if profile-specific settings were "
"changed (an online cache used for storing profile settings when they are "
"loaded is kept for this purpose). This step will not occur if an in-memory "
"version of normal profile is in use or other SPL components are active."
msgstr ""
"\t3. A menos que se desactive con indicadores en 17.10, se guardan los "
"perfiles (empezando con el perfil normal) en disco si y sólo si se cambian "
"ajustes específicos del perfil (con este propósito se conserva una caché en "
"línea usada para almacenar ajustes de los perfiles cuando estos se cargan). "
"Este paso no ocurrirá si está en uso una versión en memoria del perfil "
"normal o hay otros componentes de SPL activos."

#: ..\python_docs\spladdoninternals.py:178
msgid ""
"\t4. If there is an instant switch profile defined, this is recorded in the "
"normal profile, otherwise it is removed from the profile database."
msgstr ""
"\t4. Si hay un perfil de cambio instantáneo definido, este se registra en el "
"perfil normal, de cualquier otro modo se elimina de la base de datos de "
"perfiles."

#: ..\python_docs\spladdoninternals.py:179
msgid ""
"\t5. Once all profiles are saved, various flags, active profile and config "
"pool is cleared."
msgstr ""
"\t5. Una vez se guardan todos los perfiles, se limpian diversos indicadores, "
"el perfil activo y el contenedor de configuración."

#: ..\python_docs\spladdoninternals.py:180
msgid ""
"\t6. For add-on 5.x and earlier, there is only one broadcast profile to "
"worry about, and this profile is saved at this point."
msgstr ""
"\t6. Para el complemento 5.x y anteriores, hay sólo un perfil de emisión del "
"que preocuparse, y este perfil se guarda en este punto."

#: ..\python_docs\spladdoninternals.py:181
msgid ""
"\t7. These steps are part of splconfig.SPLConfig.save method in add-on 8.0 "
"and later."
msgstr ""
"\t7. Estos pasos son parte del método splconfig.SPLConfig.save en el "
"complemento 8.0 y posteriores."

#: ..\python_docs\spladdoninternals.py:182
msgid ""
"3. In 17.12 and later, NVDA notifies registered handlers for app terminate "
"action. As noted above, this will cause add-on dialogs to close without "
"saving settings."
msgstr ""
"3. En 17.12 y posteriores, NVDA notifica a los manejadores registrados la "
"acción de finalización de aplicación. Como se explica arriba, esto causará "
"que los diálogos del complemento se cierren sin guardar los ajustes."

#: ..\python_docs\spladdoninternals.py:183
msgid ""
"4. NVDA then attempts to remove SPL Studio Settings entry from NVDA's "
"preferences menu, then various maps used by Studio add-on (such as Cart "
"Explorer map) are cleared."
msgstr ""
"4. A continuación NVDA intenta eliminar la entrada de ajustes de SPL Studio "
"del menú de preferencias de NVDA, después se limpian diversos mapas usados "
"por el complemento de Studio (como el mapa del explorador cart)."

#: ..\python_docs\spladdoninternals.py:184
msgid ""
"5. As the app module is laid to rest, the window handle value for Studio "
"window is cleared. This is a must, as the handle will be different next time "
"Studio runs. At this point, NVDA removes splstudio (Studio app module) from "
"list of app modules in use."
msgstr ""
"5. Como el módulo de aplicación se sienta a descansar, el valor del "
"manejador de ventana para la ventana de Studio se limpia. Esto es "
"obligatorio, ya que el manejador será diferente la próxima vez que se inicie "
"Studio. En este punto, NVDA elimina splstudio (el móodulo de aplicación de "
"Studio) de la lista de módulos de aplicación en uso."

#: ..\python_docs\spladdoninternals.py:185
msgid "### Add-on updates: updating to latest and greatest version"
msgstr ""
"### Actualizaciones del complemento: actualizar a la última y más fantástica "
"versión"

#: ..\python_docs\spladdoninternals.py:186
msgid ""
"Note: this feature is being transfered from Studio add-on to other modules. "
"This section will discuss standalone update method (checking for Studio add-"
"on update from Studio window)."
msgstr ""

#: ..\python_docs\spladdoninternals.py:187
msgid ""
"In add-on 7.0 and later, it is possible to update to the latest version of "
"the add-on by using add-on update check facility. This is done by connecting "
"to a server where the update add-on files are stored."
msgstr ""
"En el complemento 7.0 y posteriores, es posible actualizar a la última "
"versión del complemento usando la característica de comprobación de "
"actualizaciones del complemento. Esto se hace conectando a un servidor donde "
"se alojan los archivos de actualización del complemento."

#: ..\python_docs\spladdoninternals.py:188
#, fuzzy
#| msgid ""
#| "The Studio add-on uses a combination of urllib library and development "
#| "branches (explained later) to fetch the needed update metadata. The user "
#| "can tell the add-on to check for updates automatically or one can perform "
#| "this check manually."
msgid ""
"The Studio add-on uses a combination of urllib library and update channels "
"(explained later) to fetch the needed update metadata. The user can tell the "
"add-on to check for updates automatically or one can perform this check "
"manually."
msgstr ""
"El complemento de Studio usa una combinación de la biblioteca urllib y ramas "
"de desarrollo (explicadas más tarde) para recuperar los metadatos necesarios "
"de actualización. El usuario puede decirle al complemento que busque "
"actualizaciones automáticamente o puede comprobarlas de forma manual."

#: ..\python_docs\spladdoninternals.py:189
msgid "The update check is performed as follows:"
msgstr "La búsqueda de actualizaciones se hace de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:190
msgid ""
"1. If the add-on is told to check for updates, the Studio app module "
"constructor will start a timer whose purpose is to call a function when it "
"is time to check for an update."
msgstr ""
"1. Si le decimos al complemento que busque actualizaciones, el constructor "
"del módulo de aplicación de Studio iniciará un temporizador cuyo propósito "
"es llamar a una función cuando sea hora de buscar una actualización."

#: ..\python_docs\spladdoninternals.py:191
msgid ""
"2. If automatic update check is enabled, the update manager (splconfig."
"updateInit) will determine when the update was checked last. This is done in "
"order to perform update checks every 24 hours."
msgstr ""
"2. Si está activada la búsqueda automática de actualizaciones, el gestor de "
"actualizaciones (splconfig.updateInit) determinará cuando fue la última vez "
"que se buscaron actualizaciones. Esto se hace para realizar búsquedas de "
"actualizaciones cada 24 horas."

#: ..\python_docs\spladdoninternals.py:192
msgid ""
"3. Once the timer kicks in (automatic update check is on), the update check "
"function (splupdate.updateChecker) will be called. This function uses two "
"parameters to determine if a status progress tone should be played and to "
"schedule the next update check."
msgstr ""
"3. Una vez el temporizador llega a su fin (con la búsqueda automática de "
"actualizaciones activada), se llamará a la función de búsqueda de "
"actualizaciones (splupdate.updateChecker). Esta función usa dos parámetros "
"para determinar si debería reproducirse un tono de estado de progreso y para "
"programar la próxima búsqueda de actualizaciones."

#: ..\python_docs\spladdoninternals.py:193
#, fuzzy
#| msgid ""
#| "4. The update check function first connects to the URL for the current "
#| "development branch (more on branches at the end of this article) and "
#| "compares the filename returned by the server. If the file names does not "
#| "match, the add-on will interpret this as presence of an update and will "
#| "return a dictionary containing current add-on version, new version "
#| "(parsed as a regular expression) and URL for the file, and if not, it "
#| "returns nothing."
msgid ""
"4. The update check function first connects to the URL for the current "
"update channel (more on channels at the end of this article) and compares "
"the filename returned by the server. If the file names does not match, the "
"add-on will interpret this as presence of an update and will return a "
"dictionary containing current add-on version, new version (parsed as a "
"regular expression) and URL for the file, and if not, it returns nothing."
msgstr ""
"4. La función de búsqueda de actualizaciones primero se conecta a la URL de "
"la rama actual de desarrollo (más sobre ramas al final de este artículo) y "
"compara el nombre de archivo devuelto por el servidor. Si los nombres de "
"archivo no encajan, el complemento interpretará esto como que hay una "
"actualización disponible y devolverá un diccionario que contiene la versión "
"actual del complemento, la nueva versión (extraída de una expresión regular) "
"y la URL del archivo, y si no, no devuelve nada."

#: ..\python_docs\spladdoninternals.py:194
msgid ""
"5. If a new version is available and if the user said \"yes\" to update "
"prompt, the update metadata (update timestamp) will be cached to be "
"retrieved by the app module later."
msgstr ""
"5. Si hay una nueva versión disponible y el usuario ha dicho \"Sí\" a la "
"pregunta de actualización, los metadatos de la actualización (sello de "
"actualización) se guardarán para que el módulo de aplicación los consulte "
"más tarde."

#: ..\python_docs\spladdoninternals.py:195
msgid ""
"6. This process repeats if automatic check is enabled (a timer will be set "
"to call this function again after 24 hours)."
msgstr ""
"6. Este proceso se repetirá si la búsqueda automática está activada (se "
"creará un temporizador para llamar otra vez a esta función en 24 horas)."

#: ..\python_docs\spladdoninternals.py:196
msgid ""
"In case of a manual update check (described in SPL Assistant layer section), "
"apart from not using a timer and stopping an update check timer temporarily "
"(if needed), it will go through steps 3 through 5 from above."
msgstr ""
"En el caso de una búsqueda manual de actualizaciones (descrita en la sección "
"de la capa del asistente de SPL), aparte de no usarse un temporizador y "
"detener el temporizador de búsqueda de actualizaciones automática "
"temporalmente (si es necesario), se harán los pasos del 3 al 5 explicados "
"arriba."

#: ..\python_docs\spladdoninternals.py:197
msgid "## Time announcements, alarms and adjusting basic settings"
msgstr "## Anuncios de tiempo, alarmas y modificación de ajustes básicos"

#: ..\python_docs\spladdoninternals.py:198
msgid ""
"Now that we know how Studio app module is born and dies, it is time for us "
"to look at what happens while the Studio add-on is alive, and we'll start "
"with how Studio add-on announces time, work with alarms and uses basic "
"settings."
msgstr ""
"Ahora que sabemos cómo nace y muere el módulo de aplicación de Studio, es el "
"momento para que miremos qué pasa mientras el complemento de Studio está "
"vivo, y empezaremos por ver cómo anuncia la hora el complemento de Studio, "
"cómo trabaja con las alarmas y usa ajustes básicos."

#: ..\python_docs\spladdoninternals.py:199
msgid "### Time announcement routines: a tale of four brothers"
msgstr ""
"### Procedimientos de anunciado de tiempo: un cuento de cuatro hermanos"

#: ..\python_docs\spladdoninternals.py:200
msgid ""
"SPL Studio app module for NVDA comes with four time announcement commands. "
"These are elapsed time, remaining time, broadcaster time and complete time "
"including seconds. The first two uses Studio API to obtain needed "
"information, while others use a combination of Python routines and Windows "
"API functions."
msgstr ""
"El módulo de aplicación de SPL Studio para NVDA viene con cuatro órdenes de "
"verbalización de tiempo. Estas son tiempo transcurrido, tiempo restante, "
"hora del locutor y hora completa incluyendo segundos. Los dos primeros usan "
"la api de Studio para obtener la información necesaria, mientras que los "
"otros usan una combinación de procedimientos Python y funciones de la api de "
"Windows."

#: ..\python_docs\spladdoninternals.py:201
msgid ""
"Three of these routines are assigned to commands (sometimes termed "
"gestures). These are:"
msgstr ""
"Tres de estos procedimientos tienen órdenes asignadas (a veces llamadas "
"gestos). Estas son:"

#: ..\python_docs\spladdoninternals.py:202
msgid "* Control+Alt+T: Remaining time"
msgstr "* Ctrl+alt+t: tiempo restante"

#: ..\python_docs\spladdoninternals.py:203
msgid "* Alt+Shift+T: Elapsed time"
msgstr "* Alt+shift+t: tiempo transcurrido"

#: ..\python_docs\spladdoninternals.py:204
msgid "* NVDA+Shift+F12: Broadcaster time"
msgstr "* NVDA+shift+f12: tiempo del locutor"

#: ..\python_docs\spladdoninternals.py:205
msgid ""
"One can then use Input Gestures dialog (part of NVDA screen reader) to "
"change them or assign a command to complete time routine."
msgstr ""
"Se puede usar el diálogo de gestos de entrada (parte del lector de pantalla "
"NVDA) para cambiarlas o asignar una orden a la función de hora completa."

#: ..\python_docs\spladdoninternals.py:206
msgid ""
"### A step sideways with studioAPI function: A central Studio API handler "
"and dispatcher"
msgstr ""
"### Un paso a un lado con la función StudioApi: un manejador y procesador "
"central de la api de Studio"

#: ..\python_docs\spladdoninternals.py:207
msgid ""
"Before going any further, it is important to mention a function that not "
"only is used by the first two time routines, but also comes in handy in SPL "
"Assistant and other methods. This function, called studioAPI (part of the "
"main app module and defined as a module-level function), sends messages to "
"Studio window and retrieves the value returned. The signature is:"
msgstr ""
"Antes de continuar, es importante mencionar una función que no sólo usan los "
"dos primeros procedimientos de tiempo, sino que también es útil en el "
"asistente de SPL y otros métodos. Esta función, llamada studioAPI (parte del "
"módulo de aplicación principal y definida como una función a nivel de "
"módulo), envía mensajes a la ventana de Studio y recupera el valor devuelto. "
"Su cabecera es:"

#: ..\python_docs\spladdoninternals.py:208
msgid "\tstudioAPI(arg, command)"
msgstr "\tstudioAPI(arg, command)"

#: ..\python_docs\spladdoninternals.py:209
msgid ""
"With the arguments being the message to be sent to studio window (arg and "
"command). At first glance, it may seem similar to user32's SendMessage "
"function (in fact, that's what the studioAPI function will call), but unlike "
"a typical SendMessage function routine, the Studio handle and message type "
"is automatically filled in, hence only argument (WParem) and command "
"(LParem) are needed."
msgstr ""
"Siendo los argumentos el mensaje que se envía a la ventana de Studio (arg y "
"command). A primera vista, puede parecer similar a la función SendMessage de "
"user32 (de hecho, es a la que llamará la función studioAPI), pero a "
"diferencia del procedimiento típico de la función SendMessage, el manejador "
"de Studio y el tipo de mensaje se rellenan automáticamente, por lo que sólo "
"el argumento (WParam) y la orden (LParam) son necesarios."

#: ..\python_docs\spladdoninternals.py:210
msgid ""
"In older versions of the add-on, studioAPI did more than return results. It "
"called a callback with or without an offset, as well as not return anything. "
"However, the only callback passed in was time announcer (next section), thus "
"in 2018, studioAPI function has been relegated to a thin wrapper around "
"SendMessage function with Studio window handle and message typed filled in."
msgstr ""
"En versiones más antiguas del complemento, studioAPI hacía más que devolver "
"resultados. Llamaba a una función de retorno con o sin desplazamiento, o no "
"devolvía nada. Sin embargo, la única función de retorno que se le pasaba era "
"la de verbalización de tiempo (próxima sección), y por lo tanto en 2018, la "
"función studioAPI ha sido relegada a una delgada envoltura alrededor de la "
"función SendMessage con el manejador de la ventana de Studio y el tipo de "
"mensaje rellenados."

#: ..\python_docs\spladdoninternals.py:211
msgid ""
"### First applications of studioAPI function: Announcing elapsed and "
"remaining times"
msgstr ""
"### Primeras aplicaciones de la función studioAPI: verbalización de tiempo "
"transcurrido y restante"

#: ..\python_docs\spladdoninternals.py:212
msgid ""
"When you press Control+Alt+T or Alt+Shift+T to hear remaining or elapsed "
"time, the script will first check if you are in the main Playlist Viewer, "
"and if so, will call studioAPI function with correct arguments and commands, "
"the result then being fed to announceTime function. In fact, the only "
"differences are argument that is used and the error message."
msgstr ""
"Cuando pulses ctrl+alt+t o alt+shift+t para escuchar el tiempo transcurrido "
"o el restante, el script primero comprobará si estás en el visor principal "
"de listas de reproducción, y si es así, llamará a la función studioAPI con "
"los argumentos correctos y órdenes, devolviendo el resultado a la función "
"announceTime. De hecho, las únicas diferencias son el argumento que se usa y "
"el mensaje de error."

#: ..\python_docs\spladdoninternals.py:213
msgid "### Broadcaster time: Simulating Studio's broadcaster clock"
msgstr "### Hora del locutor: simulando el reloj del locutor de Studio"

#: ..\python_docs\spladdoninternals.py:214
msgid ""
"When you listen to radio shows, you may hear messages such as, \"five "
"minutes to two\" or \"ten minutes past five\". This announcement is called "
"broadcaster time."
msgstr ""
"Cuando escuchas programas de radio, puedes oír mensajes como, \"Cinco "
"minutos para las dos\" o \"Son las cinco y diez\". Este anuncio se llama "
"hora del locutor."

#: ..\python_docs\spladdoninternals.py:215
msgid ""
"Studio does display broadcaster clock. However, because it is in the middle "
"of the screen, one has to use object navigation commands to locate it, and "
"this method was used in older Studio add-on releases. This involved locating "
"the foreground window (api.getForegroundObject()) and navigating through a "
"preset direction to arrive at the clock object, and this is still used in "
"some places. However, this was prone to a critical problem: sometimes, the "
"object we're interested in changed positions (a good example was when "
"different builds of Studio 5.10 were released)."
msgstr ""
"Studio muestra el reloj del locutor. Sin embargo, como está en medio de la "
"pantalla, hay que usar órdenes de navegación de objetos para ubicarlo, y "
"esto se hacía en versiones antiguas del complemento de Studio. Esto "
"implicaba ubicar la ventana en primer plano (api.getForegroundObject()) y "
"navegar en una dirección prestablecida para llegar al objeto del reloj, y "
"esto todavía se usa en algunos lugares. Sin embargo, esto era propenso a un "
"problema crítico: en ocasiones, el objeto en el que estamos interesados "
"cambiaba su posición (un buen ejemplo era cuando se publicaban diferentes "
"versiones de Studio 5.10)."

#: ..\python_docs\spladdoninternals.py:216
msgid ""
"Recently, this method was abandoned in favor of using Python's time module "
"to obtain current time and convert it into a format that is familiar to "
"broadcasters, thus removing the need to use object navigation. When you "
"press NVDA+Shift+F12, NVDA first fetches local time (time.localtime), then "
"converts this into a format suitable for output. Along the way NVDA tries to "
"emulate how Studio displays broadcaster clock. Recently, a slight "
"modification was made so this process can be used to obtain time left to top "
"of the hour when NVDA+Shift+F12 is pressed twice, with the difference being "
"subtracting local time from top of the next hour. When processing is "
"completefor both cases, NVDA announces the output text."
msgstr ""
"Recientemente, este método se ha abandonado en favor del uso del módulo time "
"de Python para obtener la hora actual y convertirla a un formato que sea "
"familiar para los locutores, por lo tanto eliminando la necesidad de usar "
"navegación por objetos. Cuando pulsas NVDA+shift+f12, NVDA primero recupera "
"la hora local (time.localtime), después la convierte a un formato adecuado "
"para la salida. A lo largo del camino, NVDA intenta emular cómo muestra "
"Studio el reloj del locutor. Recientemente se ha hecho una ligera "
"modificación para que este proceso pueda usarse para obtener el tiempo "
"restante hasta la hora en punto cuando NVDA+shift+f12 se pulsa dos veces, "
"con la diferencia de que la hora local se extrae de la siguiente hora. "
"Cuando el proceso se completa para ambos casos, NVDA verbaliza el texto de "
"salida."

#: ..\python_docs\spladdoninternals.py:217
msgid "### Complete time: Windows API to the rescue"
msgstr "### Hora completa: la api de Windows al rescate"

#: ..\python_docs\spladdoninternals.py:218
msgid ""
"Here, complete time refers to time including seconds. Normally, when you "
"press NVDA+F12, NVDA excludes seconds when announcing time. All that is "
"needed to announce seconds is to change the format argument for kernel32."
"dll's GetTimeFormat function. With this change, NVDA can announce time "
"including seconds, but in order to use it, you need to assign a command to "
"this feature (some app module commands are not assigned by default)."
msgstr ""
"Aquí, hora completa se refiere a la hora incluyendo los segundos. "
"Normalmente, cuando pulsas NVDA+f12, NVDA excluye los segundos al verbalizar "
"la hora. Lo único que hace falta para verbalizar los segundos es cambiar el "
"argumento de formato en la función GetTimeFormat de kernel32.dll. Con este "
"cambio, NVDA puede verbalizar la hora incluyendo segundos, pero para usarla, "
"debes asignar una orden para esta función (algunas órdenes del módulo de "
"aplicación no vienen asignadas por defecto)."

#: ..\python_docs\spladdoninternals.py:219
msgid "### Setting alarms"
msgstr "### Establecimiento de alarmas"

#: ..\python_docs\spladdoninternals.py:220
msgid ""
"Studio app module comes with three alarms: song outro (ending), intro and "
"microphone active alarm. Because we need to talk about some important things "
"when talking about microphone alarm, we'll just tour the routine used when "
"setting up the intro and outro alarms."
msgstr ""
"El módulo de aplicación de Studio viene con tres alarmas: fin de canción, "
"introducción y alarma de micrófono activo. Ya que tenemos que hablar de "
"cosas importantes al explicar la alarma del micrófono, recorreremos el "
"procedimiento usado al establecer las alarmas de introducción y fin."

#: ..\python_docs\spladdoninternals.py:221
msgid ""
"When you press Alt+NVDA+1 or Alt+NVDA+2 to open end of track or song intro "
"alarm dialogs, the dialog will display two controls:"
msgstr ""
"Cuando pulses NVDA+alt+1 o NVDA+alt+2 para abrir los diálogos de alarma de "
"fin de pista o introducción de canción, el diálogo mostrará dos controles:"

#: ..\python_docs\spladdoninternals.py:222
msgid ""
"* Alarm setting: a spin box (a sping control) is used to adjust alarm "
"values. You can type the alarm value or use up or down arrow to change the "
"value. If an incorrect value is entered, the maximum value (59 for end of "
"track, 9 for song intro) will be used."
msgstr ""
"* Ajuste de alarma: un botón giratorio (un control giratorio) se usa para "
"ajustar los valores de la alarma. Puedes teclear el valor de la alarma o "
"usar flechas arriba y abajo para cambiarlo. Si se introduce un valor "
"incorrecto, se usará el valor máximo (59 para fin de pista, 9 para "
"introducción de canción)."

#: ..\python_docs\spladdoninternals.py:223
msgid "* Notification check box: This sets whether alarm will play or not."
msgstr ""
"* Casilla de verificación de notificación: establece si la alarma se "
"reproducirá o no."

#: ..\python_docs\spladdoninternals.py:224
msgid ""
"In reality, a single dialog (splconfui.AlarmsCenter class) presents these "
"two alarm dialogs (there are two additional dialogs, covered in the next "
"section). The type of dialog to be shown is controled by an integer which "
"denotes which dialog text to present. The process is outlined below:"
msgstr ""
"En realidad, un único diálogo (clase splconfui.AlarmsCenter) presenta estos "
"dos diálogos de alarma (hay dos diálogos adicionales, cubiertos en la "
"próxima sección). El tipo de diálogo a mostrar viene controlado por un "
"entero que indica qué texto presentar en el diálogo. El proceso viene "
"descrito a continuación:"

#: ..\python_docs\spladdoninternals.py:225
msgid ""
"1. Just before the dialog opens, checks if another dialog or the add-on "
"settings dialog is opened, and if so, NVDA will ask you to close the "
"previously opened dialog first."
msgstr ""
"1. Antes de que el diálogo se abra, se comprueba si otro diálogo o el "
"diálogo de configuración del complemento está abierto, y si es así, NVDA te "
"pedirá que cierres el diálogo previamente abierto primero."

#: ..\python_docs\spladdoninternals.py:226
msgid ""
"2. Tells NVDA that an alarm dialog is opened. This is meant to prevent the "
"same dialog from being opened repeatedly."
msgstr ""
"2. Se le dice a NVDA que hay un diálogo de alarma abierto. Esto se hace para "
"evitar que se abra el mismo diálogo repetidamente."

#: ..\python_docs\spladdoninternals.py:227
msgid ""
"3. After the dialog is dismissed (either a new value is set or you click "
"Cancel), NVDA clears the alarm opened flag, thereby letting other dialogs to "
"be shown. "
msgstr ""
"3. Después de cerrar el diálogo (bien porque se establece un nuevo valor o "
"se pulsa en cancelar), NVDA limpia el indicador de alarma abierta, "
"permitiendo que otros diálogos se muestren. "

#: ..\python_docs\spladdoninternals.py:228
msgid ""
"We'll learn how the alarm values are stored and retrieved in the "
"configuration management section, and you'll get to meet how intro and outro "
"alarms work in the next chapter."
msgstr ""
"Aprenderemos cómo se almacenan y recuperan los valores de la alarma en la "
"sección de gestión de configuración, y sabrás cómo funcionan las alarmas de "
"introducción y fin de pista en el próoximo capítulo."

#: ..\python_docs\spladdoninternals.py:229
msgid "#### Alarms Center"
msgstr "#### Centro de alarmas"

#: ..\python_docs\spladdoninternals.py:230
msgid ""
"This single dialog that presents different alarm controls is known as "
"'Alarms Center\". In fact, not only this dialog houses end of track and "
"track intro alarms, it includes microphone alarm controls, and all that's "
"needed to change its appearance is a single integer that specifies which "
"portion of the dialog should be shown. In case of Alarms Center dialog "
"presented from add-on settings (see a later chapter on add-on "
"configuration), all alarm controls will be shown (level = 0), with different "
"levels controlling what controls should be shown as follows:"
msgstr ""
"Este diálogo único que presenta diferentes controles de alarma se conoce "
"como 'Centro de alarmas'. De hecho, este diálogo no sólo aloja la alarma de "
"fin de pista y la de introducción, sino también los controles de la alarma "
"del micrófono, y todo lo que se necesita para modificar su aspecto es un "
"único entero que especifica qué parte del diálogo debería mostrarse. En el "
"caso del diálogo del centro de alarmas presentado desde los ajustes del "
"complemento (mira el capítulo de la configuración del complemento), se "
"mostrarán todos los controles de alarma (level=0), con diferentes niveles "
"controlando qué controles deberían mostrarse de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:231
msgid "* 0: Alarms Center, displays all controls."
msgstr "* 0: centro de alarmas, muestra todos los controles."

#: ..\python_docs\spladdoninternals.py:232
msgid "* 1: End of track alarm."
msgstr "* 1: alarma de fin de pista."

#: ..\python_docs\spladdoninternals.py:233
msgid "* 2: Track intro alarm."
msgstr "* 2: alarma de introducción de pista."

#: ..\python_docs\spladdoninternals.py:234
msgid "* 3: Microphone alarm controls."
msgstr "* 3: controles de la alarma del micrófono."

#: ..\python_docs\spladdoninternals.py:235
msgid "### Toggle settings"
msgstr "### Conmutar ajustes"

#: ..\python_docs\spladdoninternals.py:236
msgid ""
"Studio add-on comes with some toggle settings that affect the operation of "
"the app module. These include status announcements (Control+NVDA+1), library "
"scan announcement (Alt+NVDA+R) and braille timer (Control+Shift+X). For each "
"setting script, NVDA will first check the current value, change the value "
"and announce the new value."
msgstr ""
"El complemento de Studio viene con algunos ajustes conmutables que afectan a "
"la forma de operar del módulo de aplicación. Estos incluyen anuncios de "
"estado (ctrl+NVDA+1), anuncio de escaneo de biblioteca (alt+NVDA+r) y "
"temporizador braille (ctrl+shift+x). Para cada script de configuración, NVDA "
"primero comprobará el valor actual, cambiará el valor y anunciará el nuevo "
"valor."

#: ..\python_docs\spladdoninternals.py:237
msgid ""
"Now you know how the alarm dialogs function, what happenn when you toggle "
"some settings and went through a behind the scenes tour of various time "
"announcement commands. There are other things we need to talk about, and "
"we'll continue our discussion of the Studio app module with how alarms come "
"into play and how status changes are announced."
msgstr ""
"Ahora ya sabes cómo funcionan los diálogos de alarma, qué pasa cuando "
"conmutas algunos ajustes y has recorrido el interior de diversas órdenes de "
"verbalización de tiempo. Hay otras cosas de las que debemos hablar, así que "
"continuaremos nuestra exposición del módulo de aplicación de Studio viendo "
"cómo entran en juego las alarmas y cómo se verbalizan los cambios de estado."

#: ..\python_docs\spladdoninternals.py:238
msgid ""
"## Event handling: announcing status changes, activating alarms and more"
msgstr ""
"## Procesamiento de eventos: verbalización de cambios de estado, activación "
"de alarmas y más"

#: ..\python_docs\spladdoninternals.py:239
msgid ""
"When you are producing a live show, it is important for your screen reader "
"to announce various status changes and happenings such as number of "
"listeners, outro notification, playback status, alerting you of listener "
"requests and so on. NVDA is an expert when it comes to handling status "
"changes, activating alarms and more. In this section, we'll learn the magic "
"behind this expertise: handling events."
msgstr ""
"Cuando produces un programa en vivo, es importante que tu lector de pantalla "
"verbalice diversos cambios de estado y sucesos como número de oyentes, "
"notificación de fin de pista, estado de la reproducción, alertas sobre "
"peticiones de oyentes y demás. NVDA es un experto cuando se trata de manejar "
"cambios de estado, activar alarmas y más. En esta sección, conoceremos la "
"magia que hay tras esta profesionalidad: el procesamiento de eventos."

#: ..\python_docs\spladdoninternals.py:240
msgid "### NVDA is event-driven"
msgstr "### NVDA está dirigido por eventos"

#: ..\python_docs\spladdoninternals.py:241
msgid ""
"Windows applications (especially those using Windows API) are event-driven "
"programs. Somewhere in the application is an event loop that responds to "
"various events, such as when a check box is clicked, computer is shutting "
"down and so on. NVDA, being a Windows screen reader, does use events for "
"various purposes, ranging from announcing new chat notification in Skype to "
"ignoring it completely."
msgstr ""
"Las aplicaciones de Windows (especialmente aquellas que usan la api de "
"Windows) son programas dirigidos por eventos. En algún lugar de la "
"aplicación hay un bucle que responde a diversos eventos, tales como cuando "
"se hace clic en una casilla de verificación, el ordenador se está apagando y "
"demás. NVDA, al ser un lector de pantalla, usa los eventos con diversos "
"propósitos, desde verbalizar una notificación de nuevo chat en Skype hasta "
"ignorarlo completamente."

#: ..\python_docs\spladdoninternals.py:242
msgid ""
"To handle various events, NVDA uses an event queue (queue handler) and an "
"event handler for event processing. When an event is fired by itself or from "
"other programs, NVDA first checks if the given event is worthy of its "
"attention. Then it performs actions associated with the event, such as "
"announcing changes to a control (name, value, etc.), playing beeps and "
"sounds (progress bar updates) and so on. For add-ons (mostly global plugins "
"and app modules), NVDA is eager to listen to certain events and let controls "
"fire events."
msgstr ""
"Para manejar distintos eventos, NVDA usa una cola de eventos (queueHandler) "
"y un manejador de eventos para procesarlos. Cuando un evento se dispara "
"desde NVDA o desde otros programas, NVDA primero comprueba si dicho evento "
"es digno de su atención. A continuación realiza acciones asociadas con el "
"evento, como verbalizar los cambios de un control (nombre, valor, etc.), "
"reproducir pitidos y sonidos (actualizaciones de una barra de progreso) y "
"así sucesivamente. Para los complementos (mayoritariamente extensiones "
"globales y módulos de aplicación), NVDA tiene ganas de escuchar ciertos "
"eventos y dejar que los controles los disparen."

#: ..\python_docs\spladdoninternals.py:243
msgid "Typically, an event handling routine is declared like this:"
msgstr ""
"Normalmente, un procedimiento para manejar un evento se declara de la "
"siguiente manera:"

#: ..\python_docs\spladdoninternals.py:244
msgid "\tevent_eventname(module, object in question, next handler)"
msgstr ""
"\tevent_nombredeevento(módulo, objeto en cuestión, siguiente manejador)"

#: ..\python_docs\spladdoninternals.py:245
msgid ""
"For example, for Studio app module, one event handler declared is gain focus "
"(you have moved to a different control), and is written as follows:"
msgstr ""
"Por ejemplo, para el módulo de aplicación de Studio, un manejador de eventos "
"declarado es gainFocus (te has movido a un control diferente), y está "
"escrito así:"

#: ..\python_docs\spladdoninternals.py:246
msgid "\tevent_gainFocus(self, obj, nextHandler)"
msgstr "\tevent_gainFocus(self, obj, nextHandler)"

#: ..\python_docs\spladdoninternals.py:247
msgid ""
"The routine is just like any other function (callable) except that the "
"routine called nextHandler function at the end to allow other controls to "
"respond to events."
msgstr ""
"El procedimiento es como cualquier otra función (llamable) salvo porque se "
"llama al procedimiento nextHandler al final para permitir a otros controles "
"responder a eventos."

#: ..\python_docs\spladdoninternals.py:248
msgid "### What does events have to do with Studio app module?"
msgstr ""
"### ¿Qué tienen que hacer los eventos con el módulo de aplicación de Studio?"

#: ..\python_docs\spladdoninternals.py:249
msgid ""
"Events and event handlers are crucial to the operation of the Studio app "
"module, described as \"heartbeat\" of the add-on. Events and their handlers "
"are used to perform bulk of the work required to allow the app module to "
"function. These include:"
msgstr ""
"Los eventos y los manejadores de eventos son cruciales en el funcionamiento "
"del módulo de aplicación de Studio, descrita como \"los latidos del corazón"
"\" del complemento. Los eventos y sus manejadores se usan para hacer la "
"mayoría del trabajo necesario para que el módulo de aplicación funcione. "
"Entre ellos se incluyen:"

#: ..\python_docs\spladdoninternals.py:250
msgid ""
"* Announcing status changes such as when microphone is turned on or off."
msgstr ""
"* Verbalización de cambios de estado tales como cuando el micrófono se "
"enciende o se apaga."

#: ..\python_docs\spladdoninternals.py:251
msgid "* Alarm notification, such as when end of intro is approaching."
msgstr ""
"* Notificación de alarma, como la que hay cuando se acerca el final de una "
"pista."

#: ..\python_docs\spladdoninternals.py:252
msgid ""
"* Activating certain announcement and background tasks such as activating "
"microphone alarm, announcing library scan progress and more."
msgstr ""
"* Activación de ciertas verbalizaciones y tareas en segundo plano como la "
"alarma del micrófono, el anunciado del progreso de escaneado de la "
"biblioteca y más."

#: ..\python_docs\spladdoninternals.py:253
msgid ""
"* Perform workarounds for issues such as focus problems when deleting a "
"track."
msgstr ""
"* Aplicar solución a algunos problemas como los que da el foco al eliminar "
"una pista."

#: ..\python_docs\spladdoninternals.py:254
msgid ""
"Of all the event handlers declared, the most important one is name change "
"event. It is declared as follows:"
msgstr ""
"De todos los manejadores de eventos declarados, el más importante es el "
"evento de cambio de nombre. Se declara de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:255
msgid "\tevent_nameChange(self, obj, nextHandler)"
msgstr "\tevent_nameChange(self, obj, nextHandler)"

#: ..\python_docs\spladdoninternals.py:256
msgid "When this event is fired by Studio, NVDA performs following operations:"
msgstr ""
"Cuando Studio dispara este evento, NVDA hace las siguientes operaciones:"

#: ..\python_docs\spladdoninternals.py:257
msgid "1. Various checks are performed. These include, but are not limited to:"
msgstr ""
"1. Se realizan diversas comprobaciones. Estas incluyen, pero no se limitan a:"

#: ..\python_docs\spladdoninternals.py:258
msgid "A. Make sure there is something to announce."
msgstr "A. Asegurarse de que hay algo que verbalizar."

#: ..\python_docs\spladdoninternals.py:259
msgid ""
"B. If using another app, NVDA will ensure that background monitor flag is "
"set (see the discussion on app module constructor in previous articles for "
"more details)."
msgstr ""
"B. Si se está usando otra aplicación, NVDA se asegurará de que el indicador "
"de monitorización en segundo plano esté establecido (mira la exposición en "
"el constructor del módulo de aplicación en artículos anteriores para más "
"detalles)."

#: ..\python_docs\spladdoninternals.py:260
msgid ""
"C. If the status to be announced is a common one such as listener count, "
"schedule and cart playback status, NVDA will check if it is permited to "
"announce them."
msgstr ""
"C. Si el estado a ser verbalizado es un estado común, como número de "
"oyentes, estado de la programación y reproducción del cart, NVDA comprobará "
"si tiene permitido verbalizarlo."

#: ..\python_docs\spladdoninternals.py:261
msgid ""
"2. Depending on the type of control (mostly window class name), NVDA "
"performs different operations (see below)."
msgstr ""
"2. Dependiendo del tipo de control (mayoritariamente nombre de la clase de "
"ventana), NVDA realiza distintas operaciones (mira más abajo)."

#: ..\python_docs\spladdoninternals.py:262
msgid ""
"3. Lastly, NVDA calls nextHandler() to let other controls respond to name "
"change event."
msgstr ""
"3. Finalmente, NVDA llama a nextHandler() para dejar que otros controles "
"respondan al evento de cambio de nombre."

#: ..\python_docs\spladdoninternals.py:263
msgid "### Status announcements versus alarm notification"
msgstr "### Anuncios de estado comparados con notificaciones de alarma"

#: ..\python_docs\spladdoninternals.py:264
msgid ""
"There are two groups of controls NVDA is interested in: status bar and "
"status text with window class name of TStatusBar and TStaticText, "
"respectively (Studio is a Delphi application). Depending on which control "
"fired the event, NVDA will respond differently."
msgstr ""
"Hay dos grupos de controles en los que NVDA está interesado: la barra de "
"estado y el texto de estado, con nombres de clase de ventana TStatusBar y "
"TStaticText, respectivamente (Studio es una aplicación Delphy). Dependiendo "
"del control que dispare el evento, NVDA reaccionará de forma diferente."

#: ..\python_docs\spladdoninternals.py:265
msgid "For status announcements (TStatusBar), NVDA:"
msgstr "Para anuncios de estado (TStatusBar), NVDA:"

#: ..\python_docs\spladdoninternals.py:266
msgid ""
"1. Checks IAccessible child ID (position of the control relative to the "
"parent control as exposed by MSAA (Microsoft Active Accessibility)/"
"IAccessible)."
msgstr ""
"1. Comprueba el ID del hijo de IAccessible (posición del control relativa al "
"control padre tal y como expone MSAA (Microsoft Active Accessibility) / "
"IAccessible)."

#: ..\python_docs\spladdoninternals.py:267
msgid ""
"2. If IAccessible child ID is 1, it either announces library scan progress "
"or playback status."
msgstr ""
"2. Si el identificador del hijo de IAccessible es 1, se verbaliza el "
"progreso del escaneo de la biblioteca o bien el estado de la reproducción."

#: ..\python_docs\spladdoninternals.py:268
msgid ""
"3. For other status bar objects (controls or windows), NVDA first checks if "
"it is a toggle change (ends with \"On\" or \"Off\"), and if so, it does the "
"following:"
msgstr ""
"3. Para otros objetos de la barra de estado (controles o ventanas), NVDA "
"primero comprueba si es un cambio de conmutación (acaba en \"on\" o \"off"
"\"), y si es así, hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:269
msgid ""
"A. If you set status announcement to words (Control+NVDA+1), NVDA announces "
"toggle change notification via speech."
msgstr ""
"A. Si estableces la verbalización de estado en palabras (ctrl+NVDA+1), NVDA "
"verbaliza la notificación de cambio de estado mediante voz."

#: ..\python_docs\spladdoninternals.py:270
msgid ""
"B. If status announcement is set to beeps, an appropriate wave file is "
"selected for playback via NVWave module (nvwave.playWaveFile; this is done "
"via messageSound function)."
msgstr ""
"B. Si la verbalización de estado se ha establecido en pitidos, se selecciona "
"un archivo wav adecuado y se reproduce mediante el módulo NVWave (nvwave."
"playWaveFile; esto se hace mediante la función messageSound)."

#: ..\python_docs\spladdoninternals.py:271
msgid "C. Braille output is not affected - it'll announce toggle changes."
msgstr ""
"C. La salida braille no se ve afectada, se anunciarán los cambios de "
"conmutación."

#: ..\python_docs\spladdoninternals.py:272
msgid ""
"D. For cart edit mode or microphone toggle, extra steps are performed, (by "
"calling extraAction method with the status string as the argument) such as "
"activating microphone alarm or announcing that you are using Cart Explorer "
"(if this is the case). We'll come back to how this works in future "
"installments."
msgstr ""
"D. Para el modo de edición de cart o la conmutación del micrófono, se "
"realizan pasos extra, (llamando al método extraAction con la cadena de "
"estado como argumento), como activar la alarma del micrófono o indicar que "
"estás usando el explorador cart (si es el caso). Volveremos a explicar cómo "
"funciona esto en futuras entregas."

#: ..\python_docs\spladdoninternals.py:273
msgid ""
"4. For all other announcements, NVDA announces them. In case of schedule "
"announcement, to prevent itself from repeating the same message, NVDA checks "
"if a cached name is the same as the just changed name."
msgstr ""
"4. Para todos los demás anuncios, NVDA los verbaliza. En el caso del anuncio "
"de programación, para evitar que se repita el mismo mensaje, NVDA comprueba "
"si el nombre cambiado es igual que un nombre guardado que ya tenía."

#: ..\python_docs\spladdoninternals.py:274
msgid "For static text controls (mostly used for alarm notifications):"
msgstr ""
"Para controles de texto estático (mayormente usados para notificaciones de "
"alarma):"

#: ..\python_docs\spladdoninternals.py:275
msgid ""
"1. Checks whether NVDA is looking at remaining time for the intro or the "
"whole track."
msgstr ""
"1. Comprueba si NVDA está mirando el tiempo restante para la introducción o "
"para la pista entera."

#: ..\python_docs\spladdoninternals.py:276
msgid ""
"2. For both cases, NVDA checks if it can braille this (braille timer is not "
"off)."
msgstr ""
"2. En ambos casos, comprueba si NVDA puede emitirlo por braille (el "
"temporizador braille no está apagado)."

#: ..\python_docs\spladdoninternals.py:277
msgid ""
"3. If NVDA is told to play or announce alarms (for outro and intro), NVDA "
"plays appropriate tones (middle A (440 hertz) for outro, an octave above "
"middle C (512 hertz) for intro), or if told to do so, warns you that end of "
"track or intro is approaching (add-on 6.0 and later)."
msgstr ""
"3. Si NVDA está configurado para verbalizar o reproducir alarmas (para "
"introducción y fin), NVDA reproduce los tonos apropiados (la mitad de (440 "
"hz) para fin de pista, y una octava por encima de la mitad (512 hz) para la "
"introducción), o si se le pide hacerlo, te avisa de que el fin de pista o la "
"introducción está llegando (complemento 6.0 y posteriores)."

#: ..\python_docs\spladdoninternals.py:278
msgid ""
"The structure of event_nameChange function defined in the Studio app module "
"is such that it can be extended to handle name change event for other "
"controls (it is a tree structure, with the root being the event and two "
"subtrees, one for the status bar and another for static text). Just like "
"other add-ons that define event handling routines, name change event calls "
"nextHandler()."
msgstr ""
"La estructura de la función event_nameChange definida en el módulo de "
"aplicación de Studio está hecha de tal manera que puede extenderse para "
"manejar el evento de cambio de nombre para otros controles (es una "
"estructura en árbol, siendo la raíz el evento y dos subárboles, uno para la "
"barra de estado y otro para el texto estático). Al igual que en otros "
"complementos que definen procedimientos para manejar eventos, el evento de "
"cambio de nombre llama a nextHandler()."

#: ..\python_docs\spladdoninternals.py:279
msgid "### Other events defined in the Studio app module"
msgstr "### Otros eventos definidos en el módulo de aplicación de Studio"

#: ..\python_docs\spladdoninternals.py:280
msgid "There are four more events defined in the Studio app module. They are:"
msgstr ""
"Hay cuatro eventos más definidos en el módulo de aplicación de Studio. Son "
"los siguientes:"

#: ..\python_docs\spladdoninternals.py:281
msgid ""
"* Gain focus: performs focus-related routines such as checking if you are in "
"Insert Tracks dialog in order to turn off background library scanning (more "
"on background library scan in a future installment)."
msgstr ""
"* gainFocus: realiza procedimientos relacionados con el foco, tales como "
"comprobar si estás en el diálogo de inserción de pistas para apagar el "
"escaneo en segundo plano de la biblioteca (más sobre el escaneo de la "
"biblioteca en segundo plano en una entrega futura)."

#: ..\python_docs\spladdoninternals.py:282
msgid ""
"* App module gain focus: Used to handle touchscreens (yes, Studio app module "
"has a dedicated SPL touch mode) such as assigning additional commands."
msgstr ""
"* gainFocus del módulo de aplicación: usado para procesar pantallas táctiles "
"(sí, el módulo de aplicación de Studio tiene un modo táctil dedicado para "
"SPL) que permite añadir órdenes adicionales."

#: ..\python_docs\spladdoninternals.py:283
msgid "* App module lose focus: opposite of the event above."
msgstr ""
"* loseFocus (pérdida de foco) del módulo de aplicación: el opuesto al evento "
"anterior."

#: ..\python_docs\spladdoninternals.py:284
msgid ""
"* Show: this event is specifically designed to respond to listener requests, "
"discussed below."
msgstr ""
"* Show (mostrar): este evento está diseñado específicamente para reaccionar "
"a peticiones de oyentes, de las que hablaremos más abajo."

#: ..\python_docs\spladdoninternals.py:285
msgid "#### Listener requests"
msgstr "#### Peticiones de los oyentes"

#: ..\python_docs\spladdoninternals.py:286
msgid ""
"A seldom talked about component of StationPlaylist Studio is the ability to "
"host a website with a PHP script to allow listeners to request tracks to be "
"played by a broadcaster. When a request is made, Studio pops up a listener "
"request dialog that lists requested tracks."
msgstr ""
"Un componente raro del que se habla en StationPlaylist Studio es la "
"capacidad de alojar un sitio web con un script php para permitir a los "
"oyentes pedir pistas para que el locutor las reproduzca. Cuando se hace una "
"petición, Studio muestra un diálogo de petición del oyente que lista las "
"pistas solicitadas."

#: ..\python_docs\spladdoninternals.py:287
msgid ""
"Due to limitations of old NVDA releases, Studio app module did not have an "
"easy way to detect the appearance of this dialog and notify you of listener "
"requests. This is no longer the case, as NVDA allows show events to be "
"registered for background event tracking. However, because anything can fire "
"show events, tracking show events is not recommended. Knowing this, the "
"Studio app module keeps an eye on show events for one and only one window: "
"listener requests, represented by window class name of TRequests, with the "
"only job assigned for this event handler being playing a sound when requests "
"arrive provided that the requests pop-up option is set in Studio."
msgstr ""
"Debido a las limitaciones que había en antiguas versiones de NVDA, el módulo "
"de aplicación de Studio no lo tenía fácil para detectar la aparición de este "
"diálogo y notificarte las peticiones de los oyentes. Este ya no será más el "
"caso, ya que NVDA permite registrar eventos de mostrar para rastrearlos en "
"segundo plano. Sin embargo, ya que cualquier cosa puede disparar eventos de "
"mostrar, rastrearlos no se recomienda. Sabiendo esto, el módulo de "
"aplicación de Studio vigila los eventos de mostrar de una y sólo una "
"ventana: peticiones de los oyentes, representada por el nombre de clase de "
"ventana TRequests, siendo el único trabajo asignado para este manejador de "
"eventos reproducir un sonido cuando las peticiones llegan, asumiendo que la "
"opción de mostrar un globo cuando lleguen solicitudes esté activada en "
"Studio."

#: ..\python_docs\spladdoninternals.py:288
msgid ""
"So far, we have covered things that the app module performs wherever you are "
"in Studio. the next few sections will cover how the app module handles "
"specific situations, such as working with items in the playlist viewer, "
"finding tracks, library scans and so on."
msgstr ""
"Hasta ahora, hemos cubierto cosas que realiza el módulo de aplicación "
"independientemente de dónde estés en Studio. Las siguientes secciones "
"cubrirán cómo el módulo de aplicación maneja situaciones específicas tales "
"como trabajar con elementos en el visor de listas de reproducción, buscar "
"pistas, escanear la biblioteca y mucho más."

#: ..\python_docs\spladdoninternals.py:289
msgid "## Track items, overlay classes and Track Finder"
msgstr "## Elementos de pista, clases de superposición y buscador de pistas"

#: ..\python_docs\spladdoninternals.py:290
msgid ""
"When you use the Studio add-on for NVDA, you may have noticed that you can "
"perform certain commands while focused on track items, and that the command "
"to find tracks is same as that of find command in web browsers. If you are "
"curious about these, then this installment will let you see how it works. "
"But first, we need to go over some more facts about NVDA screen reader, this "
"time we'll talk about objects."
msgstr ""
"Al usar el complemento de Studio para NVDA, te habrás dado cuenta de que "
"puedes ejecutar ciertas órdenes al tener el foco en los elementos de pista, "
"y que la orden para buscar pistas es la misma que la de buscar en "
"navegadores web. Si tienes curiosidad sobre todo esto, esta entrega te "
"permitirá ver cómo funciona. Pero primero, debemos hablar de algunos hechos "
"más sobre el lector de pantalla NVDA, en esta ocasión hablaremos de objetos."

#: ..\python_docs\spladdoninternals.py:291
msgid "### Important facts about NVDA's use of objects"
msgstr ""
"### Consideraciones importantes sobre el uso que hace NVDA de los objetos"

#: ..\python_docs\spladdoninternals.py:292
msgid ""
"One of the questions I and other add-on authors and NVDA developers received "
"was, \"what exactly are objects and how are they used in NVDA?\" In "
"programming, an object is instance of the object definition coming to life "
"(this definition, called a \"class\", defines how certain things behave and "
"how information can be retrieved from this object by other parts of the "
"program; the programming paradigm that uses classes and related concepts is "
"termed \"object-oriented programming\"). For example, someone may say, "
"\"build me a phone book\", and a programmer will think about how phone book "
"entries are stored and come up with a \"phone book\" (an array of phone "
"entries), all done via objects."
msgstr ""
"Una de las preguntas que hemos recibido tanto yo como otros programadores de "
"complementos y desarrolladores de NVDA es, \"¿Qué son exactamente los "
"objetos y cómo se usan en NVDA?\". En programación, un objeto es una "
"instancia de la definición del objeto en tiempo de ejecución (esta "
"definición, que se conoce como \"clase\", define cómo se comportan ciertas "
"cosas y cómo recuperan la información de este objeto otras partes del "
"programa; el paradigma de programación que usa clases y otros conceptos se "
"llama \"programación orientada a objetos\"). Por ejemplo, alguien puede "
"decir \"Constrúyeme una guía telefónica\", y un programador pensará cómo se "
"almacenan las entradas de una guía de teléfonos y entregará una \"guía "
"telefónica\" (un array de entradas de teléfono), toda ella hecha con objetos."

#: ..\python_docs\spladdoninternals.py:293
msgid ""
"In graphical user interfaces (GUI's), an object is a more technical term for "
"controls (sometimes called widgets). This includes windows, form fields, "
"links, documents and so on. A control (object) can convey information such "
"as state of the control, location, color and so on (the control contains "
"both visible and internal attributes that can be used by other programs)."
msgstr ""
"En las interfaces gráficas de usuario (GUIs), un objeto es un término más "
"técnico para los controles (a veces llamados widgets). Esto incluye "
"ventanas, campos de formulario, enlaces, documentos y demás. Un control "
"(objeto) puede contener información como estado del control, ubicación, "
"color y demás (el control contiene atributos visibles e internos que otros "
"programas pueden usar)."

#: ..\python_docs\spladdoninternals.py:294
msgid ""
"In NVDA world, all screen elements (controls) are objects. As such, when "
"dealing with objects, NVDA uses accessibility API's to obtain needed "
"information. To provide consistent user experience, differences between "
"accessibility API's (IAccessible, UI Automation, Java Access Bridge and so "
"on) are checked and provides a mechanism to announce same information across "
"controls implemented using different frameworks. For example, when a check "
"box is checked, NVDA will say \"checked\"\" - NVDA will know if you checked "
"this box because the underlying accessibility API informs NVDA of this "
"change, and the same information is spoken regardless of whether it is "
"dealing with IAccessible, UIA and so on."
msgstr ""
"En el mundo de NVDA, todos los elementos de la pantalla (controles) son "
"objetos. Por tanto, al trabajar con objetos, NVDA usa las apis de "
"accesibilidad para obtener la información necesaria. Para proporcionar una "
"experiencia de usuario consistente, se comprueban las diferencias entre las "
"distintas apis de accesibilidad (IAccessible, UI Automation, Java Access "
"Bridge y otras), y se ofrece un mecanismo para verbalizar la misma "
"información a través de controles impllementados en distintos marcos de "
"trabajo. Por ejemplo, cuando se marca una casilla de verificación, NVDA dice "
"\"marcado\" - NVDA sabrá que has marcado esta casilla porque la api de "
"accesibilidad subyacente informa a NVDA de este cambio, y la misma "
"información se verbaliza sin importar que esté tratando con IAccessible, UIA "
"o cualquier otro."

#: ..\python_docs\spladdoninternals.py:295
msgid ""
"Currently, NVDA can work with IAccessible, User Interface Automation (UIA), "
"Java Access Bridge (JAB) and others (WAI ARIA is supported). Support modules "
"for these API's lives in source/NVDAObjects directory of the NVDA Core "
"source code."
msgstr ""
"Actualmente, NVDA puede trabajar con IAccessible, User Interface Automation "
"(UIA), Java Access Bridge (JAB) y otras (se soporta WAI Aria). Los módulos "
"de soporte para estas apis se encuentran en el directorio source/NVDAObjects "
"del código fuente principal de NVDA."

#: ..\python_docs\spladdoninternals.py:296
msgid "### Overlay classes: Customizing built-in objects"
msgstr "### Clases superpuestas: personalización de objetos incorporados"

#: ..\python_docs\spladdoninternals.py:297
msgid ""
"If NVDA was limited to using its own object handlers, we would be limited to "
"information that is correctly exposed by accessibility API's (no app modules "
"at all). But why is that NVDA can announce extra information for some "
"controls and comes with various app modules for different applications? This "
"is done through overlay classes - custom objects and their handlers built on "
"top of API classes (built-in objects)."
msgstr ""
"Si NVDA estuviera limitado a usar sus propios manejadores de objetos, "
"estaríamos limitados a la información que exponen correctamente las apis de "
"accesibilidad (no habría módulos de aplicación). ¿Pero por qué NVDA puede "
"verbalizar información extra de algunos controles y viene con diversos "
"módulos de aplicación para diferentes aplicaciones? Esto se hace mediante "
"clases de superposición - objetos personalizados y sus manejadores "
"construidos sobre clases de la api (objetos incorporados)."

#: ..\python_docs\spladdoninternals.py:298
msgid ""
"In essence, overlay classes are subclasses of stable API classes (subclasses "
"are specialist classes deriving (inheriting) from one or more parent "
"classes). This allows custom (overlay) objects to provide extra properties, "
"ranging from control-specific commands to removing certain properties. For "
"example, here's how NVDA's way of announcing toast notifications (Windows 8."
"x and 10) works:"
msgstr ""
"En esencia, las clases de superposición son subclases de clases estables de "
"la api (las subclases son clases especializadas que derivan (heredan) de una "
"o más clases padre). Esto permite a los objetos personalizados "
"(superpuestos) proporcionar propiedades extra, desde órdenes específicas "
"para un control a eliminación de ciertas propiedades. Por ejemplo, así es "
"como funciona NVDA al verbalizar las notificaciones emergentes (Windows 8.x "
"y 10):"

#: ..\python_docs\spladdoninternals.py:299
msgid ""
"1. Toasts are notifications from apps, and they are UIA objects (NVDAObjects."
"UIA.Toast)."
msgstr ""
"1. Las notificaciones emergentes vienen de las aplicaciones, y son objetos "
"UIA (NVDAObjects.UIA.Toast)."

#: ..\python_docs\spladdoninternals.py:300
msgid ""
"2. When events fired by toasts are received by NVDA, it'll check to make "
"sure it is dealing with toast notifications."
msgstr ""
"2. Cuando NVDA recibe los eventos disparados por las notificaciones "
"emergentes, este se asegurará de que está trabajando exactamente con este "
"tipo de notificaciones."

#: ..\python_docs\spladdoninternals.py:301
msgid ""
"3. When NVDA is dealing with toasts, it'll perform what it is told to do by "
"toast objects (announce toasts provided by \"report help balloons\" is "
"checked from Object Presentation dialog)."
msgstr ""
"3. Cuando NVDA trate con notificaciones emergentes, hará lo que le hayan "
"dicho que haga los objetos de notificación emergente (verbalizar las "
"notificaciones sólo si está marcada la casilla \"Anunciar globos de ayuda\" "
"en el diálogo Presentación de objetos)."

#: ..\python_docs\spladdoninternals.py:302
msgid "### Why do objects and overlay classes matter in Studio app module?"
msgstr ""
"### ¿Por qué son importantes los objetos y las clases de superposición en el "
"módulo de aplicación de Studio?"

#: ..\python_docs\spladdoninternals.py:303
msgid ""
"Some readers might ask this question after reading the above section on "
"overlay classes. I had to introduce overlay classes because they are "
"important in Studio app module: track items in playlist Viewer are overlay "
"classes. In fact, there are at least three of them: a base object "
"representing track items for studio and other apps (appModules.splstudio."
"SPLTrackItem), a generic representation of Studio track item (appModules."
"splstudio.SPLStudioTrackItem), and Studio 5.10 track item (appModules."
"splstudio.SPLStudio510TrackItem; in case of 5.10, it derives its power from "
"track item class for Studio 5.0x, which in turn is powered by Studio track "
"item powered by IAccessible)."
msgstr ""
"Algunos lectores podrían hacerse esta pregunta después de leer la sección de "
"arriba sobre las clases de superposición. Tenía que introducir las clases de "
"superposición porque son importantes en el módulo de aplicación de Studio: "
"los elementos de pista en el visor de listas de reproducción son clases de "
"superposición. De hecho, hay al menos tres de ellas: un objeto base que "
"representa elementos de pista para Studio y otras aplicaciones (appModules."
"splstudio.SPLTrackItem), una representación genérica de un elemento de pista "
"de Studio (appModules.splstudio.SPLStudioTrackItem), y elementos de pista "
"para Studio 5.10 (appModules.splstudio.SPL510TrackItem; en el caso de la "
"5.10, se deriva su poder de la clase de elemento de pista para Studio 5.0x, "
"que en cierto modo va potenciada por el elemento de pista de Studio e "
"IAccessible)."

#: ..\python_docs\spladdoninternals.py:304
msgid ""
"These classes were born when I started working on Studio 5.10 support in "
"2014. Because Studio 5.10 uses a different way of showing track properties, "
"I had to come up with a way to take care of them. Adding to the urgency was "
"the fact that Studio 5.10 uses check marks to indicate whether a track is "
"selected for playback (Studio 5.0x and earlier uses check boxes), and when "
"check marks are checked in Studio 5.10, NVDA would not announce newly "
"checked state, fixed by defining a routine to be used when SPACE is pressed "
"(via an overlay class). In addition, initial version of Track Finder (see "
"below) was sensitive to object description changes, I modified it to account "
"for differences between Studio versions."
msgstr ""
"Estas clases nacieron cuando empecé a trabajar en el soporte para Studio "
"5.10 en 2014. Ya que Studio 5.10 usa una manera diferente para mostrar "
"propiedades de la pista, tuve que trabajar en una manera de procesarlas. A "
"la urgencia se añadía el hecho de que Studio 5.10 usa marcas de verificación "
"para indicar si una pista está seleccionada para reproducción (Studio 5.0x y "
"anteriores usan casillas de verificación), y cuando estas marcas de "
"verificación se marcan en Studio 5.10, NVDA no anuncia el nuevo estado de "
"verificación, esto se arregló creando un procedimiento usado al pulsar "
"espacio (mediante una clase de superposición). Además, la primera versión "
"del buscador de pistas (mira más abajo) era sensible a cambios de "
"descripción de los objetos, la modifiqué para que tuviera en cuenta las "
"diferencias entre versiones de Studio."

#: ..\python_docs\spladdoninternals.py:305
msgid ""
"Then in 2015, when I was designing Track Dial (next section), I thought "
"about scope of this feature. I thought, \"if I let this be invoked from "
"everywhere, it could lead to issues such as errors and attempting to use "
"Track Dial from somewhere other than track items\". Then I thought, "
"\"perhaps I should limit this feature to main playlist viewer at the cost of "
"making sure I identify track items correctly\". Given that I had experience "
"with overlay classes and since there was already an overlay class for Studio "
"5.10 track items, I decided to go with the latter option, which led to "
"defining a new overlay class for Studio 5.0x track items and letting 5.10 "
"track items inherit from this new class."
msgstr ""
"Después, en 2015, cuando estaba diseñando el dial de pista (siguiente "
"sección), pensé en el ámbito de esta característica. Pensé, \"Si dejo que se "
"invoque desde cualquier parte, podría crear problemas como errores e "
"intentos de usar el dial de pista desde un lugar distinto a los elementos de "
"pista\". Después pensé, \"Tal vez debería limitar esta característica al "
"visor de listas de reproducción principal con el coste de identificar los "
"elementos de pista correctamente\". Dado que tenía experiencia con clases de "
"superposición y ya que había una clase de superposición para los elementos "
"de pista de Studio 5.10, decidí seguir adelante con la última opción, que "
"desembocó en la definición de una nueva clase de superposición para los "
"elementos de pista de Studio 5.0x y dejando que la clase de los elementos de "
"pista de Studio 5.10 heredara de esta nueva clase."

#: ..\python_docs\spladdoninternals.py:306
msgid ""
"In 2018, as support for Columns Explorer was being worked on for Creator and "
"Track Tool, I decided to overhaul the entire track item class hierarchy. "
"Since track items would use same column navigation routines, it was decided "
"to split SPL 5.0x track item class into two classes: the old track item "
"class, and a new abstract class providing basic services for Studio, Creator "
"and Track Tool track items. Also, in order to support column reordering, "
"SysListView32 class was employed, as it provides a handy routine to retrieve "
"column content for the correct column when columns were rearranged on screen."
msgstr ""
"En 2018, mientras se estaba trabajando en el soporte del explorador de "
"columnas para Creator y la herramienta de pista, decidí revisar la jerarquía "
"completa de clases de elemento de pista. Ya que los elementos de pista "
"usaban los mismos procedimientos de navegación por columnas, decidí dividir "
"la clase de elemento de pista de SPL 5.0x en dos clases: la vieja clase de "
"elemento de pista, y una nueva clase abstracta que proporciona servicios "
"básicos para los elementos de pista de Studio, Creator y la herramienta de "
"pista. Además, para dar soporte al reordenado de columnas, se empleó la "
"clase SysListView32, ya que proporciona un procedimiento útil para recuperar "
"el contenido de una columna en la columna correcta cuando estas se reordenan "
"en pantalla."

#: ..\python_docs\spladdoninternals.py:307
msgid "### Track items overview"
msgstr "### Descripción de los elementos de pista"

#: ..\python_docs\spladdoninternals.py:308
msgid ""
"Each track item in Studio's playlist viewer (and in extension, tracks list "
"in Creator and Track Tool) consists of a row of columns (6 for Studio 5.0x "
"and earlier, 18 for 5.10 and later). As far as NVDA is concerned, it is an "
"overlay class that provides a number of services, including:"
msgstr ""
"Cada elemento de pista en el visor de listas de reproducción de Studio "
"consta de una fila de columnas (6 para Studio 5.0x y anteriores, 18 para "
"Studio 5.10 y posteriores). Tal y como está concebido NVDA, es una clase de "
"superposición que proporciona un número de servicios, incluyendo:"

#: ..\python_docs\spladdoninternals.py:309
msgid "* Routines for navigating and announcing various columns."
msgstr "* Procedimientos para verbalizar y navegar por diversas columnas."

#: ..\python_docs\spladdoninternals.py:310
msgid ""
"* Announcing columns in specific order (see the next chapter on importance "
"of column navigation)."
msgstr ""
"* Verbalizar las columnas en un orden específico (mira el próximo capítulo "
"para conocer la importancia de la navegación por columnas)."

#: ..\python_docs\spladdoninternals.py:311
msgid ""
"* For Studio, obtaining track comments if defined (see track comments "
"section below)."
msgstr ""
"* En Studio, Obtener comentarios de pista si están definidos (mira la "
"sección de comentarios de pista más abajo)."

#: ..\python_docs\spladdoninternals.py:312
msgid ""
"* For studio 5.10 and later, a routine to handle when check marks are "
"checked (when you check a track by pressing SPACE, NVDA will announce the "
"newly checked state and will update the braille display accordingly)."
msgstr ""
"* En Studio 5.10 y posteriores, un procedimiento para procesar la marcación "
"de las marcas de verificación (cuando marques una pista pulsando espacio, "
"NVDA verbalizará el nuevo estado de verificación y actualizará la pantalla "
"braille apropiadamente)."

#: ..\python_docs\spladdoninternals.py:313
msgid ""
"We'll come back to track items when talking about columns later. For now, "
"let's move onto two related features in Studio app module that works with "
"track items: Track Finder and track comments. There is a second feature that "
"deals with Track Finder, and we'll meet this feature in the next section."
msgstr ""
"Volveremos a los elementos de pista cuando hablemos de columnas en el "
"próximo artículo. Por ahora, movámonos a dos características relacionadas en "
"el módulo de aplicación de Studio que funcionan con los elementos de pista: "
"buscador de pistas y comentarios de pista. Hay una segunda característica "
"que trata con el buscador de pistas, la encontraremos en la siguiente "
"sección."

#: ..\python_docs\spladdoninternals.py:314
msgid "### Track Finder: Locating tracks given a search string"
msgstr ""
"### Buscador de pistas: ubicación de pistas dada una cadena de búsqueda"

#: ..\python_docs\spladdoninternals.py:315
msgid ""
"Track Finder allows you to search for tracks with the given artist or song "
"title. This is done by performing a \"linear search\" - examining one track "
"item to the next until the search term is found. This feature was partly "
"inspired by similar features in other screen readers and NVDA's own find "
"facility (cursorManager.FindDialog and its friends)."
msgstr ""
"El buscador de pistas permite buscar pistas dado su autor o el título de la "
"canción. Esto se hace mediante una \"búsqueda lineal\" - examinando un "
"elemento de pista y el siguiente hasta que se encuentra el término de "
"búsqueda. Esta característica está inspirada en parte por características "
"similares en otros lectores de pantalla y la propia función de búsqueda de "
"NVDA (cursorManager.FindDialog y sus amigos)."

#: ..\python_docs\spladdoninternals.py:316
msgid ""
"Track finder is not limited to searching for artist or title: a variation of "
"this dialog (called Column Search) allows you to search for text in specific "
"columns such as duration, file name and so on. Another variation of this "
"dialog, called Time Range Finder (which is a separate dialog of its own "
"(splmisc.SPLTimeRangeDialog) but modeled after Track Finder) uses Studio API "
"to locate tracks with duration between minimum and maximum specified by a "
"user."
msgstr ""
"El buscador de pistas no está limitado a buscar por artista o título: una "
"variante de este diálogo (llamada búsqueda por columnas) permite buscar "
"texto en columnas específicas como duración, nombre de archivo y demás. Otra "
"variante de este diálogo, llamada buscador de rango de tiempo (que es un "
"diálogo separado del otro (splmisc.SPLTimeRangeDialog) pero modelado después "
"del buscador de pista) usa la api de Studio para ubicar pistas con duración "
"entre el mínimo y el máximo especificados por el usuario."

#: ..\python_docs\spladdoninternals.py:317
msgid ""
"In reality, Track Finder and Column Search are a single dialog (splmisc."
"SPLFindDialog) that presents two dialogs (does this sound familiar?). For "
"now, we'll talk about how the original Track Finder (add-on 2.x to 5.x) "
"works (stay tuned for the next section to learn more about Column Search and "
"the complete refactoring of track finder and its applications)."
msgstr ""
"En realidad, el buscador de pistas y el buscador por columnas son un único "
"diálogo (splmisc.SPLFindDialog) que presenta dos diálogos (¿Te suena de "
"algo?). Por ahora, hablaremos de cómo el buscador de pistas original "
"(complementos del 2.x al 5.x) funciona (estáte atento a la próxima sección "
"para aprender más sobre la búsqueda de columnas y la refactorización "
"completa del buscador de pistas y sus aplicaciones)."

#: ..\python_docs\spladdoninternals.py:318
msgid "#### Original track Finder: commands, routines and controls"
msgstr "#### Buscador de pistas original: órdenes, procedimientos y controles"

#: ..\python_docs\spladdoninternals.py:319
msgid ""
"To use Track Finder, press Control+NVDA+F (wait, I saw this command before). "
"For anyone who are accustomed to NVDA's browse mode, this command would be "
"familiar: find text in webpages. This command performs activities similar to "
"alarm dialogs (see previous articles): after conditions are checked (making "
"sure you are in playlist viewer and you have added at least one track) and "
"setting required flags, NVDA opens Track Finder dialog where you can enter a "
"search term and press ENTER. NVDA will call track finder function "
"(trackFinder) to locate the track with the given search term, and depending "
"on search results, NVDA will move focus to the track or open a dialog saying "
"results were not found."
msgstr ""
"Para usar el buscador de pistas, pulsa ctrl+NVDA+f (espera, yo ya he visto "
"antes esta orden). Para cualquiera que esté acostumbrado al modo exploración "
"de NVDA, esta orden debería ser familiar: buscar texto en páginas web. Esta "
"orden realiza actividades similares a los diálogos de alarma (mira los "
"artículos anteriores): después de comprobar las condiciones (asegurándose de "
"que estás en el visor de lista de reproducción y que has añadido al menos "
"una pista) y establecer los indicadores necesarios, NVDA abre el diálogo del "
"buscador de pistas, donde puedes introducir un término de búsqueda y pulsar "
"intro. NVDA llamará a la función del buscador de pistas (trackFinder) para "
"encontrar la pista con el término de búsqueda dado, y dependiendo de los "
"resultados de búsqueda, NVDA moverá el foco a la pista o abrirá un diálogo "
"diciendo que no se encontraron resultados."

#: ..\python_docs\spladdoninternals.py:320
msgid ""
"Two other commands are used as part of Track Finder: Find next and previous, "
"assigned to NVDA+F3 and NVDA+Shift+F3, respectively (they also come from "
"browse mode). When these commands are invoked, it'll check if you have "
"searched for a term before, and if not, it'll open Track Finder dialog. If "
"you have searched for a term before, NVDA will perform linear search with "
"search direction specified (trackFinder method in the app module takes "
"various parameters, and one of them is search direction)."
msgstr ""
"Otras dos órdenes se usan como parte del buscador de pistas: buscar "
"siguiente y anterior, asignadas to NVDA+f3 y NVDA+shift+f3, respectivamente "
"(también vienen del modo exploración). Cuando se invocan estas órdenes, se "
"comprueba si has introducido previamente un término de búsqueda, y si no es "
"así, se abrirá el diálogo del buscador de pistas. Si previamente ya has "
"buscado un término, NVDA hará una búsqueda lineal en la dirección de "
"búsqueda especificada (el método trackFinder en el módulo de aplicación "
"acepta varios parámetros, y uno de ellos es la dirección de búsqueda)."

#: ..\python_docs\spladdoninternals.py:321
msgid "#### Track Finder 1.0 versus 2.0"
msgstr "#### Comparación del buscador de pistas 1.0 y el 2.0"

#: ..\python_docs\spladdoninternals.py:322
msgid ""
"In add-on version 2.0 to 5.x, when told to find tracks, NVDA will look for "
"search term in track descriptions (in case you are searching for artist in "
"Studio 5.0x, NVDA will also check the name of the check box, as this holds "
"artist name). Although this was simple to implement, it had some issues:"
msgstr ""
"En las versiones del complemento 2.0 a 5.x, al pedirle que busque pistas, "
"NVDA buscará el término de búsqueda en las descripciones de pista (en caso "
"de que estés buscando por artista en Studio 5.0x, NVDA también comprobará el "
"nombre de la casilla de verificación, ya que contiene el nombre del "
"artista). Aunque esto fue fácil de implementar, tenía varios problemas:"

#: ..\python_docs\spladdoninternals.py:323
msgid ""
"1. Because of track item changes in Studio 5.10, I had to spend some time "
"adjusting the track finder formula."
msgstr ""
"1. A causa de los cambios del elemento de pista en Studio 5.10, tuve que "
"dedicar algún tiempo a ajustar la fórmula del buscador de pistas."

#: ..\python_docs\spladdoninternals.py:324
msgid ""
"2. Wehn finding a track in a playlist with hundreds of tracks loaded, "
"finding a track at the end of the playlist took several seconds, and this "
"wasn't acceptable to users."
msgstr ""
"2. Al buscar una pista en una lista de reproducción con cientos de pistas "
"cargadas, encontrar una pista al final de la lista llevaba varios segundos, "
"y esto no era aceptable para los usuarios."

#: ..\python_docs\spladdoninternals.py:325
msgid ""
"In add-on 6.0, thanks to column search, Track Finder's performance was "
"improved. Also, track finder was split into two functions: trackFinder still "
"manages moving focus or showing the error dialog, while the linear search "
"now lives in a private function. This design allows track finder routine to "
"be used by more than one feature (in this case, place marker feature uses "
"this, as you'll see in the next section."
msgstr ""
"En el complemento 6.0, gracias a la búsqueda por columnas, el rendimiento "
"del buscador de pistas mejoró. Además, el buscador se dividió en dos "
"funciones: trackFinder todavía gestiona el movimiento del foco o muestra el "
"diálogo de error, mientras que la búsqueda lineal ahora reside en una "
"función privada. Este diseño permite que el procedimiento de búsqueda de "
"pistas pueda ser usado por más de una característica (en este caso, el "
"marcador de posiciones lo usa, como verás en la próxima sección)."

#: ..\python_docs\spladdoninternals.py:326
msgid ""
"For both versions, the signature of trackFinder method (linear search "
"routine in 1.0, search results manager in 2.0) in the Studio app module is:"
msgstr ""
"En ambas versiones, la cabecera del método trackFinder (procedimiento de "
"búsqueda lineal en 1.0, gestor de resultados de búsqueda en 2.0) en el "
"módulo de aplicación de Studio es:"

#: ..\python_docs\spladdoninternals.py:327
msgid "\ttrackFinder(self, text, obj, directionForward=True, column=None)"
msgstr "\ttrackFinder(self, text, obj, directionForward=True, column=None)"

#: ..\python_docs\spladdoninternals.py:328
msgid ""
"Text is the search term, obj is where the search should begin, direction "
"specifies search direction and column is used if Column Search is used "
"(searching for text in specific columns). In Track Finder 2.0 (add-on 6.0), "
"add an \"s\" to column keyword."
msgstr ""
"Text es el término de búsqueda, obj indica dónde debería comenzar la "
"búsqueda, direction especifica la dirección de búsqueda y column se usa si "
"se emplea la búsqueda por columnas (buscar texto en columnas específicas). "
"En el buscador de pistas 2.0 (complemento 6.0), se añade una \"s\" a la "
"palabra clave column."

#: ..\python_docs\spladdoninternals.py:329
msgid ""
"In the next section, we'll learn more about how NVDA performs column "
"navigation commands and how it is used in various features. We'll also meet "
"how Track Finder refactor has helped implement an unexpected feature or two "
"in the Studio add-on."
msgstr ""
"En la próxima sección, aprenderemos más sobre cómo realiza NVDA las órdenes "
"de navegación de columna y cómo se usa en varios escenarios. También "
"sabremos cómo nos ha ayudado la refactorización del buscador de pistas a "
"implementar una o dos características inesperadas en el complemento de "
"Studio."

#: ..\python_docs\spladdoninternals.py:330
msgid ""
"## Method resolution  order and importance of column navigation in track "
"items, Track Tool and other features"
msgstr ""
"## Orden de resolución de métodos e importancia de la navegación por "
"columnas en los elementos de pista, la herramienta de pista y otras "
"características"

#: ..\python_docs\spladdoninternals.py:331
msgid ""
"In the previous section, you saw how overlay classes work, as well as how "
"track items in Studio are defined and used. We'll continue our tour of track "
"items by looking at column navigation feature and how it is used in various "
"places. But before we get into that, we need to talk about how NVDA knows "
"how certain commands apply in specific situations via method resolution "
"order."
msgstr ""
"En la sección anterior vimos cómo funcionaban las clases de superposición, y "
"cómo se definen y usan los elementos de pista en Studio. Vamos a continuar "
"con nuestro recorrido por los elementos de pista mirando la característica "
"de navegación por columnas y viendo cómo se usa en diversos lugares. Pero "
"antes de eso, debemos hablar sobre cómo sabe NVDA cómo aplicar ciertas "
"órdenes en situaciones específicas mediante el orden de resolución de "
"métodos."

#: ..\python_docs\spladdoninternals.py:332
msgid ""
"### Method resolution order: locating commands and defining command scope"
msgstr ""
"### Orden de resolución de métodos: ubicación de órdenes y definición de su "
"ámbito"

#: ..\python_docs\spladdoninternals.py:333
msgid ""
"If multiple classes (objects) are defined, especially if inheritance is "
"involved, it becomes hard to determine which method is which and where "
"various methods are defined. This becomes complicated when two or more "
"classes inherit from a single parent, or multiple inheritance is in use "
"(Python supports both scenarios)."
msgstr ""
"Si se definen múltiples clases (objetos), especialmente si la herencia está "
"implicada, es duro determinar qué método es cuál y dónde se definen diversos "
"métodos. Esto se hace más complicado cuando dos o más clases heredan del "
"mismo padre, o se emplea herencia múltiple (Python soporta ambos escenarios)."

#: ..\python_docs\spladdoninternals.py:334
msgid ""
"One way Python solves this is through Method Resolution Order (MRO). Simply "
"put, when a method is to be used, it first looks at whether this method is "
"defined in the object it is dealing with, and if not, will consult the "
"parent of this object."
msgstr ""
"Una forma que tiene Python de resolver esto es a través del orden de "
"resolución de métodos (ORM). Resumiendo, cuando tiene que usarse un método, "
"primero se mira si el método está definido en el objeto con el que estamos "
"tratando, y si no, se consultará al padre de este objeto."

#: ..\python_docs\spladdoninternals.py:335
msgid ""
"For example, suppose we have a list box that defines a scroll method, and a "
"custom list box widget inherits from this list box (in effect, custom list "
"box is a list box). To make matters slightly complicated, let's say the "
"scroll method is not defined (not really defined) in the custom list box. "
"Then when the user scrolls through the custom list box, Python will see that "
"the custom list box does not have the scroll method, so it'll look at the "
"parent (original list box) and use its scroll method (in this case, yes, "
"Python will use the parent's scroll method)."
msgstr ""
"Por ejemplo, supongamos que tenemos un cuadro de lista que define un método "
"scroll, y un widget de cuadro de lista personalizado que hereda de este "
"cuadro de lista (en efecto, el cuadro de lista personalizado es un cuadro de "
"lista). Para complicar un poco más las cosas, digamos que el método scroll "
"no está definido (no está realmente definido) en el cuadro de lista "
"personalizado. Cuando el usuario se desplace por el cuadro de lista "
"personalizado, Python verá que el cuadro de lista personalizado no tiene el "
"método scroll, por lo que mirará en el padre (cuadro de lista original) y "
"empleará su método scroll (en este caso sí, Python usará el método scroll "
"del padre)."

#: ..\python_docs\spladdoninternals.py:336
msgid ""
"In terms of NVDA, method resolution order comes in handy when dealing with "
"overlay classes. This has wide ranging consequences, including ability to "
"limit where certain commands can be used to not defining a command (setting "
"the script bound to gesture to None), effectively forcing NVDA to look up a "
"given gesture from the base class (parent). If NVDA cannot locate the "
"command in question, it'll pass this to Windows, which then sends the "
"command to the active program."
msgstr ""
"En términos de NVDA, el orden de resolución de métodos es útil al tratar con "
"clases de superposición. Esto tiene un extenso rango de consecuencias, "
"incluyendo la habilidad de limitar dónde se pueden emplear ciertas órdenes o "
"no definir una orden (configurando el script para que esté asociado al gesto "
"None), forzando a NVDA de forma efectiva a que busque un gesto en una clase "
"base (padre). Si NVDA no puede hallar la orden en cuestión, la pasará a "
"Windows, que a continuación envía la orden al programa activo."

#: ..\python_docs\spladdoninternals.py:337
msgid "### Finishing the puzzle: MRO and Studio's track items"
msgstr "### Terminando el puzle: ORM y los elementos de pista de Studio"

#: ..\python_docs\spladdoninternals.py:338
msgid ""
"As described in the previous section, Studio app module defines three "
"classes for track items: base class for tracks found in Studio and other "
"apps, a class representing Studio 5.0x items, and another for 5.1x. In "
"reality, all that matters is the first two, with the 5.10 class providing "
"custom routines on top of the 5.0x track item class. In case of MRO, Studio "
"5.10 will be consulted if 5.10 is in use, then NVDA will consult Studio "
"track item. For 5.0x, only original track item class will be consulted."
msgstr ""
"Como se describe en la sección anterior, el módulo de aplicación de Studio "
"define tres clases para los elementos de pista: una clase base para pistas "
"encontradas en Studio y otras aplicaciones, una clase representando "
"elementos de Studio 5.0x y otra para 5.1x. En realidad, todo lo que importa "
"está en las dos primeras, y la clase para 5.10 proporciona procedimientos "
"personalizados sobre la clase de elemento de pista para la versión 5.0x. En "
"caso de MRO, se consultará al módulo de Studio 5.10 si este está en uso, y "
"luego NVDA consultará al elemento de pista de Studio. Para la versión 5.0x, "
"sólo se consultará a la clase original de elemento de pista."

#: ..\python_docs\spladdoninternals.py:339
msgid ""
"The contents of the base track item class (appModules.splstudio."
"SPLTrackItem) are as follows:"
msgstr ""
"Los contenidos de la clase base de elemento de pista (appModules.splstudio."
"SPLTrackItem) son los siguientes:"

#: ..\python_docs\spladdoninternals.py:340
msgid ""
"* initOverlayClass: This is run when the track item is first encountered. "
"This method checks if Track Dial (see below) is active, and if so, assigns "
"left and right arrow keys to Track Dial functions."
msgstr ""
"* initOverlayClass: se ejecuta cuando se encuentra por primera vez un "
"elemento de pista. Este método comprueba si el dial de pista (mira más "
"abajo) está activo, y si es así, asigna las flechas izquierda y derecha a "
"las funciones del dial de pista."

#: ..\python_docs\spladdoninternals.py:341
msgid ""
"* Track column navigation: Various methods and scripts used by Track Dial "
"and friends are defined, including announcing column information, handling "
"leftmost column and so on. Add-on 8.0 adds Columns Explorer routines, and "
"17.04 adds vertical column navigation support."
msgstr ""
"* Navegación por columnas de pista: se definen diversos métodos y scripts "
"usados por el dial de pista y sus amigos, incluyendo verbalización de "
"información de la columna, identificación de la columna más a la izquierda y "
"demás. El complemento 8.0 añade los procedimientos del explorador de "
"columnas, y el 17.04 añade soporte de navegación vertical por columnas."

#: ..\python_docs\spladdoninternals.py:342
msgid ""
"Studio track item class for 5.0x (appModules.splstudio.SPLStudioTrackItem) "
"adds:"
msgstr ""
"La clase de elemento de pista de Studio para la versión 5.0x (appModules."
"splstudio.SPLStudioTrackItem) añade:"

#: ..\python_docs\spladdoninternals.py:343
msgid ""
"* reportFocus: This is called when reporting track items to you "
"(broadcaster). It's main job is to see if custom column order is defined "
"(see below) and builds needed pieces if column order is specified."
msgstr ""
"* reportFocus: se llama a esta función al informarte a ti (locutor) sobre "
"los elementos de pista. Su función principal es ver si se ha definido un "
"orden personalizado para las columnas (mira más abajo) y construye las "
"piezas necesarias si se especifica un orden de columnas."

#: ..\python_docs\spladdoninternals.py:344
msgid ""
"* Track comments: Routines related to working with comments for traks (see "
"the previous section for details)."
msgstr ""
"* Comentarios de pista: procedimientos relacionados con el trabajo con "
"comentarios de pista (mira la sección anterior para más detalles)."

#: ..\python_docs\spladdoninternals.py:345
msgid ""
"In addition, Studio 5.10 track item (appModules.splstudio."
"SPLStudio510TrackItem) includes a script to announce changed state when "
"SPACE is pressed (this is done by speaking and/or brailling track name (obj."
"name))."
msgstr ""
"Además, el elemento de pista de Studio 5.10 (appModules.splstudio."
"SPL510TrackItem) incluye un script para verbalizar el cambio de estado "
"cuando se pulsa espacio (esto se hace hablando y / o mostrando en braille el "
"nombre de pista (obj.name))."

#: ..\python_docs\spladdoninternals.py:346
msgid "### Birth of Track Dial: from hesitation to possibilities"
msgstr "### Nacimiento del dial de pista: de la duda a las posibilidades"

#: ..\python_docs\spladdoninternals.py:347
msgid ""
"Note: Information on Track Dial is kept for reference purposes. Track Dial "
"was deprecated in 2017 with the release of add-on 17.04."
msgstr ""
"Nota: la información sobre el dial de pista se conserva con propósitos de "
"referencia y consulta. El dial de pista quedó obsoleto en 2017 con la "
"publicación del complemento 17.04."

#: ..\python_docs\spladdoninternals.py:348
msgid ""
"As I was writing the add-on, one of the top suggestions I received was "
"ability to use enhanced arrow keys feature to review columns. This feature "
"allows broadcasters using screen reader scripts to use arrow keys to review "
"column information such as artist, duration and so on. As of time of this "
"writing, all three screen reader scripts support this feature."
msgstr ""
"Según estaba programando el complemento, una de las sugerencias que más "
"recibía era la capacidad de usar la característica de flechas mejoradas para "
"revisar columnas. Esta característica permite a los locutores que usan "
"scripts para lectores de pantalla usar las flechas para revisar información "
"de columnas como artista, duración y demás. En el momento en que escribo "
"esto, los tres scripts para lectores de pantalla soportan esta "
"característica."

#: ..\python_docs\spladdoninternals.py:349
msgid ""
"At first, I told broadcasters that this wasn't possible. My impression back "
"then (summer 2014) was that I had to manipulate track description text (obj."
"description) to enable this possibility. But seeing how other screen readers "
"implement this convinced me that it might be possible to implement this for "
"NVDA users, thus I started researching this in fall 2014."
msgstr ""
"Al principio, dije a los locutores que esto no era posible. Mi impresión por "
"entonces (verano de 2014) era que tendría que manipular el texto de la "
"descripción de pista (obj.description) para activar esta posibilidad. Pero "
"viendo cómo implementaban esto otros lectores de pantalla, me convencí de "
"que podría ser posible implementarlo para usuarios de NVDA, y por tanto "
"comencé a investigar sobre ello a finales de 2014."

#: ..\python_docs\spladdoninternals.py:350
msgid ""
"I started by looking for patterns in description text that could be used to "
"give users an impression that column navigation was active (when it was "
"not). I studied how Python handles regular expressions and manipulated "
"substrings (str.find and slicing) with no satisfactory results. Then in "
"2015, while working on improving support for Studio's own stream encoder, I "
"noticed that the encoder entries were SysListView32 objects (NVDAObjects."
"IAccessible.SysListView32). Careful study of this object, especially a "
"method to retrieve column content, gave me an idea as to how to bring Track "
"Dial to life."
msgstr ""
"Comencé buscando patrones en el texto de la descripción que pudieran ser "
"usados para dar a los usuarios la impresión de que la navegación por "
"columnas estaba activa (cuando no lo estaba). Estudié cómo trabajaba Python "
"con las expresiones regulares y cómo manipulaba subcadenas (str.find y "
"división) sin resultados satisfactorios. Después, en 2015, mientras "
"trabajaba para mejorar el soporte para el codificador propio de Studio, me "
"di cuenta de que las entradas del codificador eran objetos SysListView32 "
"(NVDAObjects.IAccessible.SysListView32). Estudié cuidadosamente este objeto, "
"especialmente un método para recuperar el contenido de una columna, y esto "
"me dio una idea sobre cómo traer el dial de pista a la vida."

#: ..\python_docs\spladdoninternals.py:351
msgid "### The magic behind Track Dial: SysListView32 controls"
msgstr "### La magia tras el dial de pista: los controles SysListView32"

#: ..\python_docs\spladdoninternals.py:352
msgid ""
"SysListView32 controls are lists with items organized into columns. For "
"example, certain apps use these controls to arrange entries into columns, "
"such as in certain table-based apps, and in case of studio, displaying "
"various status about encoders."
msgstr ""
"Los controles SysListView32 son listas con elementos organizados en "
"columnas. Por ejemplo, ciertas aplicaciones usan estos controles para "
"ordenar entradas en columnas, tales como ciertas aplicaciones basadas en "
"tablas, y en el caso de Studio, mostrar diversos estados de los "
"codificadores."

#: ..\python_docs\spladdoninternals.py:353
msgid ""
"When these controls are encountered, NVDA allows you to use table navigation "
"commands (Control+Alt+arrows) to navigate between columns, provided that "
"there are child objects (columns) exposed by the accessibility API "
"implementation in use. Table navigation commands are supplied by another "
"class (behaviors.RowWithFakeNavigation; the behaviors mix-in includes things "
"NVDA should perform in various scenarios, including terminal input and "
"output, editable text handling (via a dedicated module) and so on). This is "
"all possible thanks to a method in SysListView32 class (NVDA Core) that "
"allows one to retrieve column text, and this became the engine for Track "
"Dial, Columns Explorer and other column navigation facilities in the Studio "
"add-on (I say \"add-on\" because column navigation is used by both Studio "
"and Track Tool). This was further solidified in 2018 when all track item "
"classes were repowered by SysListView32.ListItem class."
msgstr ""
"Cuando se encuentran estos controles, NVDA permite usar órdenes de "
"navegación de tablas (ctrl+alt+flechas) para navegar entre columnas, "
"asumiendo que hay objetos hijo (columnas) expuestos por la implementación de "
"la api de accesibilidad en uso. Las órdenes de navegación de tabla vienen "
"ofrecidas por otra clase (behaviors.RowWithFakeNavigation; el paquete "
"behaviors incluye cosas que NVDA debería hacer en diversos escenarios, "
"incluyendo entrada y salida de una terminal, procesamiento de texto editable "
"(mediante un módulo dedicado) y demás). Todo esto es posible gracias a un "
"método en la clase SysListView32 (núcleo de NVDA) que permite recuperar el "
"texto de una columna, y este se convirtió en el motor para el dial de pista, "
"el explorador de columnas, y otras características de navegación por "
"columnas en el complemento de Studio (digo \"complemento\" porque tanto "
"Studio como la herramienta de pista usan la navegación por columnas). Esto "
"se solidificó más en 2018, cuando todas las clases de elementos de pista "
"fueron potenciadas por la clase SysListView32.ListItem."

#: ..\python_docs\spladdoninternals.py:354
msgid ""
"Until 2018, the column text retrieval routine (which lives in SysListView32 "
"and a copy lives in splstudio.splmisc module) was as follows:"
msgstr ""
"Hasta el 2018, El procedimiento de recuperación del texto de la columna (que "
"reside en SysListView32 y cuya copia reside en el módulo splstudio.splmisc) "
"era el siguiente:"

#: ..\python_docs\spladdoninternals.py:355
msgid ""
"1. Features requiring text from a specific column will call a private "
"function in splstudio.splmisc module, which will take the current object and "
"the column index as parameters."
msgstr ""
"1. Las características que necesiten texto de una columna específica "
"llamarán a una función privada en el módulo splstudio.splmisc, que recibirá "
"el objeto y el índice de columna como parámetros."

#: ..\python_docs\spladdoninternals.py:356
msgid ""
"2. The column retriever first looks up the handle for the process where the "
"control lives, then creates a place holder for the buffer to hold the column "
"content."
msgstr ""
"2. El recuperador de columnas primero obtiene el manejador del proceso donde "
"reside el control, luego crea un marcador de posición para el buffer que "
"capturará el contenido de la columna."

#: ..\python_docs\spladdoninternals.py:357
msgid ""
"3. Next, it looks at the size of the underlying sysListView32 control "
"(ctypes.sizeof) and asks Windows to allocate storage for an internal "
"SysListView32 control via kernel32.dll's VirtualAllocEx. This is needed to "
"store the resulting column text. Same is done for another place holder to "
"store the actual column text by calling VirtualAllocEx."
msgstr ""
"3. A continuación, mira el tamaño del control SysListView32 subyacente "
"(ctypes.sizeof) y pide a Windows que reserve almacenamiento para un control "
"SysListView32 interno mediante la función VirtualAllocEx de kernel32.dll. "
"Esto es necesario para almacenar el texto de la columna resultante. Lo mismo "
"se hace con otro marcador de posición para almacenar el texto real de la "
"columna llamando a VirtualAllocEx."

#: ..\python_docs\spladdoninternals.py:358
msgid ""
"4. The retriever then creates an internal SysListView32 control used as a "
"place holder to store column text, then asks Windows to tell the process "
"where the column text lives to reveal the column text for the specified "
"column (first calls WriteProcessMemory, sens a message via user32.dll's "
"SendMessage to retrieve text length, then uses ReadProcessMemory to retrieve "
"the actual column text if there is something to read). Once the column text "
"is revealed, the retriever stores the text inside the text buffer (ctypes."
"create_unicode_buffer, allocated to store the resulting text)."
msgstr ""
"4. El recuperador crea a continuación un control interno SysListView32 usado "
"como marcador de posición para almacenar el texto de la columna, después le "
"pide a Windows que le diga al proceso donde reside el texto de la columna "
"que revele el texto de columna de la columna especificada (primero se llama "
"a WriteProcessMemory, se envía un mensaje mediante la función SendMessage de "
"user32.dll para recuperar la longitud del texto, luego se usa "
"ReadProcessMemory para recuperar el texto real de la columna si hay algo que "
"leer). Una vez se ha revelado el texto de la columna, el recuperador "
"almacena el valor dentro del buffer de texto (ctypes.create_unicode_buffer, "
"reservado para almacenar el texto resultante)."

#: ..\python_docs\spladdoninternals.py:359
msgid ""
"5. Lastly, the retriever frees resources (VirtualFreeEx) and returns the "
"just retrieved column text, which can be used by routines requesting this."
msgstr ""
"5. Por último, el recuperador libera recursos (VirtualFreeEx) y devuelve el "
"texto de la columna recién recuperado, que puede ser usado por los "
"procedimientos que lo habían solicitado."

#: ..\python_docs\spladdoninternals.py:360
msgid "In 2018, this was simplified by use of SysListView32 routines directly."
msgstr ""
"En 2018, esto se simplificó usando directamente los procedimientos de "
"SysListView32."

#: ..\python_docs\spladdoninternals.py:361
msgid ""
"### Column retrieval and navigation routines: from hesitation to a "
"cornerstone"
msgstr ""
"### Recuperación de columnas y procedimientos de navegación: de la duda a la "
"piedra angular"

#: ..\python_docs\spladdoninternals.py:362
msgid ""
"Column content retrieval routine has become one of the cornerstones of the "
"Studio add-on. In addition to Track Dial, nine other routines uses it: "
"Column Search, track place marker, column announcement order, Track Columns "
"Explorer, vertical column navigation, playlist snapshots, playlist "
"transcripts, Creator and Track Tool app modules. Let's find out how seven of "
"these work in more detail (playlist snapshots and transcripts are described "
"under SPL Assistant section, as they deserve sections of their own)."
msgstr ""
"El procedimiento de recuperación del contenido de las columnas ha llegado a "
"ser una de las piedras angulares del complemento de Studio. Además del dial "
"de pista, otros nueve procedimientos lo usan: búsqueda por columnas, "
"marcador de posición de pista, verbalización del orden de columnas, "
"explorador de columnas de pista, navegación vertical por columnas, "
"instantáneas de listas de reproducción, transcripción de listas de "
"reproducción, y los módulo de aplicación de la herramienta de pista y de "
"Creator. Veamos cómo funcionan siete de ellos con más detalle (las "
"instantáneas de lista de reproducción y la transcripción de listas se "
"describen en la sección del asistente de SPL, aunque se merece una sección "
"propia)."

#: ..\python_docs\spladdoninternals.py:363
msgid "#### Track Dial: Navigating columns in track items"
msgstr "#### Dial de pista: navegación por columnas en elementos de pista"

#: ..\python_docs\spladdoninternals.py:364
msgid "Note: no longer applicable since 17.04, included here for completeness."
msgstr ""
"Nota: ya no es aplicable desde la versión 17.04, se incluye aquí por "
"completitud."

#: ..\python_docs\spladdoninternals.py:365
msgid ""
"The column retriever routine is just one of the activities performed during "
"Track Dial, and to see the beauty of this feature, assign a command to "
"toggle Track Dial (you need to focus on the track item before opening Input "
"Gestures dialog, as Track Dial is used by track items alone). Once you "
"assign a command to toggle Track Dial and toggle this on, Studio will set a "
"flag indicating that Track Dial is on, which causes left and right arrow "
"keys to be assigned to column navigation commands (this flag is stored as "
"part of the add-on configuration database). If you tell NVDA to play beeps "
"for status announcements (see previous chapter), NVDA will play a high beep. "
"Once you are done with Track Dial, press the just assigned command to turn "
"off Track Dial, at which point left and right arrow keys return to their "
"original functions, a low beep will be heard (if told to do so) and Track "
"Dial flag will be cleared."
msgstr ""
"El procedimiento de recuperación de columna es una de las actividades "
"realizadas durante el dial de pista, y para ver la belleza de esta "
"característica, asigna una orden para conmutar el dial de pista (debes poner "
"el foco en el elemento de pista antes de abrir el diálogo de gestos de "
"entrada, ya que el dial de pista sólo es usado por los elementos de pista). "
"Una vez asignes la orden para conmutar el dial de pista y lo actives, Studio "
"establecerá un indicador indicando que el dial de pista está activo, lo que "
"causa que las flechas izquierda y derecha se asignen a órdenes de navegación "
"de columna (este indicador se almacena como parte de la base de datos de "
"configuración del complemento). Si configuras NVDA para que reproduzca "
"pitidos para anunciar los cambios de estado (mira el capítulo anterior), "
"NVDA reproducirá un pitido agudo. Una vez acabes con el dial de pista, pulsa "
"la orden asignada para apagarlo. En este punto las flechas izquierda y "
"derecha volverán a ejercer sus funciones originales, se oirá un pitido grave "
"(si se configura NVDA para ello) y se eliminará el indicador del dial de "
"pista."

#: ..\python_docs\spladdoninternals.py:366
msgid ""
"When navigating columns, NVDA will check if you are at the edge of the track "
"row, and if so, it will play a beep and repeat the last column text. If not, "
"NVDA will look at the column you wish to navigate to (stored in the app "
"module), then it'll call the column text retriever to retrieve the column "
"text."
msgstr ""
"Al navegar por columnas, NVDA comprobará si te encuentras en el borde de la "
"fila de la pista, y si es así, reproducirá un pitido y repetirá el texto de "
"la última columna. Si no, NVDA mirará la columna a la que quieres navegar "
"(almacenada en el módulo de aplicación), después llamará al recuperador de "
"texto de columna para recuperar el texto de esa columna."

#: ..\python_docs\spladdoninternals.py:367
msgid ""
"To handle differences between Studio 5.0x and 5.1x, each track item class "
"informs NVDA as to how leftmost column should be handled. For Studio 5.0x, "
"leftmost column is artist field (obj.name will be checked), while track "
"checked status is \"shown\" in Studio 5.10 (obj.name will be announced)."
msgstr ""
"Para procesar las diferencias entre Studio 5.0x y 5.1x, cada clase de "
"elemento de pista informa a NVDA cómo debería procesarse la columna que hay "
"a la izquierda del todo. En Studio 5.0x, la columna más a la izquierda es el "
"campo artista (se comprobará obj.name), mientras que el estado de "
"verificación de la pista es el que se \"muestra\" en Studio 5.10 (se "
"verbalizará obj.name)."

#: ..\python_docs\spladdoninternals.py:368
msgid "#### Custom column announcement order: What to announce and how"
msgstr ""
"#### Orden personalizado de verbalización de columnas: qué anunciar y cómo"

#: ..\python_docs\spladdoninternals.py:369
msgid ""
"Track Dial routine also allowed another top request to come to life: column "
"announcement order. This allows you (broadcaster) to hear columns in "
"specific order and to exclude certain columns from being announced. This is "
"housed in reportFocus method in the main track item class."
msgstr ""
"El procedimiento del dial de pista también permitió dar vida a otra "
"solicitud: orden de verbalización de columnas. Esto te permite (locutor) oír "
"las columnas en un orden específico y excluir ciertas columnas para que no "
"sean verbalizadas. Esto se aloja en el método reportFocus en la clase "
"principal de elemento de pista."

#: ..\python_docs\spladdoninternals.py:370
msgid ""
"In order to use this, you must tell NVDA to not use screen order (add-on "
"settings dialog). Then open column announcement dialog and check the columns "
"you wish to hear, then use the columns list to set column announcement "
"order. The column announcement order is a list box with two buttons: move up "
"and down."
msgstr ""
"Para usarlo, hay que indicar a NVDA que no utilice el orden en pantalla "
"(diálogo de ajustes del complemento). A continuación abre el diálogo de "
"verbalización de columnas y marca las columnas que quieras oír, luego usa la "
"lista de columnas para configurar el orden de verbalización. El orden de "
"verbalización de columnas es un cuadro de lista con dos botones: mover "
"arriba y abajo."

#: ..\python_docs\spladdoninternals.py:371
msgid ""
"Once column order and included columns are defined, NVDA will use this "
"information to build track item description text. This is done by repeatedly "
"calling the column retriever routine for columns you wish to hear, then "
"using the column order you defined to build parts of the description text (a "
"combination of a list and str.join is used)."
msgstr ""
"Una vez se definen las columnas incluidas y el orden de las mismas, NVDA "
"usará esta información para construir el texto de descripción del elemento "
"de pista. Esto se hace llamando repetidamente al procedimiento recuperador "
"de columna en las columnas que quieres oír, y usando después el orden de "
"columnas que definiste para construir partes del texto de la descripción (se "
"usa una combinación de lista y str.join)."

#: ..\python_docs\spladdoninternals.py:372
msgid ""
"For example, if NVDA is told to announce title and artist (in that specific "
"order), NVDA will first locate title, then will add artist information. This "
"is then presented as, \"Title: some title, Artist: some artist\". It is also "
"possible to suppress announcement of column headers, and this is controlled "
"by the column header announcement checkbox in add-on settings."
msgstr ""
"Por ejemplo, si hacemos que NVDA anuncie el título y el artista (en ese "
"orden específico), NVDA primero ubicará el título, luego añadirá la "
"información del artista. Esto después se presentará como \"Título: algún "
"título, artista: algún artista\". Es posible eliminar la verbalización de "
"las cabeceras de columna, y esto se controla con la casilla de verificación "
"a tal efecto en los ajustes del complemento."

#: ..\python_docs\spladdoninternals.py:373
msgid "#### Track Columns Explorer: Retrieve information from specific columns"
msgstr ""
"#### Explorador de columnas de pista: recuperar información de columnas "
"específicas"

#: ..\python_docs\spladdoninternals.py:374
msgid ""
"In add-on 7.0, it became possible to let NVDA announce information from "
"specific columns. This is done by letting NVDA assign SPL Assistant, 1 "
"through 0 (6 for Studio 5.0x) to a function to obtain information from "
"specific column (slot); add-on 8.0 changes these commands to use Control+NVDA"
"+number row. This is called Track Columns Explorer (usually termed Coloumns "
"Explorer)."
msgstr ""
"En el complemento 7.0, apareció la posibilidad de de hacer que NVDA "
"verbalice información de columnas específicas. Esto se hace dejando a NVDA "
"que asigne al asistente de SPL, del 1 al 0 (6 para Studio 5.0x) una función "
"para obtener información de una columna específica (slot); el complemento "
"8.0 cambia estas órdenes para usar ctrl+NVDA+fila de números. Esto se llama "
"explorador de columnas de pista (generalmente conocido como explorador de "
"columnas)."

#: ..\python_docs\spladdoninternals.py:375
msgid ""
"In addition to using column retriever routine in Track Dial, Columns "
"Explorer needs to know Studio version in use, as Studio 5.1x shows columns "
"not found in Studio 5.0x (this is checked when entering SPL Assistant as "
"discussed later). Once column slots are defined, Columns Explorer performs "
"the following:"
msgstr ""
"Además de usar el procedimiento de recuperación de columna en el dial de "
"pista, el explorador de columnas necesita saber la versión de Studio en uso, "
"ya que Studio 5.1x muestra columnas que no están en Studio 5.0x (esto se "
"comprueba al entrar en el asistente de SPL, como se expondrá más tarde). Una "
"vez se definen los slots de columna, el explorador de columnas hace lo "
"siguiente:"

#: ..\python_docs\spladdoninternals.py:376
msgid ""
"1. Checks if you are indeed focused on a track item, and if not, it'll say "
"\"not a track\"."
msgstr ""
"1. Comprueba si tienes el foco en un elemento de lista y, si no es así, NVDA "
"dirá \"No es una pista\"."

#: ..\python_docs\spladdoninternals.py:377
msgid ""
"2. Consults a list of column slots and locates corresponding column index "
"for the slot in question."
msgstr ""
"2. Consulta una lista de slots de columna y ubica el índice de columna "
"correspondiente del slot en cuestión."

#: ..\python_docs\spladdoninternals.py:378
msgid ""
"3. Uses column retriever routine to announce column header and content for "
"the selected column slot."
msgstr ""
"3. Usa el procedimiento de recuperación de columna para verbalizar la "
"cabecera de la columna y el contenido de la columna del slot seleccionado."

#: ..\python_docs\spladdoninternals.py:379
msgid "##### Optimization bonus: I've rearranged columns in studio 5.10..."
msgstr ""
"##### Bonus de optimización: he reordenado las columnas en Studio 5.10..."

#: ..\python_docs\spladdoninternals.py:380
msgid ""
"Due to different control data structure in use, one can rearrange columns in "
"Studio 5.10 and later. But how does NVDA know exactly which column is which? "
"This is thanks to the fact that internal column position doesn't change. "
"When you rearrange columns, you are changing the way columns are presented "
"on screen. When column retriever function (described above) is invoked, "
"Studio returns column content for a column index regardless of where this "
"column is located on screen. Not only this makes Columns Explorer simpler to "
"implement, it allows Track Dial to track (after manual intervention) column "
"presentation changes on screen."
msgstr ""
"Debido a que hay diferentes estructuras de control de datos en uso, se "
"pueden reordenar columnas en Studio 5.10 y posteriores. ¿Pero cómo sabe NVDA "
"exactamente qué columna es cuál? Lo hace gracias al hecho de que la posición "
"interna de las columnas no cambia. Cuando reordenas columnas, estás "
"cambiando la forma en que estas se presentan en pantalla. Cuando se invoca a "
"la función de recuperación de columna (descrita arriba), Studio devuelve el "
"contenido de la columna dado un índice sin importar dónde se encuentra esa "
"columna en pantalla. Esto no sólo hace que la implementación del explorador "
"de columnas sea más simple, sino que permite al dial de pista rastrear "
"(después de una intervención manual) los cambios de presentación de las "
"columnas en pantalla."

#: ..\python_docs\spladdoninternals.py:381
msgid "#### Column Search: Finding text in specific columns"
msgstr "#### Búsqueda por columnas: encontrar texto en columnas específicas"

#: ..\python_docs\spladdoninternals.py:382
msgid ""
"In the previous section, I mentioned that a single dialog performs double "
"duty when talking about Track Finder. We'll now tour the other side of the "
"coin: Column Search."
msgstr ""
"En la sección anterior, mencioné que un único diálogo hace una doble función "
"cuando hablamos del buscador de pistas. Ahora recorreremos el otro lado de "
"la moneda: la búsqueda por columnas."

#: ..\python_docs\spladdoninternals.py:383
msgid ""
"Column Search dialog adds a second control to Track Finder: a list of "
"columns. Once text is entered to be searched in a column, NVDA will use "
"trackFinder routine (discussed earlier) to locate text in specific columns "
"(I mentioned that trackFinder routine takes column(s) as the argument, and "
"this is where this argument comes in handy). In fact, both regular Track "
"Finder and Column Search uses the above column retriever routine to locate "
"column text (the private linear search function introduced in Track Finder "
"2.0 locates text from specified columns, and for regular track finder, "
"artist and title columns are examined). Just like the regular Track Finder, "
"once search is done, it'll either move you to a track item or present an "
"error dialog."
msgstr ""
"El diálogo de búsqueda por columnas añade un segundo control al buscador de "
"pistas: una lista de columnas. Una vez se introduce el texto a buscar en una "
"columna, NVDA usará el procedimiento trackFinder (expuesto antes) para "
"ubicar texto en columnas específicas (he mencionado que el procedimiento "
"trackFinder recibe la(s) columnas(s) como un argumento, y aquí es donde el "
"argumento resulta útil). De hecho, tanto el buscador de pistas normal como "
"la búsqueda por columnas usan el procedimiento de recuperación de columnas "
"de arriba para ubicar el texto de la columna (la función privada de búsqueda "
"lineal introducida en el buscador de pistas 2.0 localiza texto de columnas "
"específicas, y en el buscador de pistas normal, se examinan las columnas "
"artista y título). Al igual que con el buscador de pistas normal, una vez se "
"ha hecho la búsqueda, se moverá el foco a un elemento de pista o bien se "
"presentará un diálogo de error."

#: ..\python_docs\spladdoninternals.py:384
msgid ""
"So what causes one dialog to present both Track Finder and Column Search "
"dialog? It's all thanks to the arguments passed into the find dialog "
"constructor. The signature is:"
msgstr ""
"Entonces, ¿qué causa que un diálogo presente tanto el buscador de pistas "
"como el buscador por columnas? Esto se hace gracias a los argumentos pasados "
"al constructor del diálogo de búsqueda. La cabecera es:"

#: ..\python_docs\spladdoninternals.py:385
msgid "\tsplmisc.SPLFindDialog(parent, obj, text, title, columnSearch=False)"
msgstr "\tsplmisc.SPLFindDialog(parent, obj, text, title, columnSearch=False)"

#: ..\python_docs\spladdoninternals.py:386
msgid ""
"The last argument (columnSearch) determines which version of the dialog to "
"present. The object (obj) is needed to tell NVDA where to begin the search "
"and to call the track finder routine defined in the object's app module."
msgstr ""
"El último argumento (columnSearch) determina la versión del diálogo que se "
"debe presentar. El objeto (obj) es necesario para decirle a NVDA dónde "
"empezar la búsqueda y para llamar al procedimiento del buscador de pistas "
"definido en su módulo de aplicación."

#: ..\python_docs\spladdoninternals.py:387
msgid ""
"#### Track Place Marker: A variation of column search for finding filenames"
msgstr ""
"#### Marcador de pista: una variante de la búsqueda por columnas para "
"encontrar nombres de archivo"

#: ..\python_docs\spladdoninternals.py:388
msgid ""
"Another feature that uses column routines is track place marker. You would "
"drop a place marker at the current track (SPL Assistant, Control+K), move "
"around the playlist, then move to the track with the marker set on it (SPL "
"Assistant, K)."
msgstr ""
"Otra característica que usa los procedimientos de columna es el marcador de "
"pista. Tú pondrías un marcador en la pista actual (asistente de SPL, ctrl"
"+k), te moverías por la lista de reproducción, y después te moverías a la "
"pista que tiene el marcador (asistente de SPL, k)."

#: ..\python_docs\spladdoninternals.py:389
msgid ""
"Once you drop a place marker, Studio app module will record the filename of "
"the currently focused track, and when you wish to move to the marked track, "
"NVDA will use column search routine to locate it. Unlike a typical column "
"search, NVDA will call the private linear search routine directly and will "
"select the column where filename is stored (in effect, you are asking NvDA "
"to do a column search after choosing filename as the data you are looking "
"for)."
msgstr ""
"Una vez sitúes un marcador, el módulo de aplicación de Studio registrará el "
"nombre del archivo de la pista que tenga actualmente el foco, y cuando "
"quieras moverte a la pista marcada, NVDA usará el procedimiento de búsqueda "
"en columnas para encontrarla. Al contrario que pasa con las búsquedas por "
"columna típicas, NVDA llamará a la función privada de búsqueda lineal "
"directamente y seleccionará la columna donde se encuentre el nombre del "
"archivo (en efecto, le estás diciendo a NVDA que haga una búsqueda por "
"columnas después de elegir nombre de archivo como dato a buscar)."

#: ..\python_docs\spladdoninternals.py:390
msgid "#### Vertical column navigation: just announce the column I want"
msgstr ""
"#### Navegación vertical por columnas: verbalizar sólo la columna que quiero"

#: ..\python_docs\spladdoninternals.py:391
msgid ""
"Ever since implementing Track Dial, some broadcasters requested adding "
"support for moving through tracks vertically (as in reading specific columns "
"just like moving to a different row in a table). This also resolved an issue "
"where pressing Control+Alt+up/down arrow keys caused the monitor to flip "
"upside down. This is achieved by asking SPLTrackItem.reportFocus to announce "
"just the column the user wants when Control+Alt+up/down arrow is pressed, "
"all controlled by a hidden class variable. This feature not only works for "
"vertical column navigation - it is also used when a broadcaster requests "
"only one column be announced, and the column to be announced can be customed "
"(not to be confused with column announcement order routine discussed above)."
msgstr ""
"Desde que se implementó el dial de pista, algunos locutores solicitaron "
"añadir soporte para moverse verticalmente por las pistas (como leer columnas "
"específicas pero moviéndose a una fila diferente como en una tabla). Esto "
"también resolvió un problema por el que al pulsar las teclas ctrl+alt"
"+flechas arriba y abajo causaba que el monitor diera vueltas. Esto se hace "
"pidiéndole a SPLTrackItem.reportFocus que verbalice la columna que el "
"usuario quiere al pulsar ctrl+alt+flechas arriba y abajo, todo controlado "
"por una variable de clase oculta. Esta característica no sólo funciona con "
"la navegación vertical de columnas - también se usa cuando un locutor "
"solicita que sólo se anuncie una columna, y la columna a ser verbalizada "
"puede personalizarse (no hay que confundirse con el procedimiento de orden "
"de verbalización de columnas expuesto arriba)."

#: ..\python_docs\spladdoninternals.py:392
#, fuzzy
#| msgid "#### Track Tool: one routine, multiple app modules"
msgid "#### Track Tool and Creator: one routine, multiple app modules"
msgstr ""
"#### Herramienta de pista: un procedimiento, múltiples módulos de aplicación"

#: ..\python_docs\spladdoninternals.py:393
#, fuzzy
#| msgid ""
#| "Column retriever routine is not only employed by Studio app module, but "
#| "is also used in Track Tool app module (part of the studio add-on). Track "
#| "Tool's use of column retriever include Track Dial for Track Tool (same "
#| "routine as the Studio app module and Studio must be running to use it) "
#| "and announcing column information (Control+NVDA+1  through 0, now termed "
#| "Columns Explorer for Track Tool)."
msgid ""
"Column retriever routine is not only employed by Studio app module, but is "
"also used in Track Tool and Creator app modules (part of the studio add-on). "
"These app modules (specifically, track item classes) uses column retriever "
"for reviewing column data via table navigation commands and announcing "
"column information (Control+NVDA+1  through 0, now termed Columns Explorer "
"for Track Tool/SPL Creator)."
msgstr ""
"El procedimiento de recuperación de columnas no sólo se emplea en el módulo "
"de aplicación de Studio, sino que también se usa en el módulo de aplicación "
"de la herramienta de pista (parte del complemento de Studio). El uso que "
"hace la herramienta de pista del recuperador de columnas incluye el dial de "
"pista para la herramienta de pista (mismo procedimiento que en el módulo de "
"aplicación de Studio y Studio debe estar ejecutándose para usarlo) y "
"verbalización información de columnas (ctrl+NVDA+1 a 0, ahora llamado "
"explorador de columnas para la herramienta de pista)."

#: ..\python_docs\spladdoninternals.py:394
#: ..\python_docs\spladdoninternals.py:481
msgid "### Few remarks"
msgstr "### Unas pocas notas"

#: ..\python_docs\spladdoninternals.py:395
msgid ""
"Of all the features in the StationPlaylist Studio add-on, column navigation "
"is one of my favorites (besides Cart Explorer and encoder support and "
"others). I enjoyed working with this routine and learned a few things about "
"Windows API, as well as open possibilities not previously explorered before, "
"such as Track Tool and Column Search. I hope that you'll find column "
"navigation commands to be useful in your broadcasts."
msgstr ""
"De todas las características del complemento de StationPlaylist Studio, la "
"navegación por columnas es una de mis favoritas (además del explorador cart, "
"y el soporte para el codificador, y otras). Disfruté trabajando con este "
"procedimiento y aprendí unas pocas cosas sobre la api de Windows, así como "
"abrí posibilidades que no se habían explorado antes, como la herramienta de "
"pista o la búsqueda por columnas. Espero que encuentres útiles las órdenes "
"de navegación por columnas en tus emisiones."

#: ..\python_docs\spladdoninternals.py:396
msgid ""
"I would like to take this time to answer a question posed by some users and "
"developers: Can NVDA be ported to other operating systems? No. The above "
"column retriever routine is a prime example why this cannot be done easily: "
"different operating systems use different API's, and porting NonVisual "
"Desktop Access to other operating systems will involve significant "
"architectural changes to use the new API's. In case of ReactOS, this isn't "
"possible, as there are no stable foundation from which NVDA screen reader "
"can exercise its full rights: accessibility API's are needed, stable driver "
"development framework is needed, ability to run a program as a service must "
"be ready and so on. Add to the fact that we have several add-ons relying on "
"Windows API (including StationPlaylist Studio add-on) and you'll see the "
"huge work involved in an attempt to port NVDA to other operating systems."
msgstr ""
"Me gustaría aprovechar para responder una pregunta realizada por algunos "
"usuarios y desarrolladores: ¿puede llevarse NVDA a otros sistemas "
"operativos? No. El procedimiento de recuperación de columnas de arriba es un "
"buen ejemplo de por qué no puede hacerse esto fácilmente: los diferentes "
"sistemas operativos usan apis distintas, y llevar NVDA a otros sistemas "
"operativos implicaría cambios significativos de la arquitectura para usar "
"las nuevas apis. En el caso de ReactOS, no es posible, ya que no hay una "
"base estable sobre la que NVDA pueda ejercer completamente todos sus "
"derechos: hacen falta apis de accesibilidad, hace falta un marco de trabajo "
"estable para el desarrollo de controladores, debe estar lista la capacidad "
"de ejecutar un programa como servicio y muchas otras cosas. A eso añadimos "
"el hecho de que tenemos varios complementos que se apoyan en la api de "
"Windows (incluyendo el complemento para StationPlaylist Studio). Te "
"imaginarás el enorme trabajo que implica intentar llevar NVDA a otros "
"sistemas operativos."

#: ..\python_docs\spladdoninternals.py:397
msgid "## Microphone alarm and library scan: threads, threads and more threads"
msgstr ""
"## Alarma del micrófono y escaneo de biblioteca: hilos, hilos y más hilos"

#: ..\python_docs\spladdoninternals.py:398
msgid ""
"Of all the work done on Studio add-on, one of them stands out the most: "
"background tasks. I spent many hours and months perfecting this concept, "
"read documentation on this feature and learned a lot through this "
"experience. Today, this work is used in various parts of the Studio app "
"module and beyond, and we'll take a look at two most important result of "
"this work: library scan and microphone alarm."
msgstr ""
"De todos los trabajos hechos en el complemento de Studio, uno de ellos "
"destaca sobre los demás: las tareas en segundo plano. Invertí muchas horas y "
"meses perfeccionando este concepto, leí documentación sobre esta "
"característica y aprendí un montón a través de esta experiencia. Hoy, se "
"emplea este trabajo en diversas partes del módulo de aplicación de Studio y "
"más allá, y echaremos un vistazo a dos resultados de los más importantes de "
"este trabajo: el escaneo de biblioteca y la alarma del micrófono."

#: ..\python_docs\spladdoninternals.py:399
msgid "### Brief feature overview"
msgstr "### Breve descripción de las características"

#: ..\python_docs\spladdoninternals.py:400
msgid ""
"When you are producing a live show, you may forget that your microphone is "
"active. The microphone alarm feature lets NVDA notify you if microphone has "
"been active for a while. This happens even if you are using another program."
msgstr ""
"Cuando estás haciendo un programa en directo, puedes olvidarte de que el "
"micrófono está activo. La característica de alarma de micrófono hace que "
"NVDA pueda notificarte si el micrófono ha estado activado durante un rato. "
"Esto sucede incluso si estás utilizando otro programa."

#: ..\python_docs\spladdoninternals.py:401
msgid ""
"Library scan comes in handy when you want to see the progress of a "
"background library scan. Typically, you would initiate library scans from "
"Insert Tracks dialog (press Control+Shift+R). NVDA will then tell you how "
"the scan is going, and if you close Insert Tracks dialog, NVDA will continue "
"to monitor library scans in the background."
msgstr ""
"El escaneo de biblioteca viene bien cuando quieres ver el progreso de un "
"escaneo de biblioteca en segundo plano. Normalmente, iniciarías los escaneos "
"de biblioteca desde el diálogo de inserción de pistas (pulsa ctrl+shift+r). "
"NVDA te dirá entonces cómo va el escaneo, y si cierras el diálogo de "
"inserción de pistas, NVDA continuará monitorizando el escaneo de la "
"biblioteca en segundo plano."

#: ..\python_docs\spladdoninternals.py:402
msgid ""
"But there's more to it than a simple description when it comes to looking at "
"internals of these features. As you'll see, these features use a concept "
"that is gaining traction: running multiple tasks at once, or at least try to "
"emulate it. We'll visit this concept first before returning to our regularly "
"scheduled program of describing the internals of the two features above."
msgstr ""
"Pero hay mucho más que una simple descripción cuando llega el momento de "
"mirar en el interior de estas características. Como verás, estas funciones "
"usan un concepto que está ganando fuerza: ejecutar múltiples tareas a la "
"vez, o al menos intentar emularlo. Visitaremos este concepto primero antes "
"de volver a nuestro programa original de describir el interior de las dos "
"características de arriba."

#: ..\python_docs\spladdoninternals.py:403
msgid ""
"### Recent trends in computing: more and more processors in a single computer"
msgstr ""
"### Tendencias recientes en computación: más y más procesadores en un único "
"ordenador"

#: ..\python_docs\spladdoninternals.py:404
msgid ""
"A decade ago, people thought a single core CPU was enough to run multiple "
"programs. This involved the processor spending small fraction of a second "
"devoted to each program. Nowadays, it has become common to see desktops, "
"laptops, smartphones and other small devices using at least two cores "
"(termed multi-core; two cores is dubbed \"dual core\"). As of 2017, many "
"computers use processors with four cores (dubbed \"quad core\"), while "
"enthusiasts prefer more cores (the current record holder for desktop "
"computers (as of July 2017) is 18, held by Intel Core I9-7980XE, a 3 GHz "
"unlocked processor which costs 2000 dollars; for servers where more cores "
"are used, the current record holder is a group of eight processors (octa "
"processor) called Intel Xeon E7-8895V3, with each processor boasting "
"eighteen cores with base speed of 2.6 GHz)."
msgstr ""
"Hace una década, la gente pensaba que que una CPU de un único núcleo era "
"suficiente para ejecutar múltiples programas. Esto implicaba que el "
"procesador invertía una pequeña fracción de segundo exclusivamente a cada "
"programa. Hoy en día, es común ver ordenadores de sobremesa, portátiles, "
"smartphones y otros pequeños dispositivos que tienen al menos dos núcleos "
"(llamados multi-core; con dos núcleos se llama \"dual core\"). En 2017, "
"muchos ordenadores disponen de procesadores con cuatro núcleos (llamados "
"\"quad core\"), mientras que los entusiastas prefieren más núcleos (el "
"récord actual para ordenadores de sobremesa (en julio de 2017) es 18, y lo "
"tiene el Intel Core i9-7980XE, un procesador desbloqueado con 3 GHZ que "
"cuesta 2000 dólares; en los servidores donde se usan más núcleos, el récord "
"actual lo tiene un grupo de ocho procesadores (octa processor) llamado Intel "
"Xeon e7-8895v3, cada procesador con dieciocho núcleos con una velocidad base "
"de 2.6 GHZ)."

#: ..\python_docs\spladdoninternals.py:405
msgid ""
"Despite the fact that many computers come equipped with multi-core "
"processors, not all programs take advantage of this. Python interpreter is "
"one of those programs, and since NVDA is a Python-based screen reader and "
"due to its operational architecture, many of its operations cannot take "
"advantage of multiple processors. Fortunately, Python provides a way to "
"simulate this - run certain tasks in the background, and this is utilized by "
"NVDA and some of its add-ons as you'll see in this article on library scan "
"and microphone alarm."
msgstr ""
"A pesar del hecho de que muchos ordenadores vienen equipados con "
"procesadores de múltiples núcleos, no todos los programas aprovechan las "
"ventajas de esto. El intérprete Python es uno de esos programas, y ya que "
"NVDA es un lector de pantalla basado en Python y debido a su arquitectura "
"operativa, muchas operaciones no pueden aprovechar la ventaja de tener "
"múltiples procesadores. Por suerte, Python proporciona una manera de simular "
"esto - ciertas tareas en segundo plano, que tanto NVDA como algunos "
"complementos utilizan como podrás comprobar en este artículo sobre el "
"escaneo de la biblioteca y la alarma del micrófono."

#: ..\python_docs\spladdoninternals.py:406
msgid "### A gentle introduction to threads: multiple tasks at once"
msgstr "### Una introducción suave a los hilos: varias tareas a la vez"

#: ..\python_docs\spladdoninternals.py:407
msgid ""
"During normal business hours, a program will run from beginning to end with "
"some interuptions (keyboard input, switching to a different part of the "
"program and so on). However, there are times when the program will need to "
"work with many things simultaneously, such as calculating distance between "
"many points, adding multiple numbers at once, comparing many pairs of "
"strings and so on. Fortunately, a mechanism called threads allow a program "
"to do multiple things simultaneously."
msgstr ""
"Durante las horas laborables, un programa se ejecutará de principio a fin "
"con algunas interrupciones (entrada por teclado, cambiar a una zona "
"diferente del programa y demás). Sin embargo, hay veces en las que el "
"programa necesitará trabajar con muchas cosas simultáneamente, como calcular "
"la distancia entre muchos puntos, sumar varios números a la vez, comparar "
"muchos pares de cadenas y demás. Por suerte, un mecanismo llamado hilos "
"permite que un programa haga muchas cosas simultáneamente."

#: ..\python_docs\spladdoninternals.py:408
msgid ""
"A thread is a procedure independent of other tasks. If one thread is busy "
"with something, other threads can work on other tasks. The best analogy is "
"multiple bank tellers in a bank: customers can talk to different tellers, "
"with one teller working on updating customer records for a customer while "
"another customer discusses fraudulent credit card charges with a different "
"teller."
msgstr ""
"Un hilo es un procedimiento independiente de otras tareas. Si un hilo está "
"ocupado con algo, otros hilos pueden trabajar en otras tareas. La mejor "
"analogía es varios banqueros en un banco: los clientes pueden hablar con "
"diferentes banqueros, con un banquero actualizando los registros de un "
"cliente mientras otro cliente discute sobre cargos en la tarjeta de crédito "
"fraudulentos con otro banquero."

#: ..\python_docs\spladdoninternals.py:409
msgid ""
"A thread can be involved with parts of a task, devoted to a single task or "
"multiple tasks. For example, an antivirus program could have multiple "
"threads (workers) working independently of each other. One worker can "
"display the overall progress of a scan, while other threads can scan "
"multiple drives at once, with each thread devoted to scanning files and "
"folders on separate drives. In NVDA world, multiple workers are involved to "
"perform various tasks, including making sure NVDA is responsive, handling "
"browse mode in different web browsers and so on."
msgstr ""
"Un hilo puede implicarse en partes de una tarea, dedicarse a una tarea única "
"o varias tareas. Por ejemplo, un programa antivirus podría tener varios "
"hilos (trabajadores) trabajando independientemente unos de otros. Un "
"trabajador puede mostrar el progreso general de un análisis, mientras que "
"otros hilos pueden analizar varias unidades a la vez, donde cada hilo se "
"dedica a analizar exclusivamente los archivos y carpetas de una unidad. En "
"el mundo de NVDA, varios trabajadores están implicados en llevar a cabo "
"diversas tareas, incluyendo asegurarse de que NVDA está adaptado, procesar "
"el modo exploración en distintos navegadores web y demás."

#: ..\python_docs\spladdoninternals.py:410
msgid "### Threads: a more geeky introduction"
msgstr "### Hilos: una introducción más jeek"

#: ..\python_docs\spladdoninternals.py:411
msgid ""
"A thread (sometimes termed \"thread of execution) is an independent path of "
"execution. A single process (app) can have as many threads as it desires "
"(minimum is one for the main thread). Each thread can be asked to perform "
"certain operations with other threads in parallel, which can range from a "
"single, repetative task (part of a function) to being responsible for an "
"entire module or a significant part of the program. In case of antivirus "
"example above, each scanner thread is responsible for scanning an entire "
"drive, with each of them reporting its progress to a manager thread which "
"displays overall progress of a virus scan."
msgstr ""
"Un hilo (a veces llamado \"hilo de ejecución\") es un camino independiente "
"de ejecución. Un único proceso (aplicación) puede tener tantos hilos como "
"desee (el mínimo es uno para el hilo principal). Se puede pedir a cada hilo "
"que haga ciertas operaciones con otros hilos en paralelo, que pueden variar "
"desde una única tarea repetitiva (parte de una función) hasta ser "
"responsables de un módulo entero o una parte significativa del programa. En "
"el ejemplo anterior del antivirus, cada hilo del analizador es responsable "
"de analizar una unidad entera, y cada uno informa su progreso a un hilo "
"administrador que muestra el progreso total del análisis de virus."

#: ..\python_docs\spladdoninternals.py:412
msgid ""
"Using threads means each thread can execute on a processor core on a multi-"
"core system. Because of this, many people would want many programs to take "
"advantage of this and finish their jobs faster. However, threads introduce "
"disadvantages, namely many days spent designing careful coordination "
"routines between threads, preventing attempts by multiple threads to change "
"a critical value that a manager thread depends on (called race condition) "
"and so forth."
msgstr ""
"Usar hilos significa que cada hilo puede ejecutarse en un núcleo del "
"procesador en un sistema multinúcleo. Por este motivo, mucha gente querría "
"que muchos programas aprovecharan las ventajas de esta tecnología y "
"finalizaran sus trabajos más rápido. Sin embargo, los hilos presentan "
"desventajas, normalmente muchos días invertidos en diseñar cuidadosamente "
"procedimientos de coordinación entre hilos, evitar intentos de múltiples "
"hilos para que no intenten cambiar un valor crítico del que depende un hilo "
"gestor (fallo conocido como condición de carrera) y demás."

#: ..\python_docs\spladdoninternals.py:413
msgid "### Python's way of managing threads and the threading module"
msgstr ""
"### El módulo threading y la forma que tiene Python de gestionar los hilos"

#: ..\python_docs\spladdoninternals.py:414
msgid ""
"Python interpreter (and programs which uses them, including NVDA) is not "
"exactly multithreaded. Because of internal issues, Python uses so-called "
"global interpreter lock to prevent multiple threads from messing with each "
"other. One way to bring true parallelism in Python is use of multiprocessing "
"module (multiple Python interpreters, each one devoted to a single task), "
"which has its own advantages and drawbacks (NVDA does not ship with "
"multiprocessing module in the first place)."
msgstr ""
"El intérprete Python (y los programas que lo usan, incluido NVDA) no es "
"exactamente multihilo. Debido a problemas internos, Python usa algo llamado "
"bloqueo global del intérprete para evitar que varios hilos tengan conflictos "
"entre sí. Una forma de traer el paralelismo real a Python es usar el módulo "
"multiprocessing (varios intérpretes Python, cada uno dedicado a una tarea), "
"que tiene sus propias ventajas y desventajas (la primera, que NVDA no viene "
"con el módulo multiprocessing integrado)."

#: ..\python_docs\spladdoninternals.py:415
msgid ""
"To manage threads, Python programs (including NVDA) use Python's threading "
"module. This library includes various ways of managing threads, including "
"defining which function can execute in a separate thread, coordinating "
"sharing of information between threads (locks, semaphores (resource access "
"counter) and so on), and letting a thread run its task after waiting for a "
"while (called timers). Even with multiple threads defined, NVDA is mostly "
"single-threaded (serial execution)."
msgstr ""
"Para gestionar hilos, los programas en Python (incluido NVDA) usan el módulo "
"threading de Python. Esta biblioteca incluye varias formas de gestionar "
"hilos, incluida la de definir qué función se ejecutará en un hilo separado, "
"coordinación de la información compartida entre hilos (cerrojos, semáforos "
"(contador de accesos al recurso) y demás), y dejar que un hilo ejecute su "
"tarea tras esperar un rato (temporizadores). Incluso con varios hilos "
"definidos, NVDA es mayoritariamente de un solo hilo (ejecución en serie)."

#: ..\python_docs\spladdoninternals.py:416
msgid ""
"To use threads, a programmer will define the thread type (regular thread, "
"timer and so on), define some properties and tell the thread which routine "
"to execute. Once the thread is defined, the start (thread.start) method is "
"called to let the thread do its work."
msgstr ""
"Para usar hilos, un programador definirá el tipo de hilo (hilo regular, "
"temporizador y demás), definirá algunas propiedades e indicará al hilo qué "
"procedimiento debe ejecutar. Una vez el hilo está definido, se llama al "
"método de inicio (thread.start) para hacer que el hilo haga su trabajo."

#: ..\python_docs\spladdoninternals.py:417
msgid "### Threads in Studio app module"
msgstr "### Hilos en el módulo de aplicación de Studio"

#: ..\python_docs\spladdoninternals.py:418
msgid ""
"For the most part, Studio app module uses only one thread (NVDA's main "
"thread) to do its job. However, there are times when multiple threads are "
"used - up to three can be active at a time: NVDA's main thread (announcing "
"status changes, alarms, Cart Explorer and others), microphone alarm (a "
"timer) and library scan (a background thread). Another situation threads are "
"used is when background encoder monitoring is enabled (see the encoder "
"routines article for details and use of threads there)."
msgstr ""
"La mayoría del módulo de aplicación de Studio usa sólo un hilo (el hilo "
"principal de NVDA) para hacer su trabajo. Sin embargo, hay veces en que se "
"usan varios hilos - puede haber hasta tres hilos activos al mismo tiempo: el "
"hilo principal de NVDA (anunciando cambios de estado, alarmas, explorador "
"cart y otras funciones), la alarma del micrófono (un temporizador) y el "
"escaneo de biblioteca (un hilo en segundo plano). Otra situación en la que "
"se usan hilos es cuando está activada la monitorización en segundo plano del "
"codificador (mira el artículo de procedimientos del codificador para más "
"detalles y uso de hilos allí)."

#: ..\python_docs\spladdoninternals.py:419
msgid ""
"The main reason for using threads is to prevent background tasks from "
"blocking user input (commands will not work when a long running task is run "
"from the main NVDA thread). This is more noticeable when library scan is "
"active as you'll find out soon. For now, let's take a look at microphone "
"alarm."
msgstr ""
"El motivo principal para usar hilos es evitar que las tareas en segundo "
"plano bloqueen la entrada de usuario (las órdenes no funcionarán cuando una "
"tarea que tarda mucho en ejecutarse lo haga desde el hilo principal de "
"NVDA). Esto es más perceptible cuando el escaneo de biblioteca está activo, "
"como podrás comprobar pronto. Por ahora, echemos un vistazo a la alarma del "
"micrófono."

#: ..\python_docs\spladdoninternals.py:420
msgid "#### Microphone alarm: A timer duo waiting to do their work"
msgstr ""
"#### Alarma del micrófono: un dúo de temporizadores esperando para hacer su "
"trabajo"

#: ..\python_docs\spladdoninternals.py:421
msgid ""
"Simply put, microphone alarm is a timer (akin to a countdown timer). When "
"the microphone becomes active, Studio app module will tell a timer thread to "
"come alive. This timer's only job is to play the alarm sound and display a "
"warning message, and it will wait a while (microphone alarm value in "
"seconds; for example, five seconds)."
msgstr ""
"En pocas palabras, la alarma de micrófono es un temporizador (un "
"temporizador de cuenta atrás). Cuando el micrófono se pone activo, el módulo "
"de aplicación de Studio hará que un hilo temporizador venga a la vida. La "
"única misión de este temporizador es reproducir el sonido de alarma y "
"mostrar un mensaje de aviso, y esperará un rato (valor de la alarma del "
"micrófono en segundos; por ejemplo, cinco segundos)."

#: ..\python_docs\spladdoninternals.py:422
msgid "The master switch which flips the microphone alarm timer is:"
msgstr ""
"El interruptor maestro que hace girar al temporizador de la alarma del "
"micrófono es:"

#: ..\python_docs\spladdoninternals.py:423
msgid ""
"alarm = threading.Timer(micAlarm, messageSound, args=[micAlarmWav, "
"micAlarmMessage])"
msgstr ""
"alarm = threading.Timer(micAlarm, messageSound, args=[micAlarmWav, "
"micAlarmMessage])"

#: ..\python_docs\spladdoninternals.py:424
msgid ""
"Where \"micAlarm\" denotes how long this timer will wait and the second "
"argument is the task to be performed (messageSound function). If microphone "
"alarm is off (value is 0), this switch will be left alone forever (turned "
"off until you enable the alarm by specifying a value above 0)."
msgstr ""
"Donde \"micAlarm\" indica cuánto tiempo esperará el temporizador y el "
"segundo argumento es la tarea a realizar (función messageSound). Si la "
"alarma del micrófono está apagada (su valor es 0), este interruptor quedará "
"solo para siempre (apagado hasta que actives la alarma especificando un "
"valor superior a 0)."

#: ..\python_docs\spladdoninternals.py:425
msgid ""
"However, microphone alarm is more than a timer: a unique feature of timers "
"is responding to events (a cancel event, that is). When the microphone "
"becomes active, microphone alarm timer will become active. If you happen to "
"turn off your microphone before microphone alarm kicks in, NVDA instructs "
"microphone alarm to quit (timer is canceled). In other words, the \"real\" "
"master switch is status change, and one of the activities performed by name "
"change event handler (event_nameChange function described earlier) is to "
"manage microphone alarm timer via doExtraAction method (in fact, microphone "
"alarm and Cart Explorer are managed from this function)."
msgstr ""
"Sin embargo, la alarma del micrófono es más que un temporizador: una función "
"única de los temporizadores es responder a eventos (un evento de "
"cancelación). Cuando el micrófono se activa, el temporizador de la alarma "
"del micrófono se activará con él. Si apagas el micrófono antes de que la "
"alarma del micrófono salte, NVDA ordena a la alarma del micrófono que salga "
"(se cancela el temporizador). En otras palabras, el interruptor maestro "
"\"real\" es el cambio de estado, y una de las actividades que el manejador "
"de evento de cambio de nombre (función event_nameChange descrita "
"anteriormente) realiza es la de gestionar el temporizador de la alarma del "
"micrófono mediante el método doExtraAction (de hecho, la alarma del "
"micrófono y el explorador cart se gestionan desde esta función)."

#: ..\python_docs\spladdoninternals.py:426
msgid ""
"In some cases, NVDA can be told to periodically notify you that microphone "
"is active. If this is the case, NVDA will start a new timer (this time, wx."
"PyTimer) that'll run a function to do just that periodically after the "
"initial microphone alarm is sounded. Just like the master microphone alarm "
"timer, this time will quit if microphone is turned off."
msgstr ""
"En algunos casos, podemos decirle a NVDA que nos avise periódicamente de que "
"el micrófono está activo. Si este es el caso, NVDA iniciará un nuevo "
"temporizador (esta vez, wx.PyTimer) que ejecutará una función para hacerlo "
"periódicamente después de que suene la primera alarma de micrófono. Al igual "
"que con el temporizador maestro de alarma, este temporizador también se "
"detendrá si el micrófono se apaga."

#: ..\python_docs\spladdoninternals.py:427
msgid ""
"#### Library scan: a unique combination of Studio API and a background thread"
msgstr ""
"#### Escaneo de biblioteca: una combinación única de la api de Studio y un "
"hilo en segundo plano"

#: ..\python_docs\spladdoninternals.py:428
msgid ""
"When NVDA is told to keep an eye on background library scanning, it calls up "
"another thread to perform this duty. This thread will ask Studio for number "
"of items scanned so far and take appropriate action after scanning is "
"complete (in fact, multiple helper functions are used)."
msgstr ""
"Al decirle a NVDA que mantenga vigilado el escaneo de biblioteca en segundo "
"plano, este llama a otro hilo para hacer esta tarea. Este hilo le preguntará "
"a Studio por el número de elementos escaneados hasta ahora y tomará las "
"medidas adecuadas en cuanto el escaneo se complete (de hecho, se usan varias "
"funciones auxiliares)."

#: ..\python_docs\spladdoninternals.py:429
msgid "The library scan routine is performed as follows:"
msgstr "El procedimiento de escaneo de biblioteca es el siguiente:"

#: ..\python_docs\spladdoninternals.py:430
msgid ""
"1. NVDA will make sure you are not in Insert Tracks dialog (if you are, "
"background library scan routine will not be invoked, as event_nameChange "
"will perform this duty instead)."
msgstr ""
"1. NVDA se asegurará de que no estés en el diálogo de inserción de pistas "
"(si estás ahí, no se invocará el procedimiento de escaneo de la biblioteca "
"en segundo plano, ya que event_nameChange hará lo mismo en su lugar)."

#: ..\python_docs\spladdoninternals.py:431
msgid ""
"2. If you do close Insert Tracks while a scan is in progress, or invoke "
"library scan from SPL Assistant (Shift+R), NVDA will instruct a thread to "
"keep an eye on scan progress in the background(see below for signature) to "
"allow you to use Studio commands and to let you hear scan progress from "
"other programs."
msgstr ""
"2. Si cierras el diálogo de insertar pistas mientras hay un escaneo en "
"progreso, o invocas el escaneo de biblioteca desde el asistente de SPL (shift"
"+r), NVDA ordenará que un hilo vigile el progreso del escaneo en segundo "
"plano (mira abajo la cabecera) para permitirte usar órdenes de Studio y "
"dejarte oír el progreso del escaneo desde otros programas."

#: ..\python_docs\spladdoninternals.py:432
msgid ""
"3. Library scan thread will ask Studio to return number of items scanned "
"(this is done every second) and will store the result for record keeping."
msgstr ""
"3. El hilo de escaneo de biblioteca pedirá a Studio que le devuelva el "
"número de elementos escaneados (lo hace cada segundo) y almacenará el "
"resultado para llevar un registro."

#: ..\python_docs\spladdoninternals.py:433
msgid ""
"4. After the scan result is obtained, the thread will check where you are in "
"studio, and if you are back in Insert Tracks dialog, the thread will "
"terminate (see step 1)."
msgstr ""
"4. Después de obtener el resultado del escaneo, el hilo comprobará en qué "
"parte de Studio estás, y si te encuentras de vuelta en el diálogo de "
"inserción de pistas, el hilo finalizará (mira el paso 1)."

#: ..\python_docs\spladdoninternals.py:434
msgid ""
"5. Every five seconds, library scan thread will call a private function "
"(which wants to see how many items were scanned and current library scan "
"announcement setting) to announce library scan results as follows:"
msgstr ""
"5. Cada cinco segundos, el hilo de escaneo de biblioteca llamará a una "
"función privada (que quiere ver cuántos elementos se han escaneado y el "
"ajuste actual de verbalización de escaneo de biblioteca) para anunciar los "
"resultados del escaneo de la biblioteca de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:435
msgid ""
"A. If you tell NVDA to announce scan progress, NVDA will say, \"scanning\" "
"and/or play a beep (if told to do so)."
msgstr ""
"A. Si le pides a NVDA que verbalice el progreso del escaneo, este dirá "
"\"Escaneando\" y / o reproducirá un pitido (si así lo tiene indicado)."

#: ..\python_docs\spladdoninternals.py:436
msgid ""
"B. If NVDA is told to announce scan count, number of items scanned so far "
"will be announced (again with or without a beep)."
msgstr ""
"B. Si se pide a NVDA que verbalice la cantidad de elementos escaneados, se "
"verbalizarán los que se han analizado hasta ahora (otra vez con o sin "
"pitido)."

#: ..\python_docs\spladdoninternals.py:437
msgid ""
"C. This reporter function will not be invoked if you tell NVDA to ignore "
"library scan completely or ask it to interupt you only when the overall scan "
"is complete (you can press Alt+NVDA+R to cycle through different library "
"scan announcement settings)."
msgstr ""
"C. No se invocará a esta función informadora si le dices a NVDA que ignore "
"el escaneo de biblioteca completamente o le pides que te interrumpa sólo "
"cuando el escaneo general se haya completado (puedes pulsar alt+NVDA+r para "
"cambiar rápidamente entre los diferentes ajustes de verbalización de escaneo "
"de biblioteca)."

#: ..\python_docs\spladdoninternals.py:438
msgid ""
"6. Once library scanning is complete (after checking scan result value every "
"second and seeing that the previous scan result and the current one have "
"same values), NVDA will announce scan results (in some cases, number of "
"items scanned will be announced). In Studio 5.10 and later, the library scan "
"counter will not be defined when scan completes, which is more efficient "
"than keeping track of equalities."
msgstr ""
"6. Una vez el escaneo de la biblioteca se completa (después de comprobar el "
"valor del resultado cada segundo y ver que el resultado del escaneo anterior "
"y el actual tienen el mismo valor), NVDA verbalizará los resultados del "
"escaneo (en algunos casos, se verbalizará el número de elementos "
"escaneados). En Studio 5.10 y versiones posteriores, el contador del escaneo "
"de la biblioteca no estará definido cuando el escaneo se complete, lo que es "
"más eficiente que ir comparando."

#: ..\python_docs\spladdoninternals.py:439
msgid ""
"You can imagine what would have happened if the above operation was not a "
"background task: cannot perform other NVDA commands until library scan is "
"complete, cannot cancel this operation and what not. And this is the "
"signature of the thread that performs the above operation:"
msgstr ""
"Te puedes imaginar qué habría pasado si la operación anterior no fuese una "
"tarea en segundo plano: no se podrían ejecutar otras órdenes de NVDA hasta "
"que se completara el escaneo de biblioteca y no se podría cancelar la "
"operación. Esta es la cabecera del hilo que realiza la operación de arriba:"

#: ..\python_docs\spladdoninternals.py:440
msgid ""
"libraryScanner = threading.Thread(target=self.libraryScanReporter, "
"args=(_SPLWin, countA, countB, parem))"
msgstr ""
"libraryScanner = threading.Thread(target=self.libraryScanReporter, "
"args=(_SPLWin, countA, countB, param))"

#: ..\python_docs\spladdoninternals.py:441
msgid ""
"There are important arguments in use: the function (task) to be performed "
"and arguments for this function. The most important argument is the last "
"one: Studio 5.0x and 5.10 expects different arguments when told to report "
"number of items scanned so far."
msgstr ""
"Hay argumentos importantes en uso: la función (tarea) a realizar y los "
"argumentos para esta función. El argumento más importante es el último: "
"Studio 5.0x y 5.10 esperan argumentos diferentes cuando se les pide que "
"informen de los elementos escaneados hasta el momento."

#: ..\python_docs\spladdoninternals.py:442
msgid ""
"Despite limitations of Python's threading routines, if used properly, it can "
"open new possibilities, and you saw some of them above: microphone alarm and "
"background library scan. Use of threads in the Studio app module also allows "
"NVDA to be responsive while using Studio and allows background tasks to be "
"faithful to the tasks at hand. We'll come back to threads when we talk about "
"encoder connection routines. There is a more \"magical\" feature we'll "
"visit, and this is our next stop on the SPL Studio Add-on Internals: Cart "
"Explorer."
msgstr ""
"A pesar de las limitaciones de los procedimientos de Python para hilos, si "
"se usan adecuadamente, pueden abrir nuevas posibilidades como las que has "
"visto arriba: la alarma del micrófono y el escaneo de la biblioteca en "
"segundo plano. El uso de hilos en el módulo de aplicación de Studio también "
"permite que NVDA sea rápido mientras se utilice Studio y permite que las "
"tareas en segundo plano sean fieles a la tarea que se desempeña a mano. "
"Volveremos a los hilos cuando hablemos de los procedimientos de conexión del "
"codificador. Hay una característica más \"mágica\" que visitaremos, y es "
"nuestra siguiente parada en el recorrido por el interior del complemento "
"para SPL Studio: el explorador cart."

#: ..\python_docs\spladdoninternals.py:443
msgid "## The magic behind Cart Explorer"
msgstr "## La magia que hay tras el explorador cart"

#: ..\python_docs\spladdoninternals.py:444
msgid ""
"A live radio broadcast would not be complete without jingles. This can range "
"from station promotions (often called \"promos\"), advertisements, jingles "
"to convey the mood of a show, segment jingles and more. Many station "
"automation programs, including StationPlaylist Studio includes facilities to "
"manage jingles (sometimes called carts), including defining a cart to be "
"played when cart keys are pressed, announcing the name of the playing cart "
"and saving uer specific carts to a safe location."
msgstr ""
"Una emisión de radio en directo no estaría completa sin jingles. Estos "
"pueden ir desde promociones de radio (a veces llamadas \"promos\"), "
"anuncios, jingles para transmitir el estado de ánimo en un programa, jingles "
"de segmento y más. Muchos programas de automatización de emisoras, incluido "
"StationPlaylist Studio, incluyen formas de gestionar jingles (a veces "
"llamados carts), incluyendo la definición de un cart para que sea "
"reproducido al pulsar las teclas de cart, verbalizar el nombre del cart en "
"reproducción y guardar nuestros carts específicos en una ubicación segura."

#: ..\python_docs\spladdoninternals.py:445
msgid ""
"For blind broadcasters, one of the things they worry is pressing a wrong "
"jingle key by accident, thus script writers were asked to implement a way "
"for broadcasters to learn which carts are assigned to cart keys. As of time "
"of this post, all three screen readers (JAWS for Windows (script author: "
"Brian Hartgen), Window-Eyes (script author: Jeff Bishop), NVDA (script "
"author: Joseph Lee (I, the author of this article)) includes a feature to "
"learn jingle assignments. As this is a series of articles on internals of an "
"NVDA add-on, I'll give you an overview of what happens when you activate and "
"explore cart assignments (in fact, this section was the most interesting and "
"feedback driven portion of the add-on). Along the way you'll learn where "
"Cart Explorer (NVDA's version of cart learn mode) draws its power and why it "
"is very important."
msgstr ""
"Una de las cosas que preocupa a los locutores ciegos es pulsar una tecla de "
"jingle incorrecta por accidente, por lo que se pidió a los desarrolladores "
"de scripts que implementaran una forma para que los locutores aprendieran "
"qué carts están asignados a las teclas cart. En el momento en que escribo "
"este artículo, los tres lectores de pantalla (JAWS for Windows (autor de los "
"scripts: Brian Hartgen), Window Eyes (autor de los scripts: Jeff Bishop) y "
"NVDA (autor de los scripts: Joseph Lee (yo, el autor de este artículo)) "
"incluyen una función para aprender las asignaciones de jingles. Como esta es "
"una serie de artículos sobre el interior de un complemento de NVDA, te daré "
"una descripción de lo que pasa cuando activas y exploras las asignaciones "
"cart (de hecho, esta sección fue la porción más interesante y dirigida por "
"comentarios del complemento). A lo largo del camino aprenderás de dónde coge "
"su poder el explorador cart (la versión de NVDA del modo de aprendizaje de "
"cart) y por qué es muy importante."

#: ..\python_docs\spladdoninternals.py:446
msgid "### Carts in StationPlaylist Studio"
msgstr "### Carts en StationPlaylist Studio"

#: ..\python_docs\spladdoninternals.py:447
msgid ""
"Studio comes in three editions: Demo (same as Pro but for limited time "
"trial), Standard and Pro. The first user visible difference between Standard "
"and Pro is number of cart assignments: Standard can store 48 jingles, while "
"Pro can work with 96 of them."
msgstr ""
"Studio viene en tres ediciones: Demo (igual que la Pro pero funcionando "
"durante un tiempo limitado de prueba), Standard y Pro. La primera diferencia "
"visible para el usuario entre Standard y Pro es la cantidad de asignaciones "
"de cart: la Standard puede almacenar 48 jingles, mientras que la Pro puede "
"trabajar con 96 de ellos."

#: ..\python_docs\spladdoninternals.py:448
msgid ""
"To play jingles, a broadcaster would use Cart Edit Mode Control+T), then "
"assign a hotkey to a file. For Studio Standard, you can assign F1 through "
"F12 by themselves or in combination with Control, Shift or Alt. In Demo and "
"Pro, number row can be assigned (1 through 9, 0, hyphen (-) and equals (=) "
"either by themselves or in combination with Control, Shift or Alt, for a "
"grand total of 96 jingles). Once jingles are assigned, they will appear "
"under cart menus (there are four cart menus, one for standalone keys (called "
"main) and one each for Control, Shift and Alt)."
msgstr ""
"Para reproducir jingles, un locutor usaría el modo de edición de cart (ctrl"
"+t), y a continuación asignaría una tecla rápida a un archivo. En Studio "
"Standard, puedes asignar de f1 a f12 por sí mismas o en combinación con "
"ctrl, shift o alt. En Demo y Pro, puede asignarse la fila de números (del 1 "
"al 9, el 0, el guión (-), y el igual (=) bien por sí solos o en combinación "
"con ctrl, shift o alt, para llegar al total de 96 jingles). Una vez los "
"jingles están asignados, aparecerán en los menús de cart (hay cuatro menús "
"de cart, uno para teclas independientes (llamado principal) y uno para "
"control, otro para shift y otro para alt)."

#: ..\python_docs\spladdoninternals.py:449
msgid "### Where does Studio store carts?"
msgstr "### ¿Dónde almacena Studio los carts?"

#: ..\python_docs\spladdoninternals.py:450
msgid ""
"Studio's \"carts\" are housed in Studio installation folder. There are four "
"cart files (called banks) in use: a .cart file for each of the cart banks "
"(main, Shift, Control, Alt). During normal business hours, Studio will work "
"with these four banks unless told by a broadcaster to load carts from a "
"different cart bank file."
msgstr ""
"Los \"carts\" de Studio se alojan en la carpeta de instalación de Studio. "
"Hay cuatro archivos de cart (llamados bancos) en uso: un archivo .cart por "
"cada uno de los bancos de carts (principal, shift, control, alt). Durante "
"las horas laborables, Studio funcionará con estos cuatro bancos a menos que "
"un locutor cargue otros carts desde un archivo de banco de carts diferente."

#: ..\python_docs\spladdoninternals.py:451
msgid "### Cart Explorer: my own Summer of Code"
msgstr "### Explorador cart: mi propio verano de código"

#: ..\python_docs\spladdoninternals.py:452
msgid ""
"It was a hot day in June 2014 when I sat down to design a way to let "
"broadcasters learn cart assignments. Since I was developing add-on 3.0 back "
"then, I decided that this feature should be a top priority feature to be "
"included in the upcoming release."
msgstr ""
"Era un día caluroso en junio de 2014 cuando me senté a diseñar una forma de "
"que los locutores aprendieran las asignaciones cart. Ya que estaba "
"desarrollando el complemento 3.0 por entonces, decidí que esta "
"característica debería tener la prioridad más alta para incluirla en la "
"liberación que estaba por llegar."

#: ..\python_docs\spladdoninternals.py:453
msgid ""
"When I started writing this feature, the first thing I thought about was its "
"name. I felt \"cart learn mode\" didn't really convey the picture - after "
"all, I reasoned that broadcasters will use this feature to explore cart "
"assignments. Thus the name \"Cart Explorer\" was chosen - in effect, when "
"you use this feature, you are browsing jingle assignments in preparation for "
"a show."
msgstr ""
"Cuando empecé a escribir esta característica, la primera cosa en la que "
"pensé fue su nombre. Yo sentía que \"Modo de aprendizaje de cart\" no "
"representaba adecuadamente el cuadro - después de todo, razoné que los "
"locutores usarán esta característica para explorar las asignaciones de cart. "
"Por tanto, elegí el nombre \"Explorador cart\" - en efecto, cuando usas esta "
"característica, estás explorando las asignaciones de jingles para prepararte "
"para un programa."

#: ..\python_docs\spladdoninternals.py:454
msgid ""
"Next, I read JAWS script documentation to get a glimpse of how Brian has "
"managed to implement cart learn mode. In JAWS scripts, script settings are "
"stored in the user configuration directory (typically this is %systemdrive%"
"\\Users\\%username%\\AppDate\\Roaming\\Freedom Scientific\\JAWS\\%JAWSVersion"
"%\\Settings\\Enu; Brian, please correct me if I'm wrong). A section of this "
"script configuration file is dedicated to carts, and JAWS scripts use a map "
"of key names and cart values to announce cart information while cart learn "
"mode is active."
msgstr ""
"Después, leí la documentación de los scripts de Jaws para hacerme una idea "
"de cómo implementó Bryan el modo de aprendizaje de cart. En los scripts de "
"Jaws, los ajustes de cada script se alojan en la carpeta de ajustes del "
"usuario (normalmente esta es %systemdrive%\\Users\\%username%\\AppDate"
"\\Roaming\\Freedom Scientific\\JAWS\\%JAWSVersion%\\Settings\\Enu; Bryan, "
"corrígeme por favor si me equivoco). Una sección de este archivo de "
"configuración del script está dedicada a los carts, y Jaws usa un mapa de "
"nombres de clave y valores de cart para anunciar la información del cart "
"mientras el modo de aprendizaje de carts esté activo."

#: ..\python_docs\spladdoninternals.py:455
msgid ""
"Based on this information, I started writing an ini file parser, seeing that "
"broadcasters would store cart assignments in a configuration database. This "
"was prone to a number of errors, including wrong cart name format, "
"nonexistent cart key assignment, invalid configuration format and others. I "
"once wrote a blog post (on this blog) explaining how this worked (times have "
"changed, as you'll see very soon)."
msgstr ""
"Basándome en esta información, comencé a escribir un intérprete de archivos "
"ini, viendo que los locutores almacenarían las asignaciones de cart en una "
"base de datos de configuración. Este estaba sujeto a un gran número de "
"errores, incluidos el formato equivocado del nombre del cart, asignación de "
"clave de cart no existente, formato de configuración no válido y otros. Una "
"vez escribí una entrada de blog (en mi blog) explicando cómo funcionaba (los "
"tiempos han cambiado, como verás muy pronto)."

#: ..\python_docs\spladdoninternals.py:456
msgid ""
"Then I became curious as to how Studio stores its own cart banks, and "
"naturally, I opened the folder where carts were stored and opened each .cart "
"file in Notepad++ (a very handy text editor). From reading the cart bank "
"format (explained below), I thought it might be useful to write a cart bank "
"file parser. Thus I resumed writing Cart Explorer routines, this time "
"incorporating the cart bank format, not forgetting to handle suttle errors, "
"and this is the routine used in add-on releases up to 5.x (6.0 uses a "
"completely different yet related routine, as you'll see)."
msgstr ""
"Entonces me entró la curiosidad de cómo guarda Studio sus propios bancos "
"cart y, naturalmente, abrí la carpeta donde se almacenaban los carts y abrí "
"cada archivo .cart en Notepad++ (un editor de texto muy útil). Desde que leí "
"el formato del banco cart (explicado debajo), pensé que podría ser útil "
"escribir un intérprete de archivos cart. Por tanto continué escribiendo los "
"procedimientos del explorador cart, en esta ocasión incorporando el formato "
"del banco cart, sin olvidarme de tener en cuenta los errores, y este es el "
"procedimiento que se usa en versiones del complemento posteriores a la 5.x "
"(la 6.0 usa un procedimiento relacionado pero totalmente diferente, como "
"verás)."

#: ..\python_docs\spladdoninternals.py:457
msgid ""
"While writing the first version of Cart Explorer, I realized that this "
"feature needed some real life testing, so I asked a seasoned blind "
"broadcaster to test this feature. We spent a better part of Independence Day "
"writing, debugging and rewriting this routine until we felt satisfied. In "
"the end, our hard work paid off, as you can see in subsequent paragraphs."
msgstr ""
"Mientras escribía la primera versión del explorador cart, me di cuenta de "
"que esta característica necesitaba algunas pruebas en la vida real, por lo "
"que pedí a un locutor ciego profesional que la probara. Invertimos la mejor "
"parte del día de la independencia escribiendo, depurando y reescribiendo "
"este procedimiento hasta que nos sentimos satisfechos. Al final, nuestro "
"duro trabajo fue recompensado, como puedes ver en los siguientes párrafos."

#: ..\python_docs\spladdoninternals.py:458
msgid "### Introducing Cart Explorer version 1"
msgstr "### Presentación del explorador cart versión 1"

#: ..\python_docs\spladdoninternals.py:459
msgid ""
"Cart Explorer version 1, shipped as part of add-on 3.0, worked as follows:"
msgstr ""
"La versión 1 del explorador cart, incorporada en el complemento 3.0, "
"funcionaba de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:460
msgid ""
"1. You press Control+NVDA+3 to activate Cart Explorer. When this happens, "
"NVDA will make sure you are in main playlist viewer, then it will set a flag "
"indicating that Cart Explorer is active."
msgstr ""
"1. Se pulsa NVDA+ctrl+3 para activar el explorador cart. Cuando esto ocurre, "
"NVDA se asegura de que estés en el visor principal de listas de "
"reproducción, y después establece un indicador para informar de que el "
"explorador cart está activo."

#: ..\python_docs\spladdoninternals.py:461
msgid ""
"2. NVDA will then open and parse cart bank files, storing cart assignments "
"in a dictionary of cart keys to cart names. This parser also takes care of "
"some corner cases, including skipping unassigned carts and determining "
"Studio edition in use. Once carts were parsed, NVDA says, \"Entering Cart "
"Explorer\", and if errors occur, NVDA will inform you that it cannot enter "
"Cart Explorer (this happens if the cart bank file doesn't exist)."
msgstr ""
"2. NVDA abre e interpreta los archivos de los bancos cart, almacenando las "
"asignaciones de carts en un diccionario con teclas de cart y nombres de "
"cart. Este intérprete también tiene en cuenta algunos casos excepcionales, "
"incluyendo saltarse los carts no asignados y determinar la edición de Studio "
"en uso. Una vez se interpretan los carts, NVDA dice \"Entrando en el "
"explorador cart\", y si ocurren errores, NVDA te informará de que no puede "
"entrar en el explorador cart (esto pasa si el archivo del banco de carts no "
"existe)."

#: ..\python_docs\spladdoninternals.py:462
msgid ""
"3. While using Cart Explorer, if you press a cart key, NVDA will look up the "
"name of the key in the carts dictionary, and announce the cart name "
"associated with it (if found, otherwise, NVDA says, \"cart unassigned\")."
msgstr ""
"3. Mientras usas el explorador cart, si pulsas una tecla cart, NVDA buscará "
"el nombre de la tecla en el diccionario de carts, y anunciará el nombre del "
"cart asociado con ella (si se encuentra, en cualquier otro caso NVDA dice "
"\"Cart sin asignar\")."

#: ..\python_docs\spladdoninternals.py:463
msgid ""
"4. It so happens that some people will activate Cart Edit Mode to modify "
"cart assignments while in the middle of exploring carts. If this happens, "
"NVDA will remind you (via doExtraAction function used by name change event) "
"that Cart Explorer is active, and when Cart Edit Mode is turned off, NVDA "
"will ask you to reenter Cart Explorer (this was done to parse newly updated "
"cart bank files)."
msgstr ""
"4. A veces algunas personas activan el modo de edición de cart para "
"modificar sus asignaciones mientras explora carts. Si esto pasa, NVDA te "
"recordará (mediante la función doExtraAction usada en el evento de cambio de "
"nombre) que el explorador cart está activo, y cuando el modo de edición de "
"cart se desactive, NVDA te preguntará si quieres volver a entrar en el "
"explorador cart (esto se hizo para interpretar los archivos actualizados de "
"bancos de carts)."

#: ..\python_docs\spladdoninternals.py:464
msgid ""
"5. You press Control+NVDA+3, and NVDA will clear carts dictionary, thereby "
"leaving Cart Explorer."
msgstr ""
"5. Se pulsa ctrl+NVDA+3, y NVDA limpiará el diccionario de carts, dejando el "
"explorador cart después."

#: ..\python_docs\spladdoninternals.py:465
msgid ""
"But there was a major concern with this approach: what if a future version "
"of Studio uses a different cart bank format? Thus, I revisited cart bank "
"files again in July 2015, and this time, I noticed a familiar structure: "
"comma-separated values, and thought about a possibility that a spreadsheet "
"application such as Excel would handle this gracefully. To test my "
"hypothesis, I opened .cart files in Excel, and voila, it presented itself "
"just like any CSV file. Thus I worked on modifying cart parsing routine, "
"this time using Python's CSV module to parse \"cart\" files (cart bank files "
"are really CSV files in disguise). This new routine (described below) made "
"its appearance as part of add-on 6.0."
msgstr ""
"Pero había un gran problema con este enfoque: ¿qué pasa si una versión "
"futura de Studio utiliza un formato diferente de bancos de cart? Por lo "
"tanto, volví a visitar los archivos de banco de cart de nuevo en julio de "
"2015, y esta vez me di cuenta de que había una estructura familiar: valores "
"separados por comas, y pensé en la posibilidad de que una aplicación de "
"hojas de cálculo los procesaría adecuadamente. Para probar mi hipótesis, "
"abrí los archivos .cart en Excel, y efectivamente, se mostraron como "
"archivos csv. Por lo tanto, trabajé en modificar el procedimiento de "
"interpretación de carts, en esta ocasión usando el módulo csv de Python para "
"interpretar los archivos \"cart\" (los archivos de bancos de cart realmente "
"son archivos csv en esencia). Este nuevo procedimiento (descrito debajo) "
"hizo su aparición como parte del complemento 6.0."

#: ..\python_docs\spladdoninternals.py:466
msgid "### The magic behind Cart Explorer version 2: handling CSV files"
msgstr ""
"### La magia tras el explorador cart versión 2: trabajar con archivos csv"

#: ..\python_docs\spladdoninternals.py:467
msgid ""
"Since Python comes with a library to handle CSV files and since cart banks "
"are CSV files, I rewrote Cart Explorer routine (a function in splmisc module "
"which returns the carts dictionary) as follows:"
msgstr ""
"Ya que Python viene con una biblioteca para trabajar con archivos csv y ya "
"que los bancos de carts son archivos csv, reescribí el procedimiento del "
"explorador cart (una función en el módulo splmisc que devuelve el "
"diccionario de carts) de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:468
msgid ""
"1. When entering Cart Explorer, Car Explorer preparation routine (splmisc."
"cartExplorerInit) will take a snapshot of your user name and Studio edition "
"(Studio's title bar indicates which version is in use). Then it initializes "
"the carts dictionary and stores the Studio edition in use."
msgstr ""
"1. Al entrar en el explorador cart, el procedimiento de preparación del "
"explorador cart (splmisc.cartExplorerInit) tomará una instantánea de tu "
"nombre de usuario y la edición de Studio (la barra de título de Studio "
"indica qué versión se está usando). Después inicializa el diccionario de "
"carts y almacena la edición de Studio en uso."

#: ..\python_docs\spladdoninternals.py:469
msgid ""
"2. Next, the preparation function will write down names and paths to cart "
"banks. In case a user other than default user is using Studio, it'll modify "
"the cart file names to match the name likely to be used by Studio to present "
"user-specific cart banks. These cart names form one part of the cart bank "
"path (the other part is the path to the folder where the carts live, "
"obtained by using an environment variable)."
msgstr ""
"2. A continuación, la función de preparación escribirá nombres y rutas en "
"los bancos cart. En caso de que un usuario distinto al que hay por defecto "
"esté utilizando Studio, se modificarán los nombres de archivo de los carts "
"para que encajen con el nombre que probablemente usará Studio para presentar "
"los bancos de carts específicos del usuario. Estos nombres de carts forman "
"una parte de la ruta al banco de carts (la otra parte es la ruta a la "
"carpeta en la que residen los carts, obtenida mediante una variable de "
"entorno)."

#: ..\python_docs\spladdoninternals.py:470
msgid ""
"3. For each cart bank, NVDA will ask Python to parse the cart bank as a CSV "
"file (csv.reader; when finished, it returns a list of lists, with each list "
"representing one row of a CSV table)."
msgstr ""
"3. En cada banco de carts, NVDA pedirá a Python que interprete el banco como "
"un archivo csv (csv.reader; al acabar, devuelve una lista de listas, siendo "
"cada lista una fila de la tabla csv)."

#: ..\python_docs\spladdoninternals.py:471
msgid ""
"4. Once the csv version of the selected cart bank is ready, the row "
"containing cart keys and cart names, together with the cart bank modifier "
"and the carts dictionary are sent to a helper function (part of splmisc "
"module) that will do the following:"
msgstr ""
"4. Una vez está lista la versión csv del banco de carts correspondiente, la "
"fila que contiene las teclas de cart y sus nombres, junto con el modificador "
"del banco de carts y el diccionario de carts, se envían a una función "
"auxiliar (parte del módulo splmisc) que hará lo siguiente:"

#: ..\python_docs\spladdoninternals.py:472
msgid ""
"A. Depending on Studio edition, this helper will work with only the first "
"half (Standard will only work with function keys, which are the first twelve "
"columns of this row) or the entire row (the rest are number row keys) will "
"be processed."
msgstr ""
"A. Dependiendo de la edición de Studio, esta función auxiliar trabajará con "
"la primera mitad solamente (la Standard sólo trabajará con las teclas de "
"función, que están en las primeras doce columnas de esta fila) o se "
"procesará la fila entera (el resto son las teclas numéricas)."

#: ..\python_docs\spladdoninternals.py:473
msgid ""
"B. Depending on column position (items in the row list), it will see if "
"function keys or number row keys should be assigned to the selected cart "
"entry. This routine also checks the type of the cart bank (modifiers or none "
"(main)) and modifies the cart key name accordingly."
msgstr ""
"B. Dependiendo de la posición de la columna (elementos en la lista de la "
"fila), se verá si deberían asignarse las teclas de función o las de la fila "
"numérica a la entrada seleccionada del cart. Este procedimiento también "
"comprueba el tipo del banco de carts (modificadores o nada (principal)) y "
"modifica el nombre de la tecla cart según corresponda."

#: ..\python_docs\spladdoninternals.py:474
msgid ""
"C. Next, the helper routine will try to locate the name of the jingle "
"assigned to the cart key in question, and if there is one, it'll add the "
"cart key and jingle name pair into the carts dictionary."
msgstr ""
"C. A continuación, el procedimiento auxiliar intentará ubicar el nombre del "
"jingle asignado a la tecla cart en cuestión, y si hay uno, añadirá el par de "
"la tecla del cart y el nombre del jingle al diccionario de carts."

#: ..\python_docs\spladdoninternals.py:475
msgid ""
"5. Back at the cartExplorerInit function, if no erorrs were found while "
"parsing a cart bank, it'll move onto the next one, otherwise it will inform "
"the Studio app module by modifying a flag value in the carts dictionary "
"(stored as an integer, representing number of cart bankks with errors)."
msgstr ""
"5. De vuelta en la función cartExplorerInit, si no se encontraron errores "
"mientras se interpretaba un banco de carts, esta se moverá al siguiente, en "
"cualquier otro caso informará al módulo de aplicación de Studio modificando "
"un valor indicador en el diccionario de carts (almacenado como un entero que "
"representa el número de bancos cart con errores)."

#: ..\python_docs\spladdoninternals.py:476
msgid ""
"6. By now cartExplorerInit is desperate to pass the carts dictionary to "
"someone, and this someone turns out to be the Studio app module - once "
"picked up by the app module, carts dictionary is hired by you to look up "
"cart names for cart keys while you use Cart Explorer (to fire the carts "
"dictionary, simply deactivate Cart Explorer by pressing Control+NVDA+3)."
msgstr ""
"6. Ahora cartExplorerInit está desesperada por pasarle el diccionario de "
"carts a alguien, y ese alguien resulta ser el módulo de aplicación de Studio "
"- una vez es recogido por el módulo de aplicación, tú lo utilizas para mirar "
"los nombres de carts que se corresponden con las teclas cart mientras usas "
"el explorador cart (para echar al fuego el diccionario de carts, simplemente "
"desactiva el explorador cart pulsando ctrl+NVDA+3)."

#: ..\python_docs\spladdoninternals.py:477
msgid ""
"In effect, the routine above (the \"magic\" behind Cart Explorer) replaced a "
"hand-written cart bank parser and simplified the add-on code (I regret not "
"investigating CSV module in 2014). As far as user experience is concerned, "
"this is same as Cart Explorer 1, with the difference being the parsing "
"routine. With the addition of splmisc.cartExplorerInit, the majority of the "
"splmisc module (miscellaneous services, containing the Track Finder/Column "
"Search combo dialog, column retriever and Cart Explorer preparation tool) "
"was completed. But the innovations continued."
msgstr ""
"En efecto, el procedimiento anterior (la \"magia\" tras el explorador cart) "
"reemplazó un intérprete de bancos de carts escrito a mano y simplificó el "
"código del complemento (lamento no haber investigado el módulo csv en 2014). "
"En términos de experiencia de usuario, no cambia nada con respecto al "
"explorador cart versión 1, siendo la diferencia el procedimiento de "
"interpretación. Al añadir la función splmisc.cartExplorerInit, la mayoría "
"del módulo splmisc (servicios misceláneos entre los que están el diálogo "
"combinado del buscador de columnas y el buscador de pistas, el recuperador "
"de columnas y la herramienta de preparación del explorador cart) estaba "
"completo. Pero continuaron las innovaciones."

#: ..\python_docs\spladdoninternals.py:478
msgid "### Enter Cart Explorer version 3: file modification timestamps"
msgstr ""
"### Introducción al explorador cart versión 3: fechas de modificación de los "
"archivos"

#: ..\python_docs\spladdoninternals.py:479
msgid ""
"There were two issues with Cart Explorer version 2: confusing statements "
"when cart insert mode was active, and inability to detect that cart editing "
"is finished. Cart insert mode allows broadcasters to press the cart command "
"to have the file inserted into the playlist as a regular track. Inability to "
"detect cart edit completion meant one had to reenter Cart Explorer to view "
"updated cart assignments."
msgstr ""
"Había dos problemas con la versión 2 del explorador cart: frases confusas "
"cuando el modo de inserción de cart estaba activo, e incapacidad de detectar "
"que había finalizado la edición de carts. El modo de inserción de carts "
"permite a los locutores pulsar la orden cart para insertar el archivo dentro "
"de la lista de reproducción como si fuera una pista normal. La incapacidad "
"de detectar la finalización de la edición de carts significaba que había que "
"entrar en el explorador cart para ver las asignaciones cart actualizadas."

#: ..\python_docs\spladdoninternals.py:480
msgid ""
"The first issue was solved by telling users that Cart Explorer was active "
"while cart insert mode was active. The resolution to the second issue "
"required a bit of work, and involved rewriting parts of Cart Explorer (now "
"version 3), which is included as of add-on 17.01 (optimized in 17.04). The "
"biggest difference is recording file modification timestamps for carts when "
"carts dictionary is being built (see above), and if cart edit is turned off, "
"checking the timestamps of newly modified cart banks against previous "
"timestamps (when cart edit is off, when cart assignments have changed, cart "
"files are written back to disk) and skipping unmodified cart banks. In "
"spring 2017, this was further optimized by allowing carts dictionary to be "
"modified on the fly (only changed bits will be modified, including possible "
"new assignments, changes and deletions). This means no more need to reenter "
"cart Explorer when cart assignments have changed, a huge relief for "
"broadcasters who need to change cart assignments for holidays or other "
"special occasions."
msgstr ""
"El primer problema se solucionó indicando a los usuarios que el explorador "
"cart estaba activo mientras el modo de inserción de carts lo estaba. La "
"resolución del segundo problema necesitó un poco de trabajo, e implicó "
"reescribir partes del explorador cart (ahora versión 3), que viene incluido "
"a partir del complemento 17.01 (optimizado en 17.04). La gran diferencia es "
"que se registran las fechas de modificación de los archivos cart cuando se "
"construye el diccionario de carts (mira arriba), y si se desactiva la "
"edición de carts, se comprueba la fecha de modificación de los archivos de "
"banco de carts con las fechas guardadas (cuando la edición de carts se "
"apaga, cuando cambian las asignaciones de carts, se escriben los archivos de "
"carts de vuelta al disco) ignorando los archivos de cart no modificados. En "
"la primavera de 2017, esto se optimizó aún más permitiendo que el "
"diccionario de carts fuera modificado al vuelo (sólo se cambiarán los bits "
"modificados, incluidas las posibles nuevas asignaciones, cambios y "
"eliminaciones). Esto significa que desaparece la necesidad de volver a "
"entrar al explorador cart cuando las asignaciones de los carts cambian, un "
"gran alivio para los locutores que necesitan cambiar las asignaciones de "
"carts para las fiestas u otras ocasiones especiales."

#: ..\python_docs\spladdoninternals.py:482
msgid ""
"Cart Explorer has come a long way; from a simple suggestion to the CSV "
"parsing routine above to checking timestamps for cart assignment changes, "
"Cart Explorer has changed to meet the needs of broadcasters using Studio and "
"NVDA. I would like to improve this further in future releases (another "
"suggestion I received was ability to specify cart file names for individual "
"banks, and I'm thinking about implementing this in the near future)."
msgstr ""
"El explorador cart ha recorrido un largo camino; desde una sugerencia simple "
"hasta el procedimiento para interpretar csv que se ha descrito antes y la "
"comprobación de las fechas de modificación de los archivos para buscar "
"cambios de asignación de carts. El explorador cart ha cambiado hasta "
"satisfacer las necesidades de los locutores que usan Studio y NVDA. Me "
"gustaría mejorarlo más en versiones futuras (otra sugerencia que recibí fue "
"la capacidad de especificar los nombres de archivo con carts de bancos "
"individuales, y estoy pensando en implementarla en el futuro cercano)."

#: ..\python_docs\spladdoninternals.py:483
msgid ""
"One of the things you may have noticed as you read this article so far is "
"how I and other developers continue to research better ways of accomplishing "
"something. You also saw a glimpse of how developers and users shape a "
"feature and how much work is involved to bring a feature suggestion to life. "
"These activities (research and feature development collaboration) are just "
"two of the pillars supporting Studio add-on for NVDA, and highlights how "
"design philosophy and product development approach affects future course of "
"product development."
msgstr ""
"Una de las cosas de las que puedes haberte dado cuenta según lees este "
"artículo hasta ahora es cómo tanto yo como otros desarrolladores seguimos "
"investigando mejores maneras de resolver algo. También echaste un vistazo a "
"cómo desarrolladores y usuarios dan forma a una característica y cuánto "
"trabajo implica hacer realidad una sugerencia. Estas actividades "
"(investigación y colaboración en el desarrollo de características) son dos "
"de los pilares que dan soporte al complemento de NVDA para Studio, y "
"resaltan cómo afectan la filosofía del diseño y el enfoque de desarrollo del "
"producto al curso futuro de su evolución."

#: ..\python_docs\spladdoninternals.py:484
msgid ""
"This ends our detailed tour of internals of major features in Studio app "
"module. When we come back, we'll visit our friend from the past: SPL "
"Assistant layer and inner workings of various layer commands."
msgstr ""
"Con esto termina nuestro recorrido detallado por el interior de las "
"características más importantes del módulo de aplicación de Studio. Cuando "
"volvamos, visitaremos a nuestro amigo del pasado: la capa del asistente de "
"SPL y el funcionamiento interno de diversas órdenes de capa."

#: ..\python_docs\spladdoninternals.py:485
msgid "## All about StationPlaylist Assistant layer"
msgstr "## Todo sobre la capa del asistente de SPL"

#: ..\python_docs\spladdoninternals.py:486
msgid ""
"You may recall visiting two layer command sets in a previous article: SPL "
"Controller and SPL Assistant, the former used to perform Studio functions "
"from any program and the latter for status announcements. I mentioned "
"throughout this series that we'll tour these layer sets, and we'll start "
"with SPL Assistant layer."
msgstr ""
"Como recordarás, en un artículo anterior hablamos de dos conjuntos de "
"órdenes de capa: el controlador de SPL y el asistente de SPL, el primero "
"usado para realizar funciones de Studio desde cualquier programa y el otro "
"para anuncios de estado. He mencionado a lo largo de este artículo que "
"visitaríamos estos conjuntos de capa, así que empezaremos con la capa del "
"asistente de SPL."

#: ..\python_docs\spladdoninternals.py:487
msgid "### Talk about layer commands"
msgstr "### Charla sobre las órdenes de capa"

#: ..\python_docs\spladdoninternals.py:488
msgid ""
"One of the common features of Studio scripts for JAWS, Window-Eyes and NVDA "
"is extensive use of layer commands. This was popularized by JAWS and its "
"Studio layer (grave key). Some of the benefits of this approach include "
"saving keyboard commands, reminding users as to commands available in Studio "
"and so on."
msgstr ""
"Una de las características que tienen en común los scripts de Jaws, Window "
"Eyes y NVDA es el uso extenso de órdenes de capa. Jaws popularizó este "
"concepto y su capa de Studio (la tecla grave). Algunos beneficios de este "
"enfoque incluyen ahorrar órdenes de teclado, recordar a los usuarios las "
"órdenes de Studio y así sucesivamente."

#: ..\python_docs\spladdoninternals.py:489
msgid "### Birth of SPL Assistant layer"
msgstr "### Nacimiento de la capa del asistente de SPL"

#: ..\python_docs\spladdoninternals.py:490
msgid ""
"As mentioned previously, since version 1.0 in January 2014, Studio add-on "
"comes with two layer commands to represent the global plugin and the studio "
"app module. In case of Studio app module and its layer set (SPL Assistant), "
"I borrowed some commands from both JAWS and Window-Eyes scripts with some "
"notable differences, namely some commands and how things were announced."
msgstr ""
"Como mencioné antes, desde la versión 1.0 en enero de 2014, el complemento "
"de Studio viene con dos órdenes de capa para representar a la extensión "
"global y al módulo de aplicación de Studio. En el caso del módulo de "
"aplicación de Studio y su conjunto de capa (asistente de SPL), tomé "
"prestadas algunas órdenes de los scripts de Jaws y Window Eyes con algunas "
"diferencias destacables, entre ellas algunas órdenes y cómo se verbalizaban "
"las cosas."

#: ..\python_docs\spladdoninternals.py:491
msgid ""
"When I sat down to design this layer set, I felt it would be helpful for "
"broadcasters if most of the Assistant layer commands borrowed from Studio "
"command assignments. For example, a broadcaster will press M to toggle "
"microphone on and off, and in SPL Assistant layer, pressing M announces "
"microphone status. Another example was Cart Edit Mode - pressing Control+T "
"in Studio will toggle this, and pressing SPL Assistant, T will announce "
"whether this mode is on or off (the reason for assigning T for Cart Edit "
"Mode status will be discussed later)."
msgstr ""
"Cuando me senté a diseñar este conjunto de capa, sentí que sería útil para "
"los locutores que la mayoría de las órdenes de la capa del asistente "
"vinieran de las órdenes asignadas a Studio. Por ejemplo, un locutor pulsará "
"la m para encender o apagar el micrófono, y en la capa del asistente del "
"SPL, pulsar la m hace que se verbalice el estado del micrófono. Otro ejemplo "
"fue el modo de edición de cart - pulsar ctrl+t en Studio lo conmutará, y "
"pulsar asistente de SPL, t indicará si este modo está encendido o apagado "
"(más tarde se discutirá la razón por la que se asignó la t al estado del "
"modo de edición de carts)."

#: ..\python_docs\spladdoninternals.py:492
msgid ""
"Originally, one could invoke SPL Assistant layer by pressing Control+NVDA"
"+grave key from within Studio. However, some NVDA translators told me that "
"this key combination is used for NVDA screen reader commands in their "
"language. Thus, in add-on 2.0 (late spring 2014), I decided to remove this "
"command, which means in order for you (broadcasters) to invoke SPL Assistant "
"layer, you need to go to Input Gestures dialog while focused in Studio, "
"expand StationPlaylist category and look for the Assistant entry (I "
"personally use Control+NVDA+grave, and in recent add-on development builds, "
"I told Studio add-on to let SPL Controller layer command (discussed later) "
"to invoke Assistant layer)."
msgstr ""
"Originalmente se podía invocar la capa del asistente de SPL pulsando ctrl"
"+NVDA+grave desde Studio. Sin embargo, algunos traductores de NVDA me "
"dijeron que esta combinación de teclas se usa para algunas órdenes de NVDA "
"en su idioma. Por tanto, en el complemento 2.0 (a finales de la primavera de "
"2014), decidí eliminar esta orden, lo que se traduce en que para que podáis "
"invocar la capa del asistente de SPL (locutores), debéis ir al diálogo "
"gestos de entrada mientras tengáis el foco en Studio, expandir la categoría "
"StationPlaylist y buscar la entrada del asistente (personalmente uso ctrl"
"+NVDA+grave, y en compilaciones recientes de desarrollo del complemento, "
"hice que el complemento de Studio dejara a la orden de capa del controlador "
"de SPL (explicada más tarde) invocara la capa del asistente)."

#: ..\python_docs\spladdoninternals.py:493
msgid ""
"Another addition to SPL Assistant layer is ability to emulate layer commands "
"provided by other screen readers. This is achieved by using gestures map for "
"each screen reader (NVDA included), with the correct gestures map chosen "
"when entering SPL Assistant layer. Currently, in addition to default NVDA "
"layout, the add-on supports JAWS for Windows and Window-Eyes layer commands."
msgstr ""
"Otro extra añadido a la capa del asistente de SPL es la capacidad de emular "
"órdenes de capa proporcionadas por otros lectores de pantalla. Esto se "
"consigue usando un mapa de gestos para cada lector de pantalla (incluido "
"NVDA), con el mapa de gestos correcto elegido al entrar en la capa del "
"asistente de SPL. Actualmente, además de la distribución por defecto de "
"NVDA, el complemento tiene soporte para las órdenes de capa de Jaws for "
"Windows y Window Eyes."

#: ..\python_docs\spladdoninternals.py:494
msgid "### Categorizing SPL Assistant commands"
msgstr "### Categorización de las órdenes del asistente de SPL"

#: ..\python_docs\spladdoninternals.py:495
msgid ""
"Once you invoke SPL Assistant layer (a beep will be heard), you can perform "
"one of the following operations:"
msgstr ""
"Una vez que invoques a la capa del asistente de SPL (se escuchará un "
"pitido), podrás hacer una de las siguientes operaciones:"

#: ..\python_docs\spladdoninternals.py:496
msgid "* Status announcements (automation, microphone, etc.)."
msgstr "* Indicaciones de estado (automatización, micrófono, etc.)."

#: ..\python_docs\spladdoninternals.py:497
#, fuzzy
#| msgid ""
#| "* Tools (library scan, track time analysis, obtaining playlist snapshots, "
#| "columns explorer and so on)."
msgid ""
"* Tools (library scan, track time analysis, obtaining playlist snapshots and "
"transcripts, columns explorer and so on)."
msgstr ""
"* Herramientas (escaneo de biblioteca, análisis de tiempo de pista, "
"obtención de instantáneas de listas de reproducción, explorador de columnas "
"y demás)."

#: ..\python_docs\spladdoninternals.py:498
msgid "* Configuration (switching broadcast profiles)."
msgstr "* Configuración (alternar perfiles de emisión)."

#: ..\python_docs\spladdoninternals.py:499
msgid ""
"* Ask for help (opening SPL Assistant help dialog or the online user guide)."
msgstr ""
"* Pedir ayuda (abriendo el diálogo de ayuda del asistente de Spl o la guía "
"de usuario en línea)."

#: ..\python_docs\spladdoninternals.py:500
msgid "* Checking for add-on updates (manually)."
msgstr "* Buscar actualizaciones del complemento (manualmente)."

#: ..\python_docs\spladdoninternals.py:501
msgid ""
"For the first two categories, they can be divided further into commands "
"which uses studio API (via statusAPI function discussed in a previous "
"article), ones using Windows API (Columns explorer) and those relying on "
"object navigation (multiple components are involved and is sensitive to user "
"interface changes). We'll go through each of these categories in turn."
msgstr ""
"Las primeras dos categorías pueden subdividirse en órdenes que usan la api "
"de Studio (mediante la función statusApi de la que hablamos en un artículo "
"anterior), las que usan la api de Windows (explorador de columnas) y las que "
"se apoyan en la navegación por objetos (varios componentes están implicados "
"y son sensibles a los cambios en la interfaz de usuario). Vamos a ir "
"recorriendo estas categorías de una en una."

#: ..\python_docs\spladdoninternals.py:502
msgid "#### SPL Assistant 1: status announcements"
msgstr "#### Asistente de SPL 1: indicaciones de estado"

#: ..\python_docs\spladdoninternals.py:503
msgid ""
"These commands allow you to obtain various status information such as title "
"and duration of the next track, cart edit mode status and so on. These can "
"be divided into those which uses object navigation (old style) and Studio "
"API (new style) commands. In some cases, both methods are available and the "
"appropriate version is chosen based on Studio version in use."
msgstr ""
"Estas órdenes te permiten obtener diversa información de estado como el "
"título y duración de la próxima pista, el estado del modo de edición de "
"carts y demás. Pueden dividirse en aquellos que usan la navegación por "
"objetos (el viejo estilo) y órdenes que usan la api de Studio (el nuevo "
"estilo). En algunos casos ambos métodos están disponibles, y se elige la "
"versión apropiada basándose en la versión de Studio en uso."

#: ..\python_docs\spladdoninternals.py:504
msgid ""
"The following commands (sorted alphabetically) utilize Studio API to perform "
"needed functions:"
msgstr ""
"Las siguientes órdenes (ordenadas alfabéticamente) utilizan la api de Studio "
"para llevar a cabo las funciones necesarias:"

#: ..\python_docs\spladdoninternals.py:505
msgid "* E: Announces if any metadata streaming URL's are defined."
msgstr "* E: indica si se ha definido alguna URL de flujo de metadatos."

#: ..\python_docs\spladdoninternals.py:506
msgid "* H: Duration of tracks in the selected hour."
msgstr "* H: duración de pistas en la hora seleccionada."

#: ..\python_docs\spladdoninternals.py:507
msgid "* Shift+H: Duration of the remaining tracks in the hour slot."
msgstr "* Shift+h: duración de las pistas restantes en la hora."

#: ..\python_docs\spladdoninternals.py:508
msgid "* P: Playback status."
msgstr "* P: estado de la reproducción."

#: ..\python_docs\spladdoninternals.py:509
msgid ""
"* Shift+1 through Shift+4 and Shift+0: Checks metadata streaming status for "
"each URL (0 is DSP encoder). See below for details."
msgstr ""
"* Shift+1 a shift+4 y shift+0: comprueba el estado de los metadatos del "
"flujo de cada URL (0 es el codificador DSP). Mira debajo para más detalles."

#: ..\python_docs\spladdoninternals.py:510
msgid ""
"Note that playlist remainder announcement (SPL Assistant, D) was part of "
"this category until add-on 6.x. In add-on 7.0, due to refactoring work "
"surrounding this command, it has been moved to tools category."
msgstr ""
"Ten en cuenta que la indicación del recordatorio de lista de reproducción "
"(asistente de SPL, D) era parte de esta categoría hasta el complemento 6.x. "
"En el complemento 7.0, debido a los trabajos de refactorización que "
"afectaban a esta orden, se ha movido a la categoría de herramientas."

#: ..\python_docs\spladdoninternals.py:511
msgid "##### A step sideways: Metadata streaming"
msgstr "##### Un paso a un lado: flujo de metadatos"

#: ..\python_docs\spladdoninternals.py:512
msgid ""
"Studio can be told to stream track metadata to five URL's: the DSP encoder "
"address and four additional URL's (Options/Now Playing). By default, DSP "
"encoder address is used to send metadata information."
msgstr ""
"Se puede pedir a Studio que emita en tiempo real los metadatos de una pista "
"a cinco URLS: la dirección del codificador DSP y cuatro URLS adicionales "
"(Opciones / Reproducción en curso). Por defecto, se usa la dirección del "
"codificador DSP para enviar información de metadatos."

#: ..\python_docs\spladdoninternals.py:513
msgid ""
"One of the activities Studio app module performs when starting is to check "
"if metadata streaming is enabled on any URL's. In addition, NVDA can tell "
"you status of metadata streaming for all uRL's (SPL Assistant, E) or for "
"individual addresses (SPL Assistant, Shift+1 through Shift+4 and Shift+0). "
"This is done through a metadata management and announcement function "
"(metadataAnnouncer) that gathers streaming flags for URL's and presents "
"status messages and connects to predefined servers if you tell Studio to "
"connect to streaming servers."
msgstr ""
"Una de las actividades que realiza el módulo de aplicación de Studio al "
"iniciar es comprobar si la emisión de metadatos está activada en alguna URL. "
"Además, NVDA te puede informar del estado del flujo de metadatos para todas "
"las URLS (asistente de SPL, E) o para direcciones individuales (asistente de "
"SPL, shift+1 a shift+4 y shift+0). Esto se hace mediante una función de "
"indicación y administración de metadatos (metadataAnnouncer) que recopila "
"indicadores de flujo de las URLS y presenta mensajes de estado y se conecta "
"a los servidores por defecto si le pides a Studio que se conecte a "
"servidores en tiempo real."

#: ..\python_docs\spladdoninternals.py:514
msgid "When the metadata announcer is called, NVDA does the following:"
msgstr "Cuando se llama al indicador de metadatos, NVDA hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:515
msgid ""
"1. NVDA will look at connection flag (reminder = True, but in reality, this "
"is mostly used as the connection flag), and if the flag is set, connects to "
"a predefined set of streaming URL's."
msgstr ""
"1. NVDA mirará el indicador de conexión (reminder=True, pero en realidad, "
"esto se usa mayoritariamente como el indicador de conexión), y si el "
"indicador está activo, se conecta a un conjunto predefinido de URLS de flujo."

#: ..\python_docs\spladdoninternals.py:516
msgid "2. Gathers metadata streaming flags, starting with the DSP encoder."
msgstr ""
"2. Recopila indicadores de emisión de metadatos, empezando por el "
"codificador DSP."

#: ..\python_docs\spladdoninternals.py:517
msgid ""
"3. The announcer will count number of metadata enabled URL's used to format "
"the status message."
msgstr ""
"3. El anunciador contará el número de URLS de metadatos activas usadas para "
"dar formato al mensaje de estado."

#: ..\python_docs\spladdoninternals.py:518
msgid ""
"4. announces the status message. This message isn't announced right away if "
"this function is called when the app module starts - after a short pause, "
"the status message will be announced and an alarm sound will be played. This "
"is done to make sure this message is the last message to be announced when "
"Studio starts."
msgstr ""
"4. Se verbaliza el mensaje de estado. Este mensaje no se verbaliza en el "
"momento si se llama a la función cuando el módulo de aplicación se inicia - "
"se verbalizará el mensaje y se reproducirá un sonido de alarma tras una "
"breve pausa. Esto se hace para asegurarse de que este mensaje es el último "
"que se verbaliza cuando arranca Studio."

#: ..\python_docs\spladdoninternals.py:519
msgid "##### Revisiting the past: object navigation"
msgstr "##### Volviendo al pasado: navegación por objetos"

#: ..\python_docs\spladdoninternals.py:520
msgid ""
"Before the new style routines were written, all commands used object "
"navigation. Typically, the command will use a helper function and an object "
"map to locate the needed object and will announce what you are looking for "
"(typically obj.name or an error message). The process was as follows:"
msgstr ""
"Antes de escribir los procedimientos del nuevo estilo, todas las órdenes "
"usaban navegación por objetos. Normalmente, el comando usará una función "
"auxiliar y un mapa de objetos para ubicar el objeto que necesita y "
"verbalizará lo que estás buscando (normalmente obj.name o un mensaje de "
"error). El proceso era como se describe a continuación:"

#: ..\python_docs\spladdoninternals.py:521
msgid ""
"1. The Studio app module contains a map of indecies where the object lives "
"in relation to the foreground window. For example, for a given object, if "
"index was 0, NVDA nows that the object is the first child of the foreground "
"object. Technically, it is a dictionary of lists, with each list item "
"(indecies) corresponding to the version of Studio the add-on supports."
msgstr ""
"1. El módulo de aplicación de Studio contiene un mapa de índices donde el "
"objeto reside en relación con la ventana en primer plano. Por ejemplo, para "
"un objeto dado, si el índice es 0, NVDA sabe que el objeto es el primer hijo "
"del objeto en primer plano. Técnicamente, es un diccionario de listas, "
"correspondiendo cada elemento de lista (índice) con cada versión de Studio a "
"la que el complemento da soporte."

#: ..\python_docs\spladdoninternals.py:522
msgid ""
"2. To fetch needed objects and to record the command type, a number of "
"constants are defined in the app module (all integers, denoting what you "
"wish to hear). These constants serve as keys to the object index map."
msgstr ""
"2. Para recuperar los objetos necesarios y registrar el tipo de orden, se "
"definen una serie de constantes en el módulo de aplicación (todas enteras, "
"indicando lo que quieres oír). Estas constantes sirven como claves al mapa "
"de índices de objeto."

#: ..\python_docs\spladdoninternals.py:523
msgid ""
"3. After entering SPL Assistant layer and once you press one of the commands "
"below, NVDA will do the following:"
msgstr ""
"3. Después de entrar en la capa del asistente de SPL y una vez que pulses "
"una de las siguientes órdenes, NVDA hará lo siguiente:"

#: ..\python_docs\spladdoninternals.py:524
msgid ""
"\t1. Each command will obtain the object in question by calling object "
"fetcher (status function) with the announcement type as the parameter "
"(status(SPLConstant; for example, for cart edit mode, the signature is self."
"status(self.SPLPlayStatus), with the constant denoting a status bar)."
msgstr ""
"\t1. Cada orden obtendrá el objeto en cuestión llamando al recuperador de "
"objetos (función de estado) pasando como parámetro el tipo de anuncio "
"(estado (SPLConstant; por ejemplo, para el modo de edición de carts, la "
"llamada sería self.status(self.SPLPlayStatus), con la constante indicando "
"una barra de estado)."

#: ..\python_docs\spladdoninternals.py:525
msgid ""
"\t2. The object fetcher (status function) will first consult an object cache "
"(part of the Studio app module) hoping that the needed object is ready for "
"use (for performance reasons)."
msgstr ""
"\t2. El recuperador de objetos (función de estado) consultará primero una "
"caché de objetos (parte del módulo de aplicación de Studio) esperando que el "
"objeto necesario esté listo para usarse (por razones de rendimiento)."

#: ..\python_docs\spladdoninternals.py:526
msgid ""
"\t3. If the object was not cached, the fetcher will first write down the "
"foreground window, then use the directions specified in the object index map "
"(the constant passed into the status function is the key to this map and "
"different values are returned based on Studio version) to locate, cache and "
"return the object in question (in that order)."
msgstr ""
"\t3. Si el objeto no está en la caché, el recuperador anotará primero la "
"ventana en primer plano, luego usará las directrices especificadas en el "
"mapa de índices de objeto (la constante pasada a la función de estado es la "
"clave de este mapa y se devuelven valores diferentes según la versión de "
"Studio) para ubicar, meter en caché y devolver el objeto en cuestión (en ese "
"orden)."

#: ..\python_docs\spladdoninternals.py:527
msgid ""
"\t4. Back at the routine for the command, it is up to the routine as to what "
"to do with it (sometimes, the actual object is a child of the just returned "
"object)."
msgstr ""
"\t4. De vuelta en el procedimiento para esa orden, se hará una cosa u otra "
"con el objeto en función del procedimiento elegido (a veces, el objeto real "
"es hijo del objeto devuelto)."

#: ..\python_docs\spladdoninternals.py:528
msgid "The commands which utilizes object navigation steps above include:"
msgstr ""
"Las órdenes que utilizan los pasos anteriores con navegación por objetos "
"incluyen:"

#: ..\python_docs\spladdoninternals.py:529
msgid "* A. Automation."
msgstr "* A. Automatización."

#: ..\python_docs\spladdoninternals.py:530
msgid "* C: Title of the currently playing track."
msgstr "* C: título de la pista actualmente en reproducción."

#: ..\python_docs\spladdoninternals.py:531
msgid ""
"* I: Listener count (I have tried using Studio API to obtain this "
"information, but after experimenting with it, object navigation routine was "
"more stable)."
msgstr ""
"* I: número de oyentes (he intentado usar la api de Studio para obtener esta "
"información, pero después de experimentar con ella, el procedimiento de "
"navegación por objetos resultó más estable)."

#: ..\python_docs\spladdoninternals.py:532
msgid "* L: Line in."
msgstr "* L: línea de entrada."

#: ..\python_docs\spladdoninternals.py:533
msgid "* M: Microphone."
msgstr "* M: micrófono."

#: ..\python_docs\spladdoninternals.py:534
msgid "* N: Title and duration for the next track."
msgstr "* N: título y duración de la siguiente pista."

#: ..\python_docs\spladdoninternals.py:535
msgid "* Shift+P: Track pitch."
msgstr "* Shift+p: tono de pista."

#: ..\python_docs\spladdoninternals.py:536
msgid "* R: Record to file."
msgstr "* R: grabar a archivo."

#: ..\python_docs\spladdoninternals.py:537
msgid "* S: Track scheduled for."
msgstr "* S: pista programada."

#: ..\python_docs\spladdoninternals.py:538
msgid "* Shift+S: Duration of selected tracks in the current hour slot."
msgstr "* Shift+s: duración de las pistas seleccionadas en la hora actual."

#: ..\python_docs\spladdoninternals.py:539
msgid ""
"* T: Cart Edit Mode (I assigned T to this command for efficiency reasons)."
msgstr ""
"* T: modo de edición de carts (asigné la t a esta orden por razones de "
"eficiencia)."

#: ..\python_docs\spladdoninternals.py:540
msgid "* U: Studio up time."
msgstr "* U: tiempo de funcionamiento de Studio."

#: ..\python_docs\spladdoninternals.py:541
msgid "* W: Weather and temperature (if configured)."
msgstr "* W: tiempo atmosférico y temperatura (si se han configurado)."

#: ..\python_docs\spladdoninternals.py:542
msgid "* Y: Playlist modification."
msgstr "* Y: modificación de lista de reproducción."

#: ..\python_docs\spladdoninternals.py:543
msgid ""
"Note that in Studio 5.20 and later, some of these (such as automation) uses "
"Studio API."
msgstr ""
"Ten en cuenta que en Studio 5.20 y versiones posteriores, algunas de ellas "
"(como la automatización) usan la api de Studio."

#: ..\python_docs\spladdoninternals.py:544
msgid ""
"For example, if you press A to obtain automation status from Studio 5.10:"
msgstr ""
"Por ejemplo, si pulsas la A para obtener el estado de la automatización en "
"Studio 5.10:"

#: ..\python_docs\spladdoninternals.py:545
#: ..\python_docs\spladdoninternals.py:552
msgid "1. Invoke SPL Assistant, then press A."
msgstr "1. Se invoca al asistente de SPL, y luego se pulsa la A."

#: ..\python_docs\spladdoninternals.py:546
msgid ""
"2. The status function (object fetcher) is called, taking the status bar "
"constant (SPLPlayStatus, which is 0) as the key to the index map."
msgstr ""
"2. Se llama a la función de estado (recuperador de objetos), tomando la "
"constante de la barra de estado (SPLPlayStatus, que es 0) como clave para el "
"mapa de índices."

#: ..\python_docs\spladdoninternals.py:547
msgid ""
"3. Object fetcher will see if the status bar object (cache dictionary with "
"the key of 0) has been cached. For this example, it isn't."
msgstr ""
"3. El recuperador de objetos comprobará si el objeto de la barra de estado "
"(diccionario de la caché, clave 0) está cacheado. En este ejemplo, no lo "
"está."

#: ..\python_docs\spladdoninternals.py:548
msgid ""
"4. Seeing that the status bar isn't cached, object fetcher will now look at "
"the index map and will decide which column to read (for this example, it is "
"column 2 (index 1)). The column records the child position of the status bar "
"relative to the foreground window (in our case, index is 6 or the seventh "
"child)."
msgstr ""
"4. Al ver que la barra de estado no está en caché, el recuperador de objetos "
"mirará ahora el mapa de índices y decidirá qué columna va a leer (en este "
"ejemplo, es la columna 2 (índice 1)). La columna registra la posición de la "
"barra de estado hija relativa a la ventana en primer plano (en nuestro caso, "
"se trata del séptimo hijo con índice 6)."

#: ..\python_docs\spladdoninternals.py:549
msgid ""
"5. Once the child object position index is obtained, object fetcher will "
"locate the actual object and cache it (self._cachedStatusObjs[infoIndex] = "
"fg.children[statusObj]), then returns the object to the automation "
"announcement routine."
msgstr ""
"5. Una vez se obtiene el índice de la posición del objeto hijo, el "
"recuperador de objetos ubicará el objeto real y lo meterá en caché (self."
"_cachedStatusObjs[infoIndex] = fg.children[statusObj]), y luego devolverá "
"este objeto a la función de verbalización de automatización."

#: ..\python_docs\spladdoninternals.py:550
msgid ""
"6. Back at the script routine, NVDA will be reminded that it needs to look "
"at one of the object's children (status bars can contain child objects if "
"exposed by accessibility API's), then will announce one of it's contents "
"(second child object, which records automation status)."
msgstr ""
"6. De vuelta en la función del script, se le recordará a NVDA que debe mirar "
"uno de los objetos hijo (las barras de estado pueden contener objetos hijos "
"si las apis de accesibilidad lo exponen así), y luego verbalizará uno de sus "
"contenidos (segundo objeto hijo, que registra el estado de la "
"automatización)."

#: ..\python_docs\spladdoninternals.py:551
msgid "In Studio 5.20 and later:"
msgstr "En Studio 5.20 y posteriores:"

#: ..\python_docs\spladdoninternals.py:553
msgid ""
"2. Calls Studio API to retrieve the given status flag (in this case, 1, "
"which records automation status)."
msgstr ""
"2. Se llama a la api de Studio para recuperar el indicador de estado dado "
"(en este caso es el 1, que registra el estado de automatización)."

#: ..\python_docs\spladdoninternals.py:554
msgid ""
"3. A lookup table with possible status bar messages is then consulted, and "
"the appropriate message based on status flag and value is retrieved and "
"announced."
msgstr ""
"3. Después, se consulta una tabla de búsqueda con posibles mensajes de la "
"barra de estado, y se recupera y verbaliza el mensaje apropiado basándose en "
"el indicador de estado y el valor."

#: ..\python_docs\spladdoninternals.py:555
msgid ""
"Not all status bar messages will use Studio API and status messages table. "
"The lone exception is cart mode status, which requires consulting two flag "
"values returned by Studio to construct the actual announcement (cart edit "
"mode on/off and whether cart insert mode is active)."
msgstr ""
"No todos los mensajes de la barra de estado usarán la api de Studio y la "
"tabla de mensajes de estado. Una excepción es el estado del modo de carts, "
"para el que es necesario consultar dos valores devueltos por Studio para "
"construir el mensaje verbalizado finalmente (modo de edición de carts "
"activado o desactivado y si el modo de edición de carts está activado)."

#: ..\python_docs\spladdoninternals.py:556
msgid "#### SPL Assistant 2: tools"
msgstr "#### Asistente de SPL 2: herramientas"

#: ..\python_docs\spladdoninternals.py:557
msgid ""
"These are miscellaneous commands in SPL Assistant, and three of them use "
"Studio API:"
msgstr ""
"Aquí hay órdenes varias del asistente de SPL, tres de ellas usan la api de "
"Studio:"

#: ..\python_docs\spladdoninternals.py:558
msgid "* D: Remaining time for the opened playlist."
msgstr "* D: tiempo restante de la lista de reproducción abierta."

#: ..\python_docs\spladdoninternals.py:559
msgid ""
"* K: Moves to a marked track. This was discussed in column routines and "
"place marker sections."
msgstr ""
"* K: se mueve a una pista marcada. Ya se habló de esto en las secciones de "
"procedimientos de columna y marcadores."

#: ..\python_docs\spladdoninternals.py:560
msgid ""
"* Control+K: Sets track place marker. Consult the place marker section to "
"learn how it works."
msgstr ""
"* Ctrl+k: sitúa un marcador de pista. Consulta la sección de marcadores para "
"aprender cómo funciona."

#: ..\python_docs\spladdoninternals.py:561
msgid ""
"* Shift+R: Library scan. This is a convenience function to start library "
"scan in the background, useful if you have added new tracks from a number of "
"folders via Studio Options dialog. Consult a previous article on library "
"scan for details on library scan internals."
msgstr ""
"* Shift+r: escaneo de biblioteca. Esta es una función útil para iniciar un "
"escaneo de biblioteca en segundo plano, viene bien si has añadido nuevas "
"pistas desde una serie de carpetas mediante el diálogo de opciones de "
"Studio. Consulta un artículo anterior sobre el escaneo de biblioteca para "
"más detalles sobre el interior de esta característica."

#: ..\python_docs\spladdoninternals.py:562
msgid ""
"* 1 through 0 (6 for studio 5.0x): Columns Explorer (discussed earlier). "
"Unlike other commands in this set, this routine uses Windows API only."
msgstr ""
"* Números del 1 al 0 (6 en Studio 5.0x): explorador de columnas (expuesto "
"anteriormente). Al contrario que otras órdenes de este conjunto, este "
"procedimiento usa sólo la api de Windows."

#: ..\python_docs\spladdoninternals.py:563
#, fuzzy
#| msgid ""
#| "* F8: Obtains playlist snapshot information for the currently loaded "
#| "track. This feature uses a combination of Windows and Studio API's."
msgid ""
"* F8: Obtains playlist snapshot information for the currently loaded track, "
"including track count, shortest and longest tracks and top artists. This "
"feature uses a combination of Windows and Studio API's."
msgstr ""
"* F8: obtiene una instantánea con información de la lista de reproducción "
"para la pista cargada actualmente. Esta función usa una combinación de las "
"apis de Windows y Studio."

#: ..\python_docs\spladdoninternals.py:564
msgid ""
"* Shift+F8: requests a playlist transcript (data about loaded playlist). "
"Just like playlist snapshots, it uses a combination of object navigation and "
"Windows API."
msgstr ""

#: ..\python_docs\spladdoninternals.py:565
msgid ""
"* F9: Marks the current position of the playlist as start of track time "
"analysis (more on this feature below)."
msgstr ""
"* F9: marca la posición actual de la lista de reproducción como inicio del "
"análisis de tiempo de pista (se explica más sobre esto debajo)."

#: ..\python_docs\spladdoninternals.py:566
msgid "* F10: Performs track time analysis (add-on 6.0)."
msgstr "* F10: realiza el análisis de tiempo de pista (complemento 6.0)."

#: ..\python_docs\spladdoninternals.py:567
msgid "##### Track time analysis: Duration of \"selected\" tracks"
msgstr ""
"##### Análisis de tiempo de pista: duración de las pistas seleccionadas"

#: ..\python_docs\spladdoninternals.py:568
msgid ""
"A few months ago, during a Skype chat with a number of add-on users, someone "
"suggested a feature where NVDA will tell you how long it'll take to play "
"selected tracks. Since I was familiar with this concept from JAWS scripts, I "
"decided to work on it as part of add-on 6.0."
msgstr ""
"Hace unos meses, mientras conversaba en un chat de Skype con algunos "
"usuarios del complemento, alguien sugirió una característica que permitiera "
"a NVDA decir cuánto tiempo llevaría reproducir las pistas seleccionadas. Ya "
"que este concepto era familiar para mí porque lo conocía de los scripts de "
"Jaws, decidí trabajar en ello como parte del complemento 6.0."

#: ..\python_docs\spladdoninternals.py:569
msgid ""
"The resulting routine (which is available if you are focused on the main "
"playlist viewer with the playlist loaded) is as follows:"
msgstr ""
"El procedimiento resultante (que está disponible si tienes el foco en el "
"visor principal de la lista de reproducción con la lista de reproducción "
"cargada) es el siguiente:"

#: ..\python_docs\spladdoninternals.py:570
msgid ""
"1. Move to the position in a playlist to mark as start of track time "
"analysis."
msgstr ""
"1. Te mueves a una posición en la lista de reproducción para marcarla como "
"punto de inicio del análisis de tiempo de pista."

#: ..\python_docs\spladdoninternals.py:571
msgid "2. Enter SPL assistant, then press F9."
msgstr "2. Entras al asistente de SPL y pulsas f9."

#: ..\python_docs\spladdoninternals.py:572
msgid ""
"3. Move to another track in the playlist, open SPL Assistant then press F10. "
"NVDA will then:"
msgstr ""
"3. Te mueves a otra pista en la lista de reproducción, abres el asistente de "
"SPL y pulsas f10. A partir de ahí, NVDA:"

#: ..\python_docs\spladdoninternals.py:573
#, fuzzy
#| msgid ""
#| "A. Determine analysis range. For most cases, it'll be top to bottom "
#| "analysis, but in some cases, it could be reverse (bottom to top). Also, a "
#| "variable to hold total duration will be prepared."
msgid ""
"\t1. Determine analysis range. For most cases, it'll be top to bottom "
"analysis, but in some cases, it could be reverse (bottom to top). Also, a "
"variable to hold total duration will be prepared."
msgstr ""
"A. Determina el rango del análisis. En la mayoría de casos será un análisis "
"de arriba a abajo, pero en otros casos podría invertirse (de abajo a "
"arriba). Además, se preparará una variable para almacenar la duración total."

#: ..\python_docs\spladdoninternals.py:574
#, fuzzy
#| msgid ""
#| "B. For each track in the analysis range, NVDA will obtain file name and "
#| "track duration via Studio API. Once the track duration is received, it is "
#| "then added to the total duration variable."
msgid ""
"\t2. For each track in the analysis range, NVDA will obtain file name and "
"track duration (in reality, segue) via Studio API. Once the track duration "
"is received, it is then added to the total duration variable."
msgstr ""
"B. Para cada pista en el rango de análisis, NVDA obtendrá el nombre de "
"archivo y la duración de la pista mediante la api de Studio. Una vez se "
"reciba la duración de la pista, se añadirá a la variable con la duración "
"total."

#: ..\python_docs\spladdoninternals.py:575
#, fuzzy
#| msgid ""
#| "C. Once time analysis (calculating total duration) is done, NVDA will "
#| "announce number of tracks selected and the total duration using mm:ss "
#| "format."
msgid ""
"\t3. Once time analysis (calculating total duration) is done, NVDA will "
"announce number of tracks selected and the total duration using mm:ss format."
msgstr ""
"C. Una vez se hace el análisis de tiempo (cálculo de la duración total), "
"NVDA verbalizará el número de pistas seleccionadas y la duración total "
"usando el formato mm:ss."

#: ..\python_docs\spladdoninternals.py:576
msgid ""
"If you are a seasoned NVDA user, you may have noticed a familiar pattern: "
"the command to set a marker to copy review cursor text is NVDA+F9, and you "
"would move to a different location and press NVDA+F10 to copy the selected "
"text to the clipboard. Replacing the NVDA modifier key with SPL Assistant "
"produces the commands above: F9 to mark current position for time analysis, "
"and F10 to perform the actual calculation. I intentionally chose these two "
"function keys to provide consistent experience and to reenforce concepts "
"used in NVDA screen reader: review cursor."
msgstr ""
"Si eres un usuario experto de NVDA, puedes haberte dado cuenta de un patrón "
"familiar: la orden para situar un marcador para copiar texto del cursor de "
"revisión es NVDA+f9, y te moverías a una ubicación diferente y pulsarías NVDA"
"+f10 para copiar el texto seleccionado al portapapeles. Reemplazando la "
"tecla modificadora de NVDA con el asistente de SPL produce un resultado "
"parecido: f9 marca la posición inicial del análisis de tiempo, y f10 realiza "
"el cálculo. Elegí estas dos teclas de función intencionadamente para "
"proporcionar una experiencia consistente y reforzar conceptos usados en el "
"lector de pantalla NVDA: el cursor de revisión."

#: ..\python_docs\spladdoninternals.py:577
msgid "##### Playlist remainder announcement"
msgstr "##### Anuncio de tiempo restante de la lista de reproducción"

#: ..\python_docs\spladdoninternals.py:578
msgid ""
"Until add-on 6.x, playlist remainder announcement was based on Studio API. "
"However, it was found that this \"remainder\" was actually the remaining "
"time within the selected hour slot. To get around this, in add-on 7.0, this "
"routine was rewritten to take advantage of Track Dial introduced in add-on "
"5.0 (see Track Dial section above)."
msgstr ""
"Hasta el complemento 6.x, el anuncio de tiempo restante de la lista de "
"reproducción estaba basado en la api de Studio. Sin embargo, nos dimos "
"cuenta de que este \"tiempo restante\" era el de la hora actual. Para "
"solucionarlo, en el complemento 7.0 se reescribió este procedimiento para "
"aprovechar la ventaja que daba el dial de pista introducido en el "
"complemento 5.0 (mira la sección de más arriba sobre el dial de pista)."

#: ..\python_docs\spladdoninternals.py:579
msgid ""
"Technically, a combination of column content fetching and track navigation "
"routines are used to accomplish this. When SPL Assistant, D is pressed, NvDA "
"will write down the focused track and will move down the playlist (starting "
"from the focused track), recording the segue (total track duration minus "
"crossfade). Once playlist navigation is complete, the total duration is then "
"sent to time announcement routine (see above) for processing (converted to "
"hours, minutes and seconds format)."
msgstr ""
"Técnicamente, se aplica una combinación de de recuperación de contenido de "
"columnas y procedimientos de navegación por pistas para solucionar el "
"problema. Al pulsar asistente de SPL, D, NVDA anotará la pista con el foco y "
"se moverá hacia abajo en la lista de reproducción (empezando desde la pista "
"con el foco), registrando la secuencia (duración total de pista menos "
"transición). En cuanto se completa la navegación por la lista de "
"reproducción, se envía la duración total al procedimiento de verbalización "
"de tiempo (mira arriba) para su procesamiento (conversión al formato de "
"horas, minutos y segundos)."

#: ..\python_docs\spladdoninternals.py:580
#, fuzzy
#| msgid "* Playlist snapshots."
msgid "##### Playlist snapshots and transcripts"
msgstr "* Instantáneas de lista de reproducción."

#: ..\python_docs\spladdoninternals.py:581
msgid ""
"Although similar in appearance, playlist snapshots and transcripts are two "
"different things. Both uses a combination of object navigation and Windows "
"API, work by retrieving and analyzing column content for tracks, and involve "
"SPL Assistant followed by F8 with or without modifiers. Whereas a snapshot "
"is used to gather statistics about the loaded playlist, a transcript is the "
"entire playlist formatted in different ways. Also, after invoking SPL "
"Assistant layer, just pressing F8 will launch snapshots, whereas you need to "
"press Shift+F8 to obtain a playlist transcript and choose appropriate action "
"such as transcript range, output format and so on via the dialog that "
"appears afterwards."
msgstr ""

#: ..\python_docs\spladdoninternals.py:582
msgid ""
"A playlist snapshot presents statistics about the currently loaded playlist "
"(or parts of it). Information gathered include how many items (including "
"hour markers) are loaded, longest and shortest tracks, and average track "
"duration. Also, if asked to do so, up to top ten artists, categories, and/or "
"track genres are recorded. This information is presented either via speech "
"and braille, or if the command is pressed twice, in a browse mode window."
msgstr ""

#: ..\python_docs\spladdoninternals.py:583
msgid ""
"In contrast, a playlist transcript is the complete overview of the loaded "
"playlist (or parts of it) presented in various formats. This complete "
"overview includes data from all columns (not just the ones examined by "
"playlist snapshots). Once data from all columns are gathered for a track, "
"NVDA will convert this information into various formats, including plain "
"text, HTML table, comma-separated values (CSV) and so on for viewing in a "
"browse mode window, copying to clipboard (for some formats), or saving to a "
"file."
msgstr ""

#: ..\python_docs\spladdoninternals.py:584
msgid "#### SPL Assistant 3: configuration"
msgstr "#### Asistente de SPL 3: configuración"

#: ..\python_docs\spladdoninternals.py:585
msgid ""
"There is another function key assigned to SPL Assistant: pressing F12 will "
"switch to an instant switch profile (if defined). We'll come back to what is "
"meant by \"instant switch profile\" and the mechanics of it (and internals "
"of SPL Assistant, F12) in the next article."
msgstr ""
"Hay otra tecla de función asignada al asistente de SPL: pulsar f12 cambiará "
"a un perfil de cambio instantáneo (si está definido). Volveremos a explicar "
"qué se entiende por \"perfil de cambio instantáneo\" y sus mecanismos (y el "
"interior del asistente de SPL, f12) en el próximo artículo."

#: ..\python_docs\spladdoninternals.py:586
msgid "#### SPL Assistant 4: getting help"
msgstr "#### Asistente de SPL 4: conseguir ayuda"

#: ..\python_docs\spladdoninternals.py:587
msgid ""
"I believe that a product isn't complete without a good quality "
"documentation. For this reason, SPL Assistant provides two commands to help "
"you use the layer commands or the add-on itself. They are:"
msgstr ""
"Yo creo que un producto no está completo sin una buena documentación de "
"calidad. Por esta razón, el asistente de SPL proporciona dos órdenes para "
"ayudarte a usar la capa de órdenes o el complemento en sí. Son las "
"siguientes:"

#: ..\python_docs\spladdoninternals.py:588
msgid ""
"* F1: Displays a dialog presenting a list of SPL Assistant layer commands."
msgstr ""
"* F1: muestra un diálogo que presenta una lista de órdenes de la capa del "
"asistente de SPL."

#: ..\python_docs\spladdoninternals.py:589
msgid "* Shift+F1: Opens the online user guide (os.startfile)."
msgstr "* Shift+f1: abre la guía de usuario en línea (os.startfile)."

#: ..\python_docs\spladdoninternals.py:590
msgid "#### SPL Assistant 5: Checking for add-on updates"
msgstr "#### Asistente de SPL 5: búsqueda de actualizaciones"

#: ..\python_docs\spladdoninternals.py:591
msgid ""
"Pressing Control+Shift+U after entering SPL Assistant layer will cause the "
"add-on to check for add-on updates. Unlike the automatic update check "
"process described earlier, this one is a manual check, thus it'll perform "
"additional actions such as stopping the automatic update check timer before "
"actually checking for updates. Another difference is that this command will "
"display a results dialog if there are no updates or other errors are "
"encountered, whereas in automatic check mode, they are not shown."
msgstr ""
"Si pulsas ctrl+shift+u después de entrar en la capa del asistente de SPL "
"hará que el complemento busque actualizaciones de sí mismo. A diferencia del "
"proceso automático de búsqueda de actualizaciones descrito anteriormente, "
"esta es una búsqueda manual, y por tanto llevará a cabo acciones adicionales "
"como detener el temporizador de búsqueda automática de actualizaciones antes "
"de buscar actualizaciones realmente. Otra diferencia es que esta orden "
"mostrará un diálogo de resultados si no hay actualizaciones o se encuentran "
"otros errores, mientras que en el modo de búsqueda automática, no se "
"muestran."

#: ..\python_docs\spladdoninternals.py:592
msgid ""
"### A surprise: some Assistant layer commands can be invoked without "
"entering the layer first"
msgstr ""
"### Una sorpresa: pueden invocarse algunas órdenes de la capa del asistente "
"sin entrar a ella primero"

#: ..\python_docs\spladdoninternals.py:593
msgid ""
"There are times when a broadcaster will need to obtain certain information "
"quickly. So the question becomes, \"is there a way to announce something "
"without first invoking Assistant layer?\" Yes, you can assign a custom "
"command for the following Assistant commands:"
msgstr ""
"Hay veces en las que un locutor querrá obtener cierta información "
"rápidamente. Por eso nos hacemos la siguiente pregunta: \"¿Hay forma de "
"verbalizar algo sin tener que invocar primero la capa del asistente?\". Sí, "
"se puede asignar una orden personalizada a las siguientes funciones del "
"asistente:"

#: ..\python_docs\spladdoninternals.py:594
msgid "* Name of the next track."
msgstr "* Nombre de la próxima pista."

#: ..\python_docs\spladdoninternals.py:595
msgid "* Name of the current track."
msgstr "* Nombre de la pista actual."

#: ..\python_docs\spladdoninternals.py:596
msgid "* Weather and temperature."
msgstr "* Tiempo y temperatura."

#: ..\python_docs\spladdoninternals.py:597
msgid "* Playlist snapshots."
msgstr "* Instantáneas de lista de reproducción."

#: ..\python_docs\spladdoninternals.py:598
msgid "* Track time analysis marker."
msgstr "* Marcador de análisis de tiempo de pista."

#: ..\python_docs\spladdoninternals.py:599
msgid "* Track time analysis."
msgstr "* Análisis de tiempo de pista."

#: ..\python_docs\spladdoninternals.py:600
msgid ""
"For these routines, an extra step is performed to make sure that SPL "
"Assistant flag is turned off automatically after the shortcut for these "
"routines are pressed. Without this step, you might end up with a situation "
"like the following:"
msgstr ""
"En estos procedimientos, se lleva a cabo un paso adicional para asegurarse "
"de que el indicador del asistente de SPL se apaga automáticamente tras "
"pulsar el atajo de teclado en cuestión. Sin este paso, podrías acabar en una "
"situación como la siguiente:"

#: ..\python_docs\spladdoninternals.py:601
msgid "1. You invoke Assistant layer."
msgstr "1. Invocas la capa del asistente."

#: ..\python_docs\spladdoninternals.py:602
msgid ""
"2. You then press the shortcut key (not the layer counterpart) for the layer "
"command you wish to use."
msgstr ""
"2. Después pulsas la tecla rápida para la orden de capa que quieras usar "
"(sin activar la capa antes)."

#: ..\python_docs\spladdoninternals.py:603
msgid ""
"3. You press another key which may announce something else, or you hear the "
"same thing twice if you do press the layer command counterpart to the "
"command you have pressed. In effect, you have invoked two layer commands in "
"one sitting (the purpose of the layer set is to let you hear one "
"announcement at a time)."
msgstr ""
"3. Pulsas otra tecla que puede verbalizar algo más, o incluso oyes lo mismo "
"dos veces si pulsas el atajo de la capa homólogo a la orden que has pulsado. "
"En efecto, has invocado dos órdenes de capa de una vez (el propósito del "
"conjunto de capas es dejarte oír un mensaje a la vez)."

#: ..\python_docs\spladdoninternals.py:604
msgid ""
"## Introducing configuration facilities: add-on settings dialog and "
"broadcast profiles"
msgstr ""
"## Presentación de las funciones de configuración: diálogo de ajustes del "
"complemento y perfiles de emisión"

#: ..\python_docs\spladdoninternals.py:605
msgid ""
"We have arrived at our last station stop for Studio app module internals: "
"configuration management. This facility allows a broadcaster to configure "
"various options such as alarms, column announcement order and so on, as well "
"as package settings for a show as a broadcast profile to be invoked during "
"the show. Along the way you'll learn how NVDA screen reader stores various "
"settings, what happens if something goes wrong and get into internals of how "
"broadcast profiles work."
msgstr ""
"Hemos llegado a nuestra última parada del módulo de aplicación de Studio "
"visto por dentro: gestión de la configuración. Esta característica permite "
"que un locutor configure diversas opciones, como alarmas, orden de "
"verbalización de columnas y demás, así como empaquetar ajustes para un "
"programa como un perfil de emisión para invocarlo durante el programa. "
"Durante el camino aprenderás cómo almacena el lector de pantalla NVDA "
"diversos ajustes, qué pasa si algo va mal y verás cómo están hechos por "
"dentro los perfiles de emisión."

#: ..\python_docs\spladdoninternals.py:606
msgid "### ConfigObj: NVDA's configuration manager assistant"
msgstr "### ConfigObj: asistente de gestión de la configuración de NVDA"

#: ..\python_docs\spladdoninternals.py:607
msgid ""
"NVDA uses ConfigObj library to manage settings. This Python module, inspired "
"by Python's own Config Parser, allows developers to store settings in a text "
"file, read and interpret settings and validate options against default "
"configuration options."
msgstr ""
"NVDA usa la biblioteca ConfigObj para gestionar sus ajustes. Este módulo "
"Python, inspirado en el propio intérprete de configuración de Python, "
"permite que los desarrolladores almacenen ajustes en un fichero de texto, "
"leer e interpretar ajustes y validar opciones basándose en opciones de "
"configuración por defecto."

#: ..\python_docs\spladdoninternals.py:608
msgid ""
"NVDA comes with a collection of default options. They live in source/config/"
"__init__ and are used for various things, including presenting preferences, "
"validating user configuration and so on. The config management module also "
"includes facilities to handle profiles (a package of user settings to be "
"used in an app, during say all or reserved for manual activation)."
msgstr ""
"NVDA viene con una colección de opciones por defecto. Estas residen en "
"source/config/__init__ y se emplean para varias cosas, incluyendo la "
"presentación de preferencias, validación de configuración de usuario y "
"demás. El módulo de gestión de configuración también incluye funciones para "
"gestionar perfiles (un paquete de ajustes de usuario que se emplea en una "
"aplicación, al verbalizar todo o se reserva para activación manual)."

#: ..\python_docs\spladdoninternals.py:609
msgid ""
"### NVDA configuration profiles: multiple configuration files, one online "
"database"
msgstr ""
"### Perfiles de configuración de NVDA: varios archivos de configuración, una "
"única base de datos en línea"

#: ..\python_docs\spladdoninternals.py:610
msgid ""
"A number of users asked NV Access if it would be possible to have profiles "
"where certain settings can take effect while one is using apps or during say "
"all. NV Access listened and introduced configuration profiles in late 2013. "
"As of August 2015, one can create a manual or an automated (triggered) "
"profile, with the latter further divided into say all profile and app-"
"specific one."
msgstr ""
"Muchos usuarios preguntaron a NV Access si sería posible perfiles donde "
"ciertos ajustes tengan efecto mientras se esté usando una aplicación o la "
"función de verbalizar todo. NV Access escuchó e introdujo los perfiles de "
"configuración ya entrado 2013. Desde agosto de 2015, se pueden crear perfil "
"manual o automático (disparado), con estos últimos divididos en perfiles de "
"verbalizar todo y específicos de una aplicación."

#: ..\python_docs\spladdoninternals.py:611
msgid ""
"Configuration profiles involve a few support routines and a careful "
"coordination between configuration files. In essence, each configuration "
"profile (stored in profiles folder in user configuration folder) is a "
"snapshot of differences between the profile and the main user configuration "
"file (named nvda.ini). When a profile becomes active, NVDA will load the "
"profile file associated with the given profile and modify user settings "
"according to values stored in the newly activated profile, and wwill record "
"the name of the profile file to remind itself as to which profile is active "
"(the default user configuration profile is named \"normal configuration\" "
"with the file name of nvda.ini)."
msgstr ""
"Los perfiles de configuración implican unos cuantos procedimientos de "
"soporte y una cuidadosa coordinación entre archivos de configuración. En "
"esencia, cada perfil de configuración (almacenado en la carpeta profiles en "
"el directorio de configuración de usuario) es una instantánea de diferencias "
"entre el perfil y el archivo de configuración principal del usuario (llamado "
"nvda.ini). Cuando un perfil se activa, NVDA cargará el archivo de perfil "
"asociado con el perfil dado y modificará los ajustes del usuario en función "
"de los valores almacenados en el perfil recién activado. También registrará "
"el nombre del archivo de perfil para recordarse a sí mismo qué perfil está "
"activo (el perfil de configuración por defecto del usuario se llama "
"\"Configuración normal\" y tiene como nombre de archivo nvda.ini)."

#: ..\python_docs\spladdoninternals.py:612
msgid ""
"What if settings had errors? As part of the startup routine (portions of "
"main function (source/core.py) prior to entering the main loop), NVDA will "
"display a configuration error dialog if it detects serious issues with "
"configuration values (in reality, ConfigObj notifies NVDA of this problem). "
"You'll see this is also implemented in the Studio app module to deal with "
"add-on configuration issues."
msgstr ""
"¿Y si los ajustes tuvieran errores? Como parte del procedimiento de "
"inicialización (partes de la función principal (source/core.py) antes de "
"entrar en el bucle principal), NVDA mostrará un diálogo de error de "
"configuración si detecta problemas serios con los valores de configuración "
"(en realidad, ConfigObj notifica a NVDA de este problema). Verás que esto "
"también está implementado en el módulo de aplicación de Studio para tratar "
"con los problemas de configuración del complemento."

#: ..\python_docs\spladdoninternals.py:613
msgid "### All about Studio add-on Configuration Manager"
msgstr "### Todo sobre el gestor de configuración del complemento de Studio"

#: ..\python_docs\spladdoninternals.py:614
msgid ""
"Until recently, Studio app module handled all add-on configuration routines. "
"With the advent of add-on 5.0 which introduced add-on settings dialog, "
"configuration management routines were split into a dedicated Configuration "
"Manager (splstudio.splconfig). The new module takes care of configuration "
"routines, including validating the user configuration, presenting add-on "
"settings dialog and other dialogs inside it, handling broadcast profiles and "
"more. In add-on 7.0, routines pertaining to configuration dialog were split "
"into splconfui module, with the main add-on settings listed under NVDA "
"preferences menu."
msgstr ""
"Hasta hace poco, el módulo de aplicación de Studio se encargaba de la "
"gestión de la configuración del complemento. Con la llegada del complemento "
"5.0 y el diálogo de ajustes del complemento, los procedimientos de gestión "
"de configuración se movieron a un gestor de configuración dedicado "
"(splstudio.splconfig). El nuevo módulo se encarga de las funciones de "
"configuración, incluida su validación, la presentación del diálogo de "
"ajustes del complemento y otros diálogos dentro de él, la gestión de "
"perfiles de emisión y más. En el complemento 7.0, los procedimientos "
"pertenecientes al diálogo de configuración se movieron al módulo splconfui, "
"estando los ajustes principales del complemento listados en el menú de "
"preferencias de NVDA."

#: ..\python_docs\spladdoninternals.py:615
msgid "### How settings are loaded, used and saved"
msgstr "### Cómo se cargan, se usan y se guardan los ajustes"

#: ..\python_docs\spladdoninternals.py:616
msgid ""
"As mentioned in the chapter on life of the Studio app module, one of the "
"things the app module does is load the add-on configuration database by "
"calling splconfig.initialize function. The job of this function is to load "
"the add-on configuration map from various places (for add-on 5.x, it will be "
"the main configuration map only, while 6.0 also searches appModules/profiles "
"folder to load broadcast profiles). The format of the configuration file is "
"that of a typical ini file, and as far as NVDA is concerned, it is a "
"dictionary."
msgstr ""
"Como se menciona en el capítulo que habla del ciclo de vida del módulo de "
"aplicación de Studio, una de las cosas que el módulo de aplicación hace es "
"cargar la base de datos con la configuración del complemento llamando a la "
"función splconfig.initialize. El trabajo de esta función es cargar el mapa "
"de configuración del complemento de diversos lugares (en el complemento 5.x, "
"será sólo el mapa de configuración principal, mientras que el 6.0 también "
"busca en la carpeta appModules/profiles para cargar los perfiles de "
"emisión). El formato del archivo de configuración es el de un archivo ini "
"típico, y tal y como NVDA está concebido, se trata de un diccionario."

#: ..\python_docs\spladdoninternals.py:617
msgid ""
"When the configuration database is ready, Studio app module will then use "
"values stored in this settings dictionary to perform various tasks, "
"including microphone alarm, announcing listener count and so on. If multiple "
"profiles are defined, NVDA will start with the first configuration map "
"(normal profile), and the active profile is denoted by splconfig.SPLConfig "
"map (more on profiles in a moment)."
msgstr ""
"Cuando la base de datos de configuración está lista, el módulo de aplicación "
"empleará los valores almacenados en este diccionario de ajustes para llevar "
"a cabo diversas tareas, incluyendo la alarma del micrófono, verbalización "
"del número de oyentes y demás. Si se han definido varios perfiles, NVDA "
"empezará con el primer mapa de configuración (perfil normal), y el perfil "
"activo irá determinado por el mapa splconfig.SPLConfig (más sobre los "
"perfiles en un momento)."

#: ..\python_docs\spladdoninternals.py:618
msgid ""
"After you are done using Studio, close Studio so settings can be saved to "
"disk. This involves saving individual profiles, copying global settings to "
"the normal profile and saving the normal profile to disk."
msgstr ""
"Después de que acabes de usar Studio, ciérralo para que los ajustes puedan "
"guardarse a disco. Esto implica guardar perfiles individuales, copiar los "
"ajustes globales al perfil normal y guardar el perfil normal a disco."

#: ..\python_docs\spladdoninternals.py:619
msgid "### The Studio Add-on Settings Dialog"
msgstr "### El diálogo de ajustes del complemento de Studio"

#: ..\python_docs\spladdoninternals.py:620
msgid ""
"Studio app module allows you to configure various settings in two ways: via "
"a shortcut key (discussed in an article on configuring basic settings) or "
"via the settings dialog. When you use a shortcut key to change settings, "
"NVDA will look up the value for the setting, change it, announce the new "
"setting and store the newly changed value in the settings map."
msgstr ""
"El módulo de aplicación de Studio te permite configurar diversos ajustes de "
"dos formas: mediante un atajo de teclado (expuesto en un artículo que habla "
"de configurar ajustes básicos), o mediante el diálogo de ajustes. Cuando "
"usas un atajo de teclado para cambiar ajustes, NVDA buscará el valor para el "
"ajuste, lo cambiará, verbalizará el nuevo ajuste y almacenará el valor "
"recién cambiado en el mapa de ajustes."

#: ..\python_docs\spladdoninternals.py:621
msgid ""
"Alternatively, you can configure settings via the add-on settings dialog (Alt"
"+NVDA+0). As it is a settings dialog (powered by gui.SettingsDialog), it "
"will look just like any NVDA preferences dialog. For some advanced options, "
"this dialog is the only gateway to access them (covered below)."
msgstr ""
"Alternativamente, puedes configurar los ajustes mediante el diálogo de "
"ajustes del complemento (alt+NVDA+0). Como es un diálogo de preferencias "
"(proporcionado por gui.SettingsDialog), será muy parecido a todos los "
"diálogos de preferencias de NVDA. Este diálogo es la única puerta para "
"llegar a algunas opciones avanzadas (explicadas debajo)."

#: ..\python_docs\spladdoninternals.py:622
msgid ""
"Until 2018, add-on settings were divided into various dialogs. With the "
"release of NVDA 2018.2, it became possible to house all settings under one "
"roof, divided into various settings panels. Visually, it resembles a two-"
"column layout, with the left column showing a list of settings categories, "
"and the right column displaying settings for the chosen category. See below "
"for notes on multi-category settings."
msgstr ""
"Hasta 2018, las opciones del complemento estaban divididas en varios "
"diálogos. Con la llegada de NVDA 2018.2, se hizo posible alojar todas las "
"opciones bajo un mismo techo, divididas en diversos paneles de ajustes. "
"Visualmente, recuerda a una disposición en dos columnas, teniendo la columna "
"de la izquierda una lista de categorías de opciones, y la columna derecha "
"mostrando los ajustes de la categoría elegida. Mira más abajo para ver notas "
"sobre las opciones multicategoría."

#: ..\python_docs\spladdoninternals.py:623
msgid ""
"The add-on settings dialog (splconfui.SPLConfigDialog) contains following "
"options:"
msgstr ""
"El diálogo de ajustes del complemento (splconfui.SPLConfigDialog) contiene "
"las siguientes opciones:"

#: ..\python_docs\spladdoninternals.py:624
msgid ""
"* Broadcast profile controls (add-on 6.0 and later): inspired by NVDA screen "
"reader's configuration profiles dialog, this group of controls shows a list "
"of profiles loaded and buttons to create a brand new profile or a copy of an "
"existing profile, rename and delete profiles. It also contains a button "
"(really a toggle button) that tells NVDA to switch to the selected profile "
"upon request (more on this in a second)."
msgstr ""
"* Controles de los perfiles de emisión (complemento 6.0 y posteriores): "
"inspirado en el diálogo de perfiles de configuración del lector de pantalla "
"NVDA, este grupo de controles muestra una lista de perfiles cargados y "
"botones para crear un nuevo perfil o copiar un perfil existente, renombrar y "
"eliminar perfiles. También contiene un botón (en realidad un botón de "
"conmutación) que hace que NVDA cambie al perfil seleccionado a petición (más "
"sobre esto en un segundo)."

#: ..\python_docs\spladdoninternals.py:625
msgid ""
"* Global settings: these are settings not affected by profiles. These "
"include status announcements, announcing listener count, library scan "
"options and so on."
msgstr ""
"* Ajustes globales: son ajustes a los que no les afectan los perfiles. Estos "
"incluyen anuncios de estado, verbalización del número de oyentes, opciones "
"del escaneo de biblioteca y demás."

#: ..\python_docs\spladdoninternals.py:626
msgid ""
"* Profile-specific settings: Currently alarms, metadata streaming and column "
"announcement settings are profile-specific. These are end of track alarm and "
"the option to use this alarm, song ramp (intro) time and the setting to use "
"this alarm, microphone alarm and microphone alarm interval. It also includes "
"URL's for metadata streaming and column announcement order and inclusion. "
"For numeric settings such as alarm value, it is a spin control (wx.SpinCtrl; "
"use up or down arrow keys to change them)."
msgstr ""
"* Ajustes específicos del perfil: actualmente las alarmas, el flujo de "
"metadatos y los ajustes de verbalización de columnas son específicos del "
"perfil. Estos son la alarma de fin de pista y la opción para usarla, la "
"alarma de introducción y el ajuste para usarla, la alarma del micrófono y el "
"intervalo de alarma de micrófono. También se incluyen URLS para flujo de "
"metadatos y orden de verbalización e inclusión de columnas. Para los ajustes "
"numéricos como el valor de la alarma, se muestra un botón giratorio (wx."
"SpinCtrl; usa las flechas arriba y abajo para cambiarlos)."

#: ..\python_docs\spladdoninternals.py:627
msgid ""
"* Reset settings: NVDA will ask if you wish to reset settings in the "
"currently active profile back to factory defaults. This is done by using a "
"function in splconfig module (splconfig.resetConfig) that will set current "
"profile values to defaults (a default configuration map is included for this "
"purpose; this map uses a configuration specification (confspec, part of "
"defining validation routine via validator module (a close friend of "
"ConfigObj), and this confspec is defined in the splconfig module)."
msgstr ""
"* Restablecer ajustes: NVDA te preguntará si quieres restablecer los ajustes "
"del perfil activo actualmente a los que vienen por defecto de fábrica. Esto "
"se hace usando una función en el módulo splconfig (splconfig.resetConfig) "
"que establecerá los valores del perfil actual a los que vienen por defecto "
"(con este propósito se incluye un mapa con la configuración por defecto; "
"este mapa usa una especificación de configuración (confspec, parte de la "
"definición del proceso de validación mediante el módulo validator (un amigo "
"cercano de ConfigObj), la confspec se define en el módulo splconfig)."

#: ..\python_docs\spladdoninternals.py:628
msgid ""
"When you press Alt+NVDA+0 from Studio to open this dialog, the following "
"will happen:"
msgstr ""
"Cuando pulses alt+NVDA+0 desde Studio para abrir este diálogo, ocurrirá lo "
"siguiente:"

#: ..\python_docs\spladdoninternals.py:629
msgid ""
"1. Just like alarm dialogs (see above), NVDA will make sure no other dialogs "
"are open."
msgstr ""
"1. Al igual que con los diálogos de alarma (mira los artículos anteriores), "
"NVDA se asegurará de que no hay otros diálogos abiertos."

#: ..\python_docs\spladdoninternals.py:630
msgid ""
"2. It'll then call a function in splconfui module, which in turn will "
"prepare the dialog to be shown."
msgstr ""
"2. Después llamará a una función en el módulo splconfui, que se encargará de "
"preparar el diálogo a mostrar."

#: ..\python_docs\spladdoninternals.py:631
msgid ""
"3. The preparation routine (SettingsDialog.makeSettings) will populate the "
"dialog with controls and options associated with each control, with current "
"options coming from configuration values stored in the active profile."
msgstr ""
"3. El procedimiento de preparación (SettingsDialog.makeSettings) poblará el "
"diálogo con controles y opciones asociadas con cada control. Las opciones "
"actuales vendrán de los valores de configuración almacenados en el perfil "
"activo."

#: ..\python_docs\spladdoninternals.py:632
msgid ""
"4. Once the dialog is ready, it'll pop up and you'll land on \"General add-"
"on settings\" button (formerly status message checkbox) or list of active "
"profiles depending on the add-on version and add-on command-line switches "
"(former is 5.x or restrictions on loading profiles is in place, latter is "
"6.0 and no restrictions). You can then use typical dialog navigation "
"commands to navigate through various options."
msgstr ""
"4. Una vez el diálogo esté listo, aparecerá y aterrizarás en el botón "
"\"Ajustes generales del complemento\" (anteriormente la casilla de "
"verificación del mensaje de estado) o en la lista de perfiles activos, según "
"la versión del complemento que tengas y los argumentos de la línea de "
"órdenes del complemento (lo primero pasa en la 5.x o cuando haya "
"restricciones en la carga de perfiles, lo segundo en la 6.0 y sin "
"restricciones). A partir de ahí ya puedes usar órdenes estándar de "
"navegación por diálogos para desplazarte por las distintas opciones."

#: ..\python_docs\spladdoninternals.py:633
msgid ""
"After configuring some settings, click OK or Apply. NVDA will then locate "
"the selected profile and tell SPLConfig to use this profile, then store "
"options from the settings dialog into the configuration map. If Apply button "
"is pressed and if the selected profile is not the active one, NVDA will "
"present a message reminding users that settings will be saved to the profile "
"selected from settings dialog, not the active one at the moment. After that, "
"changes will be saved and add-on settings will reappear."
msgstr ""
"Después de configurar algunos ajustes, haz clic en aceptar o aplicar. NVDA "
"localizará a continuación el perfil seleccionado y pedirá a SPLConfig que "
"use este perfil, luego almacenará las opciones del diálogo de ajustes dentro "
"del mapa de configuración. Si se pulsa el botón aplicar y el perfil "
"seleccionado no es el perfil activo, NVDA mostrará un mensaje recordando a "
"los usuarios que los ajustes se guardarán en el perfil seleccionado en el "
"diálogo de ajustes, y no en el que esté activo en ese momento. Después de "
"eso, se guardarán los cambios y reaparecerán los ajustes del complemento."

#: ..\python_docs\spladdoninternals.py:634
msgid ""
"In case you discard new settings (clicking Cancel), NVDA will check to see "
"if an instant switch profile is defined, and if so, it'll perform various "
"operations depending on whether the instant profile has been renamed or "
"deleted."
msgstr ""
"En el caso de que descartes los nuevos ajustes (haciendo clic en cancelar), "
"NVDA comprobará si se ha definido un perfil de cambio instantáneo, y si es "
"así, realizará varias operaciones dependiendo de si el perfil instantáneo se "
"ha renombrado o eliminado."

#: ..\python_docs\spladdoninternals.py:635
msgid "#### Multi-category settings"
msgstr "#### Ajustes en varias categorías"

#: ..\python_docs\spladdoninternals.py:636
msgid ""
"The description above refers to the old add-on settings interface, which was "
"based on old NVDA settings routines. In the past, there were discussions "
"between add-on users regarding changing the current add-on interface to that "
"of a multi-category settings interface so all add-on settings can be found "
"under one roof."
msgstr ""
"La descripción anterior se refiere a la interfaz antigua de ajustes del "
"complemento, que estaba basada en las funciones antiguas de ajustes de NVDA. "
"En el pasado hubo debates entre los usuarios del complemento relacionados "
"con cambiar la interfaz actual del complemento a una interfaz agrupada en "
"categorías de tal forma que todos los ajustes del complemento se encuentren "
"bajo un mismo techo."

#: ..\python_docs\spladdoninternals.py:637
msgid ""
"In the old days, if one wanted to change settings in NVDA, one would open "
"NVDA's preferences menu and hunt for correct dialog. For instance, when "
"changing browse mode related settings, the place to go was NVDA menu/"
"Preferences/Browse Mode. This meant settings were scattered throughout "
"different dialogs."
msgstr ""
"En los viejos tiempos, si se querían modificar ajustes en NVDA, había que "
"abrir el menú de preferencias de NVDA y elegir el diálogo correcto. Por "
"ejemplo, al cambiar los ajustes relacionados con el modo exploración, el "
"lugar al que ir era menú de NVDA / preferencias / modo exploración. Esto "
"significaba que la configuración estaba dispersa a lo largo de diferentes "
"diálogos."

#: ..\python_docs\spladdoninternals.py:638
msgid ""
"In 2018, a major paradigm shift occurred in NVDA's own user interface: multi-"
"category settings screen. In NVDA 2018.2, a new settings screen, combining "
"various dialogs into a panel, launched. For many settings, one can now open "
"NVDA Menu/Preferences/Settings, select the desired settings category, then "
"change settings. This also had the benefit of moving many settings under one "
"roof."
msgstr ""
"En 2018, se produjo un cambio importante en el paradigma de la propia "
"interfaz de usuario de NVDA: la pantalla de opciones en categorías. En NVDA "
"2018.2 se lanzó una nueva pantalla de ajustes, combinando varios diálogos en "
"un panel. Para muchos ajustes, ahora se puede abrir el menú de NVDA / "
"preferencias / opciones, seleccionar la categoría de ajustes deseada, y "
"luego cambiar los ajustes. Esto también tuvo el beneficio de mover muchos "
"ajustes bajo un solo techo."

#: ..\python_docs\spladdoninternals.py:639
msgid ""
"As a follow-up to this development, Studio add-on settings has undergone a "
"major facelift. As noted throughout this article, add-on settings are housed "
"under various dialogs, with the main add-on settings dialog serving as a "
"gateway to these dialogs. In 2018, this has changed into a multi-category "
"settings screen."
msgstr ""
"Como un seguimiento a este desarrollo, los ajustes del complemento de Studio "
"están sufriendo un lavado de cara. Como se observa a lo largo de este "
"artículo, los ajustes del complemento se alojan bajo diversos diálogos, "
"sirviendo el diálogo principal de ajustes del complemento como una puerta "
"hacia estos diálogos. En 2018, esto se ha convertido en una pantalla de "
"ajustes con varias categorías."

#: ..\python_docs\spladdoninternals.py:640
msgid "### All about broadcast profiles"
msgstr "### Todo sobre los perfiles de emisión"

#: ..\python_docs\spladdoninternals.py:641
msgid ""
"In Studio app module world, a broadcast profile (usually shortened to "
"profile) is a group of settings to be used in a show. This is achieved by "
"using a configuration profile container (splconfig.SPLConfigPool for add-on "
"6.x and 7.x, splconfig.SPLConfig.profiles for 8.0 and later) for storing "
"these profiles, and one of them is used at any given time (by default, the "
"first profile)."
msgstr ""
"En el mundo del módulo de aplicación de Studio, un perfil de emisión (o "
"simplemente perfil, para abreviar) es un grupo de ajustes que se usan en un "
"programa. Esto se lleva a cabo empleando un contenedor de perfiles de "
"configuración (splconfig.SPLConfigPool en los complementos 6.x y 7.x, "
"splconfig.SPLConfig.profiles en 8.0 y posteriores) para almacenar estos "
"perfiles, uno de ellos se usa durante un tiempo específico (por defecto, el "
"primer perfil)."

#: ..\python_docs\spladdoninternals.py:642
msgid ""
"There are two ways of creating a profile: brand new or as a copy. Both uses "
"the same dialog (splconfui.NewProfileDialog), with the difference being the "
"base profile in use. For a brand new profile, settings from the normal "
"profile will be used (minus profile-specific settings, which are set to "
"default values), and for a copy, the new profile will contain all settings "
"from the base profile. In both cases, a memory resident profile will be "
"created and initialized just like other profiles (splconfig.unlockConfig/"
"splconfig.SPLConfig.createProfile, taking the name of the new profile as a "
"parameter); this was done to reduce unnecessary disk writes. Also, new/copy "
"profile dialog (and other dialogs invoked from the main configuration "
"dialog) will disable the main settings dialog."
msgstr ""
"Hay dos formas de crear un perfil: partiendo desde cero o como una copia. "
"Ambas formas usan el mismo diálogo (splconfui.NewProfileDialog), siendo la "
"única diferencia el perfil de partida que se usa. Para un nuevo perfil desde "
"cero, se usarán los ajustes del perfil normal (excepto los ajustes "
"específicos del perfil, para los que se establecen valores por defecto), y "
"para la copia, el nuevo perfil contendrá todos los ajustes del perfil de "
"partida. En ambos casos, se creará un perfil residente en memoria y se "
"iniciará como cualquier otro perfil (splconfig.unlockConfig/splconfig."
"SPLConfig.createProfile, que reciben el nombre de perfil como parámetro); "
"esto se hizo para reducir escrituras innecesarias en disco. Además, el "
"diálogo de nuevo perfil o copiar perfil (y otros diálogos invocados desde el "
"diálogo principal de configuración) deshabilitarán el diálogo principal de "
"ajustes."

#: ..\python_docs\spladdoninternals.py:643
msgid ""
"In case the selected profile is deleted, the profile will be removed from "
"the profiles list, the configuration file associated with the profile will "
"be deleted (if it exists) and a previously active profile will take over "
"unless if the active profile itself is gone, in which case normal profile "
"will be set as the active profile. In case of a rename operation, it'll look "
"for a profile with the old name and change some properties to reflect name "
"change. There is an important step the app module will performed if an "
"instant switch profile is renamed or deleted (if renamed, the instant "
"profile variable will hold the new name, and if deleted, instant profile "
"value will be None). A similar procedure is invoked when dealing with time-"
"based profiles."
msgstr ""
"En caso de que el perfil seleccionado sea eliminado, este se quitará de la "
"lista de perfiles, se eliminará el archivo de configuración asociado al "
"perfil (si existe) y el perfil activo anteriormente tomará el control a "
"menos que sea el perfil activo el que se vaya, en cuyo caso el perfil normal "
"se establecerá como perfil activo. En caso de operaciones de renombrado, se "
"buscará un perfil con el nombre antiguo y se cambiarán algunas propiedades "
"para reflejar el cambio de nombre. Hay un paso muy importante que el módulo "
"de aplicación llevará a cabo si se renombra o se elimina un perfil de cambio "
"instantáneo (si se renombra, la variable del perfil instantáneo guardará el "
"nuevo nombre, y si se elimina, el valor del perfil instantáneo será None). "
"Se invoca un procedimiento similar al tratar con perfiles basados en tiempo."

#: ..\python_docs\spladdoninternals.py:644
msgid "#### Introducing Config Hub"
msgstr "#### Presentación del centro de configuración"

#: ..\python_docs\spladdoninternals.py:645
msgid ""
"In add-on 6.x and 7.x, a combination of SPLConfig map and the config pool "
"was used to allow users to switch between profiles. Because these were using "
"facilities provided by other modules, this meant custom variables such as "
"active profile flag had to live in splconfig module."
msgstr ""
"En los complementos 6.x y 7.x, se usaba una combinación del mapa SPLConfig y "
"la pool de configuración para permitir a los usuarios cambiar entre "
"perfiles. Debido a que se apoyaban en funciones proporcionadas por otros "
"módulos, algunas variables personalizadas como el indicador del perfil "
"activo debían residir en el módulo splconfig."

#: ..\python_docs\spladdoninternals.py:646
msgid ""
"To solve this problem and to allow centralized profile management, a concept "
"of Configuration Hub (ConfigHub) was introduced in add-on 8.0. Inspired by "
"NVDA's own configuration management facility and powered by Chain Map (a "
"dictionary that holds multiple lookup maps), this class not only stores list "
"of currently loaded profiles and the dictionary representing current "
"settings, it also houses various records such as name of the active profile, "
"a history of previously activated profiles and so on, as well as support "
"routines for profile management."
msgstr ""
"Para resolver este problema y permitir una gestión centralizada de perfiles, "
"se introdujo el concepto de centro de configuración (ConfigHub) en el "
"complemento 8.0. Inspirado por el propio sistema de gestión de configuración "
"de NVDA y potenciado por un mapa en cadena (un diccionario que contiene "
"varios mapas de búsqueda), esta clase no sólo almacena la lista de perfiles "
"actualmente cargados y el diccionario que representa los ajustes actuales, "
"también aloja diversos registros como el nombre del perfil activo, un "
"historial de perfiles activados anteriormente y demás, así como "
"procedimientos de soporte para la gestión de perfiles."

#: ..\python_docs\spladdoninternals.py:647
msgid "The various changes due to introduction of Config Hub are:"
msgstr ""
"Los diversos cambios producidos al introducir el centro de configuración son:"

#: ..\python_docs\spladdoninternals.py:648
msgid ""
"* Switching profiles: no longer need to copy settings back and forth between "
"live config dictionary and the designated profile in the config pool. "
"Profile switching is simple as swapping new and old profile maps."
msgstr ""
"* Cambios de perfil: ya no existe la necesidad de copiar los ajustes de un "
"sitio a otro entre el diccionario de configuración activa y el perfil en "
"cuestión en la pool de configuración. El cambio de perfiles es tan simple "
"como intercambiar los mapas del antiguo y el nuevo perfil."

#: ..\python_docs\spladdoninternals.py:649
msgid "* A history of activated profiles is now kept inside this dictionary."
msgstr ""
"* Se guarda en este diccionario un historial de los perfiles activados."

#: ..\python_docs\spladdoninternals.py:650
msgid ""
"* It is possible to pass in additional options when creating a new profile, "
"such as whether it should be cached, validated now and so on."
msgstr ""
"* Es posible pasar opciones adicionales al crear un nuevo perfil, tales como "
"si debería meterse en caché, validarse en el momento y demás."

#: ..\python_docs\spladdoninternals.py:651
msgid "#### How does profile switching work"
msgstr "#### Cómo funciona el cambio de perfiles"

#: ..\python_docs\spladdoninternals.py:652
msgid ""
"There are two times where a \"live\" profile switching will occur: "
"activation or deactivation of instant switch profile, and when it is time to "
"switch to a time-based profile."
msgstr ""
"Hay dos ocasiones en las que puede dispararse un cambio de perfil "
"automático: al activar o desactivar un perfil de cambio instantáneo, o "
"cuando es hora de cambiar a un perfil basado en tiempo."

#: ..\python_docs\spladdoninternals.py:653
msgid ""
"An instant switch profile is a profile to be switched to if told by the "
"user. This is used before you connect to a streaming server to load settings "
"appropriate for a show (as of time of this writing, only one can be selected "
"as an instant switch profile; to define this profile, select a profile to be "
"used as a show, then go to profile switching button and select it)."
msgstr ""
"Un perfil de cambio instantáneo es un perfil al que se cambia si así lo "
"indica el usuario. Se suelen usar antes de conectar a un servidor de emisión "
"para cargar los ajustes apropiados para un programa (en el momento en que se "
"escribe esto, sólo puede elegirse un único perfil como perfil de cambio "
"instantáneo; para definirlo, selecciona el perfil de tu programa, ve al "
"botón de cambio de perfil y selecciónalo)."

#: ..\python_docs\spladdoninternals.py:654
msgid ""
"In contrast, a time-based profile is a special type of instant switch "
"profile that will be activated at a specific date and time. A separate map "
"(a pickle map) is employed to store settings related to these profiles, and "
"the user-facing options can be found in triggers dialog found in add-on "
"settings (see the next section for an overview of this dialog and the "
"configuration format for this map)."
msgstr ""
"En contraste, un perfil basado en tiempo es un tipo especial de perfil de "
"cambio instantáneo que se activará en la fecha y hora especificadas. Se "
"emplea un mapa separado (un mapa pickle) para almacenar los ajustes "
"relativos a estos perfiles, sus opciones de interfaz de usuario pueden "
"encontrarse en el diálogo de disparadores situado en los ajustes del "
"complemento (mira la siguiente sección para ver una descripción de este "
"diálogo y el formato de configuración de este mapa)."

#: ..\python_docs\spladdoninternals.py:655
msgid ""
"To activate an instant switch profile, press SPL Assistant, F12. For time-"
"based profile, it'll activate itself when it is time to do so (with help "
"from a countdown timer located in splmisc module). In ither case, the "
"switching procedure is as follows:"
msgstr ""
"Para activar un perfil de cambio instantáneo, pulsa asistente de SPL, f12. "
"Los perfiles basados en tiempo se activarán por sí solos cuando sea hora de "
"hacerlo (con la ayuda de un temporizador de cuenta atrás situado en el "
"módulo splmisc). En ambos casos, el procedimiento para cambiar el perfil es "
"el siguiente:"

#: ..\python_docs\spladdoninternals.py:656
msgid "1. Performs some checks, including:"
msgstr "1. Se hacen varias comprobaciones, entre ellas:"

#: ..\python_docs\spladdoninternals.py:657
msgid "\t* Checks if a switch profile (instant or time-based) is defined."
msgstr ""
"\t* Se comprueba si se ha definido un perfil de cambio (instantáneo o basado "
"en tiempo)."

#: ..\python_docs\spladdoninternals.py:658
msgid ""
"\t* For instant switch profiles, if a profile is defined, it'll make sure "
"you are not using the instant switch profile yet."
msgstr ""
"\t* Para los perfiles de cambio instantáneo, si hay alguno definido, se "
"comprueba que no lo estás usando todavía."

#: ..\python_docs\spladdoninternals.py:659
msgid "2. For add-on 7.x and earlier, saves the index of the active profile."
msgstr ""
"2. En los complementos 7.x y anteriores, se guarda el índice del perfil "
"activo."

#: ..\python_docs\spladdoninternals.py:660
msgid ""
"3. Locates the name of the switch profile and the profile associated with it "
"and switches to the switch profile (for add-on 7.x, reassigns SPLConfig to "
"use the switch profile; for 8.0 and later, swaps normal profile with the "
"instant profile map). At this point, NVDA may announce metadata streaming "
"status if told to do so when switching profiles, and with 17.12, made "
"simpler through an action extension point notifier that tells appropriate "
"functions to respond to profile switch action."
msgstr ""
"3. Se ubica el nombre del perfil de cambio y el perfil asociado a él, y se "
"cambia al perfil seleccionado (en el complemento 7.x, se reasigna SPLConfig "
"para que use el perfil de cambio; en el 8.0 y posteriores, se intercambian "
"los mapas del perfil normal y el perfil instantáneo). En ese momento, NVDA "
"puede verbalizar el estado de los metadatos del flujo si está configurado "
"para hacerlo al cambiar de perfil. En la versión 17.12, esto se ha "
"simplificado a través de un notificador de punto de extensión de acción que "
"indica a las funciones apropiadas que reaccionen ante la acción de cambio de "
"perfil."

#: ..\python_docs\spladdoninternals.py:661
msgid ""
"4. If no duration is specified for a time-based profile, NVDA will set next "
"switch time and date by calling splconfig.setNextTrigger, otherwise this is "
"delayed until the show is complete."
msgstr ""
"4. Si un perfil basado en tiempo no tiene una duración especificada, NVDA "
"establecerá la siguiente fecha y hora de cambio llamando a splconfig."
"setNextTrigger, en cualquier otro caso se espera a que el programa termine."

#: ..\python_docs\spladdoninternals.py:662
msgid ""
"5. If told to return to the previously active profile, it'll tell SPLConfig "
"to use the previously active profile (the index for the previously active "
"profile is located and is used to pull the profile with the given index from "
"the config pool)."
msgstr ""
"5. Si se indica que hay que volver al perfil previamente activo, SPLConfig "
"recibirá la orden de usar el perfil anterior (el índice para el perfil "
"activo anteriormente ya se había guardado y se usa para recuperar el perfil "
"de la pool de perfiles)."

#: ..\python_docs\spladdoninternals.py:663
msgid ""
"6. When deactivating a time-based profile, NVDA will now find out when the "
"next switch date and time will be."
msgstr ""
"6. Al desactivar un perfil basado en tiempo, NVDA averiguará cuándo serán "
"las próximas fecha y hora de activación."

#: ..\python_docs\spladdoninternals.py:664
msgid "#### Time-based switching fields and triggers dialog"
msgstr "#### El diálogo de disparadores y campos del cambio basado en tiempo"

#: ..\python_docs\spladdoninternals.py:665
msgid ""
"For each time-based profile, a list with seven fields is employed to "
"describe trigger (switch) date and time. These are:"
msgstr ""
"Para cada perfil basado en tiempo, se emplea una lista con siete campos para "
"describir la fecha y hora del disparador (cambio). Son los siguientes:"

#: ..\python_docs\spladdoninternals.py:666
msgid ""
"* Trigger date (integer between 0 and 127): A 7-bit integer, denoting days "
"on which a given profile should be activated. This field is used in profile "
"triggers dialog to set or clear activation day checkboxes. A value of 0 "
"means the profile should not be activated, and if so, it is removed from the "
"triggers map."
msgstr ""
"* Fecha del disparador (entero entre 0 y 127): un entero de 7 bits, "
"indicando en cuántos días debería activarse un perfil. Este campo se usa en "
"el diálogo de disparadores de perfil para marcar o desmarcar las casillas de "
"verificación de días de activación. El valor 0 significa que el perfil no "
"debería activarse, y si es así, se elimina del mapa de disparadores."

#: ..\python_docs\spladdoninternals.py:667
msgid ""
"* Switch date and time (five integers): The first five fields used for "
"constructing datetime.datetime object (year, month, day, hour, minute) are "
"stored. This is used to let NVDA know when to switch profiles."
msgstr ""
"* Fecha y hora del cambio (cinco enteros): los cinco primeros campos usados "
"para construir datetime. El objeto datetime (año, mes, día, hora, minuto) se "
"almacena. Se usa para que NVDA sepa cuándo cambiar de perfil."

#: ..\python_docs\spladdoninternals.py:668
msgid ""
"* Duration (integer between 0 and 1439): An integer specifying the duration "
"of this profile (show) in minutes. This is mainly used by a timer that "
"becomes active when the profile in question becomes active, and the only job "
"of this timer is to switch back to another profile when the show is complete."
msgstr ""
"* Duración (entero entre 0 y 1439): un entero que especifica la duración de "
"este perfil (programa) en minutos. Lo usa principalmente un temporizador que "
"se activa al activarse el perfil en cuestión, y cuya única función es volver "
"a otro perfil cuando el programa se acabe."

#: ..\python_docs\spladdoninternals.py:669
msgid ""
"The triggers dialog, used to configure these fields for the selected "
"profile, consists of two groups of controls:"
msgstr ""
"El diálogo de disparadores, usado para configurar estos campos en el perfil "
"seleccionado, consta de dos grupos de controles:"

#: ..\python_docs\spladdoninternals.py:670
msgid ""
"* Trigger days: seven checkboxes, one for each day of the week. Checking or "
"clearing these boxes sets corresponding bits in the trigger date field."
msgstr ""
"* Días del disparador: siete casillas de verificación, una para cada día de "
"la semana. Al marcarlas o desmarcarlas se cambian los bits correspondientes "
"en el campo de fecha del disparador."

#: ..\python_docs\spladdoninternals.py:671
msgid ""
"* Switch time: three number entry fields denoting when to switch to this "
"profile (hour and minute) and the duration of this show (minutes)."
msgstr ""
"* Hora del cambio: tres campos de entrada numérica que indican cuándo se "
"debe cambiar al perfil (hora y minuto) y la duración del programa (en "
"minutos)."

#: ..\python_docs\spladdoninternals.py:672
msgid ""
"Once the data is gathered, NvDA will first check if trigger date checkboxes "
"are checked (if no checkboxes are checked, the profile is removed). Next, "
"NVDA will see if another profile has taken the given time slot, and if not, "
"will proceed to store the next trigger date and time (will not be saved "
"until OK button is clicked from the main add-on settings dialog)."
msgstr ""
"Una vez que se recopilan los datos, NVDA primero comprobará si están "
"marcadas las casillas de verificación de fecha del disparador (si no hay "
"ninguna marcada, se elimina el perfil). A continuación, NVDA comprobará si "
"otro perfil tiene asignada la misma franja de tiempo, y si no es así, "
"procederá a alamcenar la fecha y hora del disparador (no se guardarán hasta "
"que se haga clic en el botón aceptar en el diálogo principal de ajustes del "
"complemento)."

#: ..\python_docs\spladdoninternals.py:673
msgid ""
"This article concludes a detailed tour of Studio app module internals. The "
"rest of this series will focus on SPL Studio Utilities global plugin, "
"encoder support and a few thoughts on how the add-on is developed, starting "
"with a tour of SPL Controller layer commands."
msgstr ""
"Así concluye un recorrido detallado por el interior del módulo de aplicación "
"de Studio. El resto de los capítulos se enfocarán en la extensión global de "
"utilidades de SPL, soporte del codificador y unas cuantas consideraciones "
"sobre cómo se desarrolla el complemento, comenzando con un recorrido por las "
"órdenes del controlador de SPL."

#: ..\python_docs\spladdoninternals.py:674
msgid ""
"## Introduction to SPL Utilities: SPLController and focusing to Studio window"
msgstr ""
"## Introducción a las utilidades de SPL: SPLController y cómo llevar el foco "
"a la ventana de Studio"

#: ..\python_docs\spladdoninternals.py:675
msgid ""
"Now that we've covered the \"kernel\" (innermost parts) of the Studio add-"
"on, it is time to talk about the icing: SPL Utilities global plugins and its "
"contents. The next few articles will talk about what the global plugin does, "
"introduce you to inner workings of SPL Controller layer and tour how encoder "
"support is implemented."
msgstr ""
"Ahora que hemos cubierto el \"kernel\" (la parte más íntima) del complemento "
"de Studio, es hora de hablar sobre la extensión global de utilidades de SPL "
"Studio y sus contenidos. Los siguientes artículos explicarán qué hace la "
"extensión global, te introducirán en el funcionamiento interno de la capa "
"del controlador de SPL y harán un recorrido explicando cómo se ha "
"implementado el soporte del codificador."

#: ..\python_docs\spladdoninternals.py:676
msgid "### Studio app module versus SPL Utilities global plugin"
msgstr ""
"### Comparación del módulo de aplicación de Studio y la extensión global de "
"utilidades de SPL"

#: ..\python_docs\spladdoninternals.py:677
msgid ""
"As described in the add-on design section, SPL Studio add-on comes with two "
"app modules and a global plugin. This was needed not only to differentiate "
"between module types and expertese, but also allow Studio functions to be "
"invoked from other programs. With the introduction of encoder support in add-"
"on 3.0 (fall 2014), the global plugin portion of the add-on (SPL Utilities) "
"took on an important role: working as an encoders manager to report "
"connection status and to perform other routines."
msgstr ""
"Como se ha descrito en el artículo de diseño del complemento, el complemento "
"de SPL Studio viene con dos módulos de aplicación y una extensión global. "
"Esto era necesario no sólo para diferenciar entre tipos de módulos y "
"experiencias, sino también para permitir que las funciones de Studio puedan "
"invocarse desde otros programas. Con la llegada del soporte para el "
"codificador en el complemento 3.0 (finales de 2014), la parte de extensión "
"global del complemento (utilidades de SPL) tomó un rol importante: funcionar "
"como un gestor de codificadores para informar del estado de la conexión y "
"llevar a cabo otras acciones."

#: ..\python_docs\spladdoninternals.py:678
msgid "### SPL Utilities package contents"
msgstr "### Contenidos del paquete de utilidades de SPL"

#: ..\python_docs\spladdoninternals.py:679
msgid "The SPL Utilities global plugin consists of the following modules:"
msgstr ""
"La extensión global de utilidades de SPL consta de los siguientes módulos:"

#: ..\python_docs\spladdoninternals.py:680
msgid ""
"* Main plugin code (__init__.py), containing essential global routines such "
"as SPL Controller (described below) and a procedure to focus to Studio "
"window upon request. This module defines constants used by Studio to receive "
"messages, a function to focus to Studio window and the global plugin class "
"containing definitions for SPL Controller layer commands."
msgstr ""
"* Código principal de la extensión (__init__.py), que contiene "
"procedimientos globales esenciales como el controlador de SPL (descrito "
"debajo) y un procedimiento para enfocar la ventana de Studio a petición. "
"Este módulo define constantes usadas por Studio para recibir mensajes, una "
"función para llevar el foco a la ventana de Studio y la clase de extensión "
"global que contiene definiciones para las órdenes de la capa del controlador "
"de SPL."

#: ..\python_docs\spladdoninternals.py:681
msgid ""
"* Encoder support (encoders.py), outlining NVDA's support for various "
"encoders (see the next article; the main global plugin module plays an "
"important part in helping the encoder module as you'll see in the next "
"article)."
msgstr ""
"* Soporte del codificador (encoders.py), que contiene el soporte de NVDA "
"para varios codificadores (mira el próximo artículo; el módulo principal de "
"la extensión global es una pieza importante a la hora de ayudar al módulo "
"del codificador, como podrás comprobar)."

#: ..\python_docs\spladdoninternals.py:682
msgid "### SPL Controller layer"
msgstr "### La capa del controlador de SPL"

#: ..\python_docs\spladdoninternals.py:683
msgid ""
"The SPL Controller layer (entry command unassigned, same reason as the "
"Assistant layer entry command) is used to invoke Studio functions from "
"anywhere. The entry routine is similar to the app module counterpart (SPL "
"Assistant) except for the following:"
msgstr ""
"La capa del controlador de SPL (orden de entrada sin asignar, mismo motivo "
"que el de la orden de entrada al asistente de SPL) se usa para invocar "
"funciones de Studio desde cualquier sitio. El procedimiento de entrada es "
"similar a su homólogo del módulo de aplicación (el asistente de SPL) salvo "
"por lo siguiente:"

#: ..\python_docs\spladdoninternals.py:684
msgid ""
"* NVDA will make sure Studio is running (if so, it'll cache the window "
"handle value just as in the Studio app module), otherwise it cannot enter "
"SPL Controller layer."
msgstr ""
"* NVDA se asegurará de que Studio esté en ejecución (si es así, almacenará "
"en caché el valor del manejador de ventana al igual que en el módulo de "
"aplicación de Studio), en cualquier otro caso no se puede entrar en la capa "
"del controlador de SPL."

#: ..\python_docs\spladdoninternals.py:685
msgid ""
"* All commands (except two) use Studio API (Studio API and use of user32."
"dll's SendMessage was described in a previous article)."
msgstr ""
"* Todas las órdenes (excepto dos) usan la api de Studio (en un artículo "
"anterior se describió el funcionamiento de la api de Studio y la función "
"SendMessage de user32.dll)."

#: ..\python_docs\spladdoninternals.py:686
msgid ""
"For mechanics of layer commands, see a previous article on add-on design "
"where layer commands were discussed."
msgstr ""
"Para ver los mecanismos de las órdenes de capa, consulta un artículo "
"anterior que hablaba del diseño del complemento, donde se expusieron estas "
"órdenes."

#: ..\python_docs\spladdoninternals.py:687
msgid "The following commands utilize Studio API:"
msgstr "Las siguientes órdenes utilizan la api de Studio:"

#: ..\python_docs\spladdoninternals.py:688
msgid "* A/Shift+A: Automation on/off."
msgstr "* A/Shift+A: activar o desactivar automatización."

#: ..\python_docs\spladdoninternals.py:689
msgid "* L/Shift+L: Line in on/off."
msgstr "* L/Shift+L: activar o desactivar entrada de línea."

#: ..\python_docs\spladdoninternals.py:690
msgid "* M/Shift+M/N: Microphone on/off/instant on/off toggle."
msgstr ""
"* M/Shift+M/N: activar o desactivar micrófono, o conmutador instantáneo para "
"encenderlo y apagarlo."

#: ..\python_docs\spladdoninternals.py:691
msgid "* P: Play."
msgstr "* P: reproducir."

#: ..\python_docs\spladdoninternals.py:692
msgid ""
"* Q: Obtain various status information. Due to API changes, this command "
"works better in studio 5.20 and later.)"
msgstr ""
"* Q: obtener diversa información de estado (debido a cambios en la api, esta "
"orden funciona mejor en Studio 5.20 y posteriores.)"

#: ..\python_docs\spladdoninternals.py:693
msgid "* R: Remaining time for the currently playing track (if any)."
msgstr ""
"* R: tiempo restante de la pista actualmente en reproducción (si la hay)."

#: ..\python_docs\spladdoninternals.py:694
msgid "* Shift+R: Library scan progress and umber of items scanned."
msgstr ""
"* Shift+r: progreso del escaneo de biblioteca y cantidad de elementos "
"escaneados."

#: ..\python_docs\spladdoninternals.py:695
msgid "* S/T: Stop with fade/instant stop."
msgstr "* S/T: parar progresivamente o parar de forma instantánea."

#: ..\python_docs\spladdoninternals.py:696
msgid "* U: Play/pause."
msgstr "* U: reproducir / pausar."

#: ..\python_docs\spladdoninternals.py:697
msgid ""
"For readers familiar with Studio keyboard commands, you'll find yourself at "
"home (they are indeed Studio commands except pressing Shift will turn a "
"feature off and Shift+R will remind you of Control+Shift+R for library scan "
"from Insert Tracks dialog). The letter \"Q\" stands for \"query Studio status"
"\"."
msgstr ""
"Los lectores familiarizados con las órdenes te teclado de Studio se sentirán "
"como en casa (en cierto modo estas son órdenes de Studio, salvo porque shift "
"se usa para desactivar algunas características, y shift+r te recordará al "
"ctrl+shift+r que se usa para escanear desde el diálogo de inserción de "
"pistas). La letra Q se queda para \"Consultar el estado de Studio"
"\" (consultar, en inglés, es query)."

#: ..\python_docs\spladdoninternals.py:698
msgid "Here are the two exceptions"
msgstr "Estas son las dos excepciones"

#: ..\python_docs\spladdoninternals.py:699
msgid ""
"* E: If you tell NVDA to monitor one or more encoders in the background, "
"this command will announce number of encoders being monitored (see the next "
"aritlce on the format of this message)."
msgstr ""
"* E: si pides a NVDA que monitorice uno o más codificadores en segundo "
"plano, esta orden verbalizará la cantidad de codificadores monitorizados "
"(mira el siguiente artículo para conocer el formato de este mensaje)."

#: ..\python_docs\spladdoninternals.py:700
msgid ""
"* F1: Opens a dialog displaying Controller layer commands (does this sound "
"familiar?)."
msgstr ""
"* F1: abre un diálogo que muestra las órdenes de la capa del controlador "
"(¿Te suena familiar?)."

#: ..\python_docs\spladdoninternals.py:701
msgid "### Focusing to Studio window from anywhere"
msgstr "### Cómo llevar el foco a la ventana de Studio desde cualquier parte"

#: ..\python_docs\spladdoninternals.py:702
msgid ""
"As you are broadcasting a show with Studio, you may find yourself in a "
"situation where you need to switch to Studio quickly to take care of "
"automation, insert new tracks and so on. An ideal situation is to switch to "
"Studio when you press Alt+TAB (this isn't the case if you have more than two "
"programs opened). For this reason, screen reader scripts for Studio includes "
"a command to switch to Studio upon request (unassigned in NVDA)."
msgstr ""
"Según estás emitiendo un programa en Studio, puedes encontrarte en una "
"situación donde necesitas pasar rápidamente a Studio para cambiar la "
"automatización, insertar nuevas pistas y demás. Una situación ideal es pasar "
"a Studio al pulsar alt+tab (no es el caso si tienes más de dos programas "
"abiertos). Por esta razón, los scripts de lectores de pantalla para Studio "
"incluyen una orden para pasar a Studio a petición (sin asignar en NVDA)."

#: ..\python_docs\spladdoninternals.py:703
msgid ""
"Until 2016, this was accomplished with a function in the SPL Utilities "
"module (SPLStudioUtils.fetchSPLForegroundWindow). This was employed not only "
"by the main global plugin module (called from a script to focus to Studio "
"window), but also used in encoders for various functions. The routine was as "
"follows:"
msgstr ""
"Hasta 2016, esto se llevaba a cabo con una función en el módulo de "
"utilidades de SPL (SPLStudioUtils.fetchSPLForegroundWindow). No sólo la "
"empleaba el módulo principal de la extensión global (llamada desde un script "
"para llevar el foco a la ventana de Studio), sino que se usaba en los "
"codificadores para diversos propósitos. El procedimiento era el siguiente:"

#: ..\python_docs\spladdoninternals.py:704
msgid ""
"1. The focus to Studio script will check if Studio is running, and if so, "
"it'll call the fetch window function, which in turn locates the desktop "
"(shell) window to serve as the starting point for locating Studio window."
msgstr ""
"1. El script que lleva el foco a Studio comprobará si Studio está en "
"ejecución, y si es así, llamará a la función de recuperación de ventana, que "
"primero localiza la ventana del escritorio (shell) para usarla como punto de "
"partida para encontrar la ventana de Studio."

#: ..\python_docs\spladdoninternals.py:705
msgid ""
"2. NVDA will scan top-level windows (children of desktop object) until a "
"Studio window (where the window's app module is the Studio app module) is "
"found, and if found, NVDA will increment a Studio window candidate counter."
msgstr ""
"2. NVDA escaneará las ventanas de nivel superior (hijas del objeto del "
"escritorio) hasta que se encuentre la ventana de Studio (donde el módulo de "
"aplicación de la ventana sea el de Studio), y si la encuentra, incrementará "
"un contador de ventanas de Studio candidatas."

#: ..\python_docs\spladdoninternals.py:706
msgid ""
"3. Once top-level window scanning is complete, NVDA will take action based "
"on what the Studio window candidate counter says before passing the "
"foreground object back to the main script. It can do one of the following:"
msgstr ""
"3. Una vez se haya completado el escaneo de ventanas de alto nivel, NVDA "
"tomará acciones en base a lo que diga el contador de ventanas candidatas de "
"Studio antes de devolver el objeto en primer plano al script principal. "
"Puede hacer una de las siguientes cosas:"

#: ..\python_docs\spladdoninternals.py:707
msgid ""
"A. If counter is 0 (fg is None), NVDA will know that you have minimized "
"Studio, so it'll tell you that Studio is minimized."
msgstr ""
"A. Si el contador es 0 (fg es None), NVDA sabrá que has minimizado Studio, "
"por lo que te lo dirá."

#: ..\python_docs\spladdoninternals.py:708
msgid ""
"B. If counter is 1, NVDA will locate the Studio window by looking for the "
"main Studio window (user32.dll is involved)."
msgstr ""
"B. Si el contador es 1, NVDA localizará la ventana de Studio buscándola "
"(user32.dll está implicada)."

#: ..\python_docs\spladdoninternals.py:709
msgid ""
"C. For all other values, NVDA will assume the last window found is the "
"Studio window (held in fg variable) and return it."
msgstr ""
"C. Para el resto de valores, NVDA asumirá que la última ventana que ha "
"encontrado es la ventana de Studio (contenida en la variable fg) y la "
"devolverá."

#: ..\python_docs\spladdoninternals.py:710
msgid ""
"4. Back at the focus to Studio script, NvDA will either announce if Studio "
"is minimized or switch to the foreground window returned by the fetch window "
"function (fg.SetFocus)."
msgstr ""
"4. De vuelta al script que lleva el foco a Studio, NVDA indicará que Studio "
"está minimizado o pasará a la ventana en primer plano devuelta por la "
"función de recuperación de ventana (fg.SetFocus)."

#: ..\python_docs\spladdoninternals.py:711
msgid ""
"In 2017, this has been simplified to use SetForegroundWindow Windows API "
"function with the handle to the Studio window being the only required "
"parameter. Not only this simplified this routine significantly, it also "
"improved performance of this command. One side effect is that it is no "
"longer possible to detect Studio being minimized, but one can get a clue of "
"this if NVDA says \"unavailable\" when trying to switch to Studio. One can "
"then go to system tray and restore Studio window."
msgstr ""
"En 2017, eso se ha simplificado para usar la función SetForegroundWindow de "
"la api de Windows, siendo el manejador de la ventana de Studio el único "
"parámetro necesario que se pasaba. Esto no sólo simplificó la función "
"significativamente, sino que también aumentó el rendimiento de esta orden. "
"Un efecto colateral es que ya no es posible detectar Studio cuando está "
"minimizado, pero nos podemos hacer una idea de ello cuando NVDA dice \"No "
"disponible\" al intentar cambiar a Studio. Si esto ocurre, se puede ir a la "
"bandeja del sistema y restaurar la ventana de Studio."

#: ..\python_docs\spladdoninternals.py:712
msgid "### Conclusion"
msgstr "### Conclusión"

#: ..\python_docs\spladdoninternals.py:713
msgid ""
"The routines discussed above (SPL Controller and the command to switch to "
"Studio window) is one of the two pillars of the SPL Studio Utilities global "
"plugin (the other is encoder support). With these routines, it became "
"possible to perform playback operations without focusing to studio, and you "
"can switch to Studio window from anywhere, anytime. This \"other side\" of "
"the lgobal plugin is discussed below, and after that, we'll conclude with an "
"interview with the maintainer of the add-on to learn about how he (I) "
"develop new add-on features."
msgstr ""
"Los procedimientos explicados arriba (el controlador de SPL y la orden para "
"pasar a la ventana de Studio) constituyen uno de los dos pilares de la "
"extensión global de utilidades de SPL (el otro es el soporte del "
"codificador). Con estos procedimientos, se hizo posible realizar operaciones "
"de reproducción sin llevar el foco a Studio y pasar a Studio desde cualquier "
"parte, en cualquier momento. Visitaremos el \"otro lado\" de la historia de "
"esta extensión global en el siguiente artículo del complemento de Studio "
"para NVDA visto por dentro, y después de eso, concluiremos con una "
"entrevista con el responsable del mantenimiento del complemento para "
"aprender cómo él (yo) desarrolla nuevas características del complemento."

#: ..\python_docs\spladdoninternals.py:714
msgid "## Encoder support"
msgstr "## Soporte del codificador"

#: ..\python_docs\spladdoninternals.py:715
msgid ""
"We have now arrived at the penultimate chapter in this Add-on Internals "
"article for StationPlaylist add-on: encoder support, the second pillar for "
"the SPL Utilities global plugin. We'll talk about how encoder support is "
"implemented, how NVDA can detect stream labels and a behind the scenes "
"overview of what happens when you connect to a streaming server."
msgstr ""
"Ahora hemos llegado al penúltimo capítulo en este artículo de complementos "
"vistos por dentro para el complemento de StationPlaylist: soporte del "
"codificador, el segundo pilar de la extensión global de utilidades para SPL. "
"Hablaremos sobre cómo ha sido implementado el soporte del codificador, cómo "
"puede NVDA detectar las etiquetas de flujo y una descripción tras el "
"escenario de lo que pasa cuando te conectas a un servidor de emisión."

#: ..\python_docs\spladdoninternals.py:716
msgid "### Encoder support: From suggestion to implementation"
msgstr "### Soporte del codificador: de la sugerencia a la implementación"

#: ..\python_docs\spladdoninternals.py:717
msgid ""
"Originally, I wasn't planning on including encoder support into the SPL add-"
"on. However, after talking to some Studio users who were using SAM encoders "
"and seeing how other screen readers supported it, I decided to investigate "
"SAM encoder support in summer 2014."
msgstr ""
"Originalmente, no tenía planeado incluir soporte para el codificador en el "
"complemento de SPL. Sin embargo, tras hablar con varios usuarios de Studio "
"que utilizaban los codificadores SAM y viendo cómo les daban soporte otros "
"lectores de pantalla, decidí investigar el soporte para el codificador SAM "
"en verano del 2014."

#: ..\python_docs\spladdoninternals.py:718
msgid ""
"The first issue I had to solve was making NVDA recognize the encoder entries "
"themselves. Once that was solved, the next task was announcing connection "
"error messages, which led to figuring out how SAM encoders react when "
"connected to a streaming server."
msgstr ""
"El primer problema que tenía que resolver era hacer que NVDA reconociera las "
"entradas de codificador en sí mismas. Una vez estuvo resuelto, la siguiente "
"tarea era verbalizar los mensajes de error de conexión, lo que llevó a "
"averiguar cómo reaccionaban los codificadores SAM al conectarse a un "
"servidor de emisión."

#: ..\python_docs\spladdoninternals.py:719
msgid ""
"Originally, I manipulated text written to the screen to obtain needed status "
"messages (via text infos). This routine caused some to experience screen "
"flickering issues when connecting to a streaming server. This was resolved "
"by using encoder description (obj.description), which opened up a "
"possibility to monitor changes to this text via a background thread (more on "
"this routine below), which also eliminated a need to stay on the encoders "
"window until connected."
msgstr ""
"Originalmente, manipulaba el texto escrito en pantalla para obtener los "
"mensajes de estado necesarios (mediante text infos). Este procedimiento "
"causaba que algunos usuarios experimentaran problemas de parpadeo al "
"conectarse a un servidor de emisión. Esto se resolvió usando la descripción "
"del codificador (obj.description), que abría una posibilidad de monitorizar "
"cambios en el texto mediante un hilo en segundo plano (más sobre este "
"procedimiento debajo), lo que también eliminó la necesidad de permanecer en "
"la ventana de codificadores hasta estar conectado."

#: ..\python_docs\spladdoninternals.py:720
msgid ""
"While I was resolving problems with SAM encoders, I also worked on "
"refactoring encoder support code to support StationPlaylist encoders (add-on "
"4.0). Initially, encoder support code was optimized for SAM encoders, but "
"the current code structure (explained below) was written to extend basic "
"encoder support easily, and as a result, both SAM and SPL encoder entries "
"present similar interfaces and commands, including a common encoder "
"configuration dialog (add-on 7.0)."
msgstr ""
"Mientras estaba resolviendo problemas con los codificadores SAM, trabajé "
"también en refactorizar el código de soporte del codificador para dar "
"compatibilidad con los codificadores de StationPlaylist (complemento 4.0). "
"Inicialmente, el código de soporte para el codificador se optimizó para los "
"codificadores SAM, pero la estructura actual del código (explicada debajo) "
"se escribió para extender fácilmente el soporte básico de codificadores, y "
"como resultado, las entradas del codificador de SAM y SPL presentan "
"interfaces y órdenes similares, incluyendo un diálogo común de configuración "
"del codificador (complemento 7.0)."

#: ..\python_docs\spladdoninternals.py:721
msgid "### Encoder entries: Yet another overlay class family"
msgstr ""
"### Entradas del codificador: otra familia más de clases de superposición"

#: ..\python_docs\spladdoninternals.py:722
msgid ""
"Just like Studio track items (see the section on track items), encoder "
"entries are overlay classes. Each encoder type (SAM or SPL) inherits from a "
"single encoder object (SPLStudioUtils.encoders.EncoderWindow) that provides "
"basic services such as settings commands, announcing stream labels and so "
"on. Then each encoder type adds encoder-specific routines such as different "
"connection detection routines, ways of obtaining stream labels and so on. "
"Speaking of stream labels and settings, the base encoder class is helped by "
"some friends from the encoder module itself, including a configuration map "
"to store stream labels and basic settings, a routine to obtain encoder ID "
"(encoder string and the IAccessible child ID) and so on."
msgstr ""
"Al igual que los elementos de pista de Studio (mira la sección de elementos "
"de pista), las entradas del codificador son clases de superposición. Cada "
"tipo de codificador (SAM o SPL) hereda de un único objeto codificador "
"(SPLStudioUtils.encoders.EncoderWindow) que proporciona servicios básicos "
"como órdenes de ajustes, verbalización de etiquetas de flujo y demás. Cada "
"tipo de codificador agrega procedimientos específicos del codificador como "
"diferentes funciones de detección de conexión, formas de obtener etiquetas "
"de flujo y demás. Hablando de etiquetas de flujo y ajustes, la clase base "
"del codificador recibe ayuda de algunos amigos del módulo del codificador en "
"sí, incluido un mapa de configuración para almacenar etiquetas de flujo y "
"ajustes básicos, una función para obtener el identificador del codificador "
"(cadena del codificador e identificador del hijo de IAccessible) y demás."

#: ..\python_docs\spladdoninternals.py:723
msgid ""
"On top of the base encoder class are two encoder classes, representing SAM "
"encoder entries and SPL encoder entries. SAM encoder entries (SPLStudioUtils."
"encoders.SAMEncoderWindow) is laid out just like Studio's track items, "
"whereas SPL encoder entries (SPLStudioUtils.encoders.SPLEncoderWindow) is a "
"typical SysListView32 control (see an article on column routines for more "
"information). Both classes provide similar routines, with the only "
"difference being how connection messages are handled."
msgstr ""
"Construidas sobre la clase base del codificador hay dos clases de "
"codificadores, representando las entradas del codificador SAM y del "
"codificador SPL. Las entradas del codificador SAM (SPLStudioUtils.encoders."
"SAMEncoderWindow) se presentan como los elementos de pista de Studio, "
"mientras que las entradas del codificador SPL (SPLStudioUtils.encoders."
"SPLEncoderWindow) es un control SysListView32 típico (mira el artículo sobre "
"procedimientos de columna para más información). Ambas clases proporcionan "
"procedimientos similares, siendo su única diferencia cómo se capturan los "
"mensajes de conexión."

#: ..\python_docs\spladdoninternals.py:724
msgid "### Common services: basic settings, stream labels and related methods"
msgstr ""
"### Servicios comunes: ajustes básicos, etiquetas de flujo y métodos "
"relacionados"

#: ..\python_docs\spladdoninternals.py:725
msgid "All encoder classes provide the following common services:"
msgstr ""
"Todas las clases de codificadores proporcionan los siguientes servicios "
"comunes:"

#: ..\python_docs\spladdoninternals.py:726
msgid "* Configuring settings: four settings can be configured:"
msgstr "* Configuración de ajustes: se pueden configurar cuatro ajustes:"

#: ..\python_docs\spladdoninternals.py:727
msgid ""
"\t* Pressing F11 will tell NVDA if NVDA should switch to Studio when the "
"encoder is connected."
msgstr ""
"\t* Al pulsar f11 indicaremos a NVDA si este debería pasar a Studio cuando "
"el codificador esté conectado."

#: ..\python_docs\spladdoninternals.py:728
msgid ""
"\t*Pressing Shift+F11 will ask Studio will play the next track when "
"connected."
msgstr ""
"\t* Al pulsar shift+f11 se pedirá a Studio que reproduzca la siguiente pista "
"al conectarse."

#: ..\python_docs\spladdoninternals.py:729
msgid ""
"\t* Pressing Control+F11 will enable background encoder monitoring (more on "
"this in a second)."
msgstr ""
"\t* Al pulsar ctrl+f11 se activará la monitorización del codificador en "
"segundo plano (más sobre esto en un segundo)."

#: ..\python_docs\spladdoninternals.py:730
msgid ""
"\t* Enabling or disabling connection progress tones (add-on 7.0, "
"configurable from encoder settings dialog described below)."
msgstr ""
"\t* Activar o desactivar la reproducción de tonos que indiquen el progreso "
"de la conexión (complemento 7.0, configurable desde el diálogo de ajustes "
"del codificador que se describe más abajo)."

#: ..\python_docs\spladdoninternals.py:731
msgid ""
"\t* Once these settings are changed, the new values will be stored in "
"appropriate flag in the encoder entry, which in turn are saved in the "
"configuration map."
msgstr ""
"\t* Una vez se cambien estos ajustes, los nuevos valores se almacenarán en "
"el indicador apropiado de la entrada del codificador, que eventualmente se "
"guarda en el mapa de configuración."

#: ..\python_docs\spladdoninternals.py:732
msgid ""
"* Retrieves settings. This is done by various property methods - once "
"called, these methods will look up various settings for the encoder from the "
"configuration map (key is the setting flag, value is the encoder ID)."
msgstr ""
"* Recuperación de ajustes. Esto se hace con diversos métodos de propiedad - "
"una vez llamados, estos métodos recuperarán diversos ajustes para el "
"codificador desde el mapa de configuración (la clave es el indicador del "
"ajuste, y el valor es el identificador del codificador)."

#: ..\python_docs\spladdoninternals.py:733
msgid ""
"* Monitors and responds to connection status changes. The response routine "
"(onConnection method) attempts to set focus to Studio and/or play the first "
"checked track if configured to do so."
msgstr ""
"* Monitorización y reacción ante cambios de estado de la conexión. El "
"procedimiento de respuesta (método onConnection) intenta llevar el foco a "
"Studio y / o reproducir la primera pista marcada si está configurado para "
"hacerlo."

#: ..\python_docs\spladdoninternals.py:734
msgid ""
"* Loads stream labels when an encoder first gains focus (if this was loaded "
"earlier, it could be a waste of space, especially if encoders are never "
"used)."
msgstr ""
"* Carga de etiquetas del flujo cuando un codificador obtiene el foco por "
"primera vez (si se habían cargado antes, podría suponer un gasto de espacio, "
"especialmente si nunca se usan los codificadores)."

#: ..\python_docs\spladdoninternals.py:735
msgid ""
"* Announces stream labels (if defined) via reportFocus method. In contrast "
"with the Studio track item version, an encoder's reportFocus routine:"
msgstr ""
"* Verbalización de etiquetas de flujo (si están definidas) mediante el "
"método reportFocus. En contraste con la versión del elemento de pista de "
"Studio, una función reportFocus de un codificador:"

#: ..\python_docs\spladdoninternals.py:736
msgid ""
"\t1. Locates stream labels for the current encoder (the configuration map "
"stores stream labels as dictionaries (sections), with each dictionary "
"representing the encoder type, key is the encoder position and the value is "
"the label; each encoder, when told to look up stream labels, will consult "
"its own labels dictionary)."
msgstr ""
"\t1. Ubica las etiquetas de flujo del codificador actual (el mapa de "
"configuración almacena las etiquetas de flujo como diccionarios (secciones), "
"donde en cada diccionario se representa el tipo de codificador, la clave es "
"la posición del codificador y el valor es la etiqueta; cada codificador, al "
"pedirle que busque las etiquetas de flujo, consultará su propio diccionario "
"de etiquetas)."

#: ..\python_docs\spladdoninternals.py:737
msgid ""
"\t2. If a label is found, NVDA will announce the label (in braille, "
"surrounded by parentheses)."
msgstr ""
"\t2. Si se encuentra una etiqueta, NVDA la anunciará (en braille la rodeará "
"con paréntesis)."

#: ..\python_docs\spladdoninternals.py:738
msgid ""
"* Define and remove stream labels. This is done via stream labels dialog "
"(F12) that'll make sure you entered a label (if not, the encoder position is "
"removed from the encoder-specific stream labels dictionary)."
msgstr ""
"* Definición y eliminación de etiquetas de flujo. Esto se hace mediante el "
"diálogo de etiquetas de flujo (f12) que se asegurará de que has introducido "
"una etiqueta (si no, la posición del codificador se elimina del diccionario "
"específico de etiquetas de flujo del codificador)."

#: ..\python_docs\spladdoninternals.py:739
msgid ""
"* Updates stream label position when told to do so (via a dialog, activated "
"by pressing Control+F12). This is needed if encoders were removed, as you "
"may hear stream label for an encoder that no longer exists. This is "
"implemented as a variation of find predecessor algorithm."
msgstr ""
"* Actualización de la posición de etiquetas de flujo a petición (mediante un "
"diálogo, que se activa pulsando ctrl+f12). Esto es necesario si se han "
"eliminado codificadores, ya que puedes oír una etiqueta de flujo para un "
"codificador que ya no existe. Esto se implementa como una variación del "
"algoritmo de búsqueda anterior."

#: ..\python_docs\spladdoninternals.py:740
msgid ""
"* Announces encoder columns. The base class can announce encoder position "
"(Control+NVDA+1) and stream label (Control+NVDA+2), while SAM can announce "
"encoder format, status and description and SPL allows one to hear encoder "
"format and transfer rate/connection status."
msgstr ""
"* Verbalización de las columnas del codificador. La clase base puede "
"verbalizar la posición del codificador (ctrl+NVDA+1) y la etiqueta de flujo "
"(ctrl+NVDA+2), mientras que SAM puede verbalizar el formato del codificador, "
"estado y descripción. SPL permite oír el formato del codificador y la "
"velocidad de transferencia / el estado de la conexión."

#: ..\python_docs\spladdoninternals.py:741
msgid ""
"* In add-on 7.0, a central configuration dialog for configuring encoder "
"settings for the selected encoder (include stream labels and the four "
"settings described above) has been added. Press Alt+NVDA+0 to open this "
"dialog."
msgstr ""
"* En el complemento 7.0, se ha añadido un diálogo de configuración central "
"para configurar los ajustes del codificador seleccionado (incluye las "
"etiquetas de flujo y los cuatro ajustes descritos más arriba). Pulsa alt+NVDA"
"+0 para abrir este diálogo."

#: ..\python_docs\spladdoninternals.py:742
msgid "### Encoder ID's"
msgstr "### Identificadores de codificador"

#: ..\python_docs\spladdoninternals.py:743
msgid ""
"An encoder ID is a string which uniquely identifies an encoder. This "
"consists of a string denoting the encoder type (SAM for SAM encoder, for "
"instance), followed by the encoder position (separated by a space). For "
"instance, the first SAM encoder is given the ID \"SAM 1\". The ID's are used "
"to look up stream labels, configure settings and to identify encoders being "
"monitored (SPL Controller, E)."
msgstr ""
"Un identificador de codificador es una cadena que identifica unívocamente un "
"codificador. Consta de una cadena que indica el tipo de codificador (SAM "
"para el codificador SAM, por ejemplo), seguida de la posición del "
"codificador (separada por un espacio). Por ejemplo, el primer codificador "
"SAM tiene el identificador \"SAM 1\". Los identificadores se usan para "
"buscar etiquetas de flujo, configurar ajustes e identificar codificadores "
"monitorizados (controlador de SPL, E)."

#: ..\python_docs\spladdoninternals.py:744
msgid ""
"### More and more threads: connection messages and background encoder "
"monitoring"
msgstr ""
"### Más y más hilos: mensajes de conexión y monitorización del codificador "
"en segundo plano"

#: ..\python_docs\spladdoninternals.py:745
msgid ""
"As we saw in a previous chapter, threads allow developers to let programs "
"perform certain tasks in the background. Even in encoder support, threads "
"are employed for various tasks, including connection message announcement "
"and background encoder monitoring."
msgstr ""
"Como vimos en un capítulo anterior, los hilos permiten a los desarrolladores "
"hacer que los programas realicen ciertas tareas en segundo plano. Incluso en "
"el soporte de codificadores, los hilos se emplean para diversas tareas, "
"incluyendo la verbalización del mensaje de conexión y la monitorización del "
"codificador en segundo plano."

#: ..\python_docs\spladdoninternals.py:746
msgid ""
"Each encoder overlay class (not the base encoder) includes dedicated "
"connection handling routines (reportConnectionStatus). Depending on how you "
"invoke this, it starts up as follows:"
msgstr ""
"Cada clase de superposición para cada codificador (y no el codificador base) "
"incluye procedimientos dedicados para la gestión de conexión "
"(reportConnectionStatus). Dependiendo de cómo los invoques, se pueden "
"iniciar como sigue:"

#: ..\python_docs\spladdoninternals.py:747
msgid ""
"* If background encoder monitoring is off and you press F9 to connect, NVDA "
"will run this routine in a separate thread. For SAM, this is checked right "
"after sending F9 to the application, and for SPL, this is done after "
"clicking \"connect\" button (manipulates focus in the process)."
msgstr ""
"* Si la monitorización del codificador en segundo plano está desactivada y "
"pulsas f9 para conectar, NVDA ejecutará este procedimiento en un hilo "
"separado. En SAM, se hace la comprobación justo después de enviar f9 a la "
"aplicación, y en SPL se hace después de hacer click en el botón Conectar (se "
"manipula el foco en el proceso)."

#: ..\python_docs\spladdoninternals.py:748
msgid ""
"* If background encoder monitoring is on before pressing F9, the routine "
"will run from another thread when this setting is switched on. Then when you "
"press F9, NvDA knows that the background monitoring thread is active, thus "
"skipping the above step."
msgstr ""
"* Si la monitorización del codificador en segundo plano está activada antes "
"de pulsar f9, el procedimiento se ejecutará desde otro hilo cuando este "
"ajuste se active. Cuando pulses f9, NVDA ya sabe que el hilo de "
"monitorización en segundo plano está activo, por lo que se saltará el paso "
"de arriba."

#: ..\python_docs\spladdoninternals.py:749
msgid "The connection handling routine performs the following:"
msgstr "El procedimiento encargado de gestionar la conexión hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:750
msgid ""
"1. Locates status message for the encoder entry. For SAM, it is the "
"description text, and for SPL, it is one of the entry's child objects "
"(columns). This will be done as long as Studio and/or NVDA is live (that is, "
"if the thread is running)."
msgstr ""
"1. Ubica el mensaje de estado para la entrada del codificador. En Sam es el "
"texto de descripción, y en SPL es uno de los objetos hijo de la entrada "
"(columns). Esto se hará mientras Studio y / o NVDA estén en ejecución (o lo "
"que es lo mismo, si el hilo está en ejecución)."

#: ..\python_docs\spladdoninternals.py:751
msgid ""
"2. Announces error messages if any and will try again after waiting a little "
"while (fraction of a second)."
msgstr ""
"2. Verbaliza mensajes de error si los hay y lo intenta otra vez después de "
"esperar un ratito (una fracción de segundo)."

#: ..\python_docs\spladdoninternals.py:752
msgid "3. If connected, NvDA will play a tone, then:"
msgstr "3. Si está conectado, NVDA reproducirá un tono, y entonces:"

#: ..\python_docs\spladdoninternals.py:753
msgid "\t* Do nothing if not told to focus to studio nor play the next track."
msgstr ""
"\t* No hará nada si no se le indica que lleve el foco a Studio o reproduzca "
"la siguiente pista."

#: ..\python_docs\spladdoninternals.py:754
msgid ""
"\t* Focuses to studio and/or plays the next track if no tracks are playing "
"by calling onConnect method."
msgstr ""
"\t* Lleva el foco a Studio y / o reproduce la siguiente pista si no hay "
"pistas reproduciéndose llamando al método onConnect."

#: ..\python_docs\spladdoninternals.py:755
msgid ""
"4. For other messages, NVDA will periodically play a progress tone and "
"announce connection status so far as reported by the encoder."
msgstr ""
"4. Para otros mensajes, NVDA reproducirá periódicamente un tono de progreso "
"y verbalizará el estado de la conexión tan pronto como lo informe el "
"codificador."

#: ..\python_docs\spladdoninternals.py:756
msgid ""
"5. This loop repeats as long as this encoder is being monitored in the "
"background."
msgstr ""
"5. Este bucle se repite mientras el codificador esté siendo monitorizado en "
"segundo plano."

#: ..\python_docs\spladdoninternals.py:757
msgid "### Encoder-specific routines"
msgstr "### Procedimientos específicos del codificador"

#: ..\python_docs\spladdoninternals.py:758
msgid ""
"In addition to basic services, each encoder routine has its own goodies, "
"including:"
msgstr ""
"Además de los servicios básicos, cada procedimiento de codificación tiene "
"sus propias ventajas, incluyendo:"

#: ..\python_docs\spladdoninternals.py:759
msgid "For SAM encoders:"
msgstr "Para los codificadores SAM:"

#: ..\python_docs\spladdoninternals.py:760
msgid "* To disconnect, press F10."
msgstr "* Para desconectar, pulsa f10."

#: ..\python_docs\spladdoninternals.py:761
msgid ""
"* You can press Control+F9 or Control+F10 to connect or disconnect all "
"encoders (does not work well in recent SAM releases, according to my tests). "
"A workaround was developed to fix this problem (opens context menu and "
"activates the correct item on its own)."
msgstr ""
"* Puedes pulsar ctrl+f9 o ctrl+f10 para conectar y desconectar todos los "
"codificadores (no funciona bien en versiones recientes de SAM, según mis "
"pruebas). Se desarrolló un parche para solucionar este problema (abre el "
"menú contextual y activa el elemento correspondiente por sí mismo)."

#: ..\python_docs\spladdoninternals.py:762
msgid "For SPL encoders:"
msgstr "Para los codificadores SPL:"

#: ..\python_docs\spladdoninternals.py:763
msgid "* When you press F9 to connect, NVDA does the following:"
msgstr "* Cuando pulsas f9 para conectar, NVDA hace lo siguiente:"

#: ..\python_docs\spladdoninternals.py:764
msgid ""
"\t1. Locates \"connect\" button, and if it says \"Connect\", clicks it (obj."
"doAction)."
msgstr ""
"\t1. Ubica el botón conectar, y si está etiquetado como \"connect\", hace "
"clic en él (obj.doAction)."

#: ..\python_docs\spladdoninternals.py:765
msgid "\t2. Moves focus back to the entry (self.SetFocus)."
msgstr "\t2. Mueve el foco de vuelta a la entrada (self.setFocus)."

#: ..\python_docs\spladdoninternals.py:766
msgid ""
"* To disconnect, press TAB until you arrive at \"Disconnect\" button and "
"press SPACE."
msgstr ""
"* Para desconectar, pulsa tabulador hasta que llegues al botón \"Desconectar"
"\" y pulsa la barra espaciadora."

#: ..\python_docs\spladdoninternals.py:767
msgid "## Final notes and add-on development process overview"
msgstr ""
"## Notas finales y descripción del proceso de desarrollo de un complemento"

#: ..\python_docs\spladdoninternals.py:768
msgid ""
"Now that we've visited internals of StationPlaylist Studio add-on, I'd like "
"to give you a tour of my lab where I develop this add-on. Along the way "
"you'll learn how an add-on is born, coded, tested, released and maintained."
msgstr ""
"Ahora que hemos visitado el interior del complemento StationPlaylist Studio, "
"me gustaría hacerte un recorrido por mi laboratorio, donde desarrollo este "
"complemento. Durante el camino aprenderás cómo nace un complemento, se "
"codifica, se prueba, se publica y se mantiene."

#: ..\python_docs\spladdoninternals.py:769
msgid "### Lab setup, development equipment and software"
msgstr "### Preparación del laboratorio, equipamiento de desarrollo y software"

#: ..\python_docs\spladdoninternals.py:770
#, fuzzy
#| msgid ""
#| "For all my software development, I use two computers: a touchscreen "
#| "laptop and a desktop, both running Windows 10 and latest NVDA next branch "
#| "snapshots. Both also run Cygwin and/or Windows Subsystem for Linux (WSL, "
#| "otherwise known as BASH on Ubuntu on Windows)to run various command-line "
#| "tools (Git, SCons, etc.), and in case I need to compile NVDA from source "
#| "code, installed Visual Studio 2015 with latest update and other "
#| "dependencies."
msgid ""
"For all my software development, I use two computers: a touchscreen laptop "
"and a desktop, both running Windows 10 and latest NVDA alpha snapshots. Both "
"also run Cygwin and/or Windows Subsystem for Linux (WSL, otherwise known as "
"BASH on Ubuntu on Windows)to run various command-line tools (Git, SCons, "
"etc.), and in case I need to compile NVDA from source code, installed Visual "
"Studio 2017 with latest update and other dependencies."
msgstr ""
"Para todos mis desarrollos de software, yo uso dos ordenadores: un portátil "
"con pantalla táctil y un sobremesa, ambos ejecutando Windows 10 y las "
"últimas versiones de desarrollo next de NVDA. Ambos también tienen Cygwin "
"y / o el subsistema de Windows para Linux (WSL, conocido de otra manera como "
"BASH en Ubuntu en Windows) para ejecutar varias herramientas de la línea de "
"órdenes (git, SCons, etc.), y en caso que necesite compilar NVDA desde el "
"código fuente, tengo instalado Visual Studio 2015 con la última "
"actualización y otras dependencias."

#: ..\python_docs\spladdoninternals.py:771
msgid ""
"In case of SPL add-on, I have different Studio versions installed: 5.11 on "
"my laptop and 5.20 on the desktop. This allows me to work on both versions "
"at once (both computers have the full source code of the add-on, though I "
"tend to write bug fixes on my laptop and experiment with new things on my "
"desktop)."
msgstr ""
"En el caso del complemento SPL, tengo diferentes versiones de Studio "
"instaladas: 5.11 en mi portátil y 5.20 en el sobremesa. Esto me permite "
"trabajar en ambas versiones de una vez (ambos ordenadores tienen el código "
"fuente completo del complemento, aunque tiendo a solucionar fallos en mi "
"portátil y experimentar con cosas nuevas en mi sobremesa)."

#: ..\python_docs\spladdoninternals.py:772
msgid "### Git: a \"smart\" source code manager"
msgstr "### Git: un gestor de código fuente inteligente"

#: ..\python_docs\spladdoninternals.py:773
msgid ""
"Like other NVDA developers and many add-on writers, I use Git for source "
"code management (contrary to its slogan, Git is very smart). This is a "
"distributed system, meaning a local repository contains the complete record "
"of how the source code is managed (no need to connect to a server to commit "
"and fetch updates). For example, using just my local copy of the SPL add-on "
"source code, I can view commit history and generate older add-on releases."
msgstr ""
"Al igual que los desarrolladores de NVDA y muchos creadores de complementos, "
"uso Git para gestionar el código fuente (contrariamente a su lema, Git es "
"muy inteligente). Se trata de un sistema distribuido, lo que significa que "
"un repositorio local contiene el registro completo de cómo se gestiona el "
"código fuente (sin necesidad de conectarse a un servidor para confirmar y "
"obtener actualizaciones). Por ejemplo, si uso simplemente mi copia local del "
"código fuente del complemento de SPL, puedo ver el historial de commits y "
"generar versiones antiguas del complemento."

#: ..\python_docs\spladdoninternals.py:774
#, fuzzy
#| msgid ""
#| "Another advantage of Git is extensive support for branches. A branch is a "
#| "development workflow separate from other branches. For example, NVDA "
#| "screen reader uses at least three branches for its workflow: alpha "
#| "(master branch), beta (beta branch) and rc (release candidate, used to "
#| "build official releases). SPL add-on uses this approach as well: there "
#| "are at least two branches in use, called master and stable used for "
#| "ongoing development or release and maintenance, respectively (we'll come "
#| "back to branches in a second). With the advent of Test Drive program (see "
#| "below), a third branch named \"staging\" or \"next\" is used to gather "
#| "all work done on branches under one roof for testing purposes (in 2018, "
#| "this has changed significanlty)."
msgid ""
"Another advantage of Git is extensive support for branches. A branch is a "
"development workflow separate from other branches. For example, NVDA screen "
"reader uses at least three branches for its workflow: alpha (master branch), "
"beta (beta branch) and rc (release candidate, used to build official "
"releases). SPL add-on uses this approach as well: there are at least two "
"branches in use, called master and stable used for ongoing development or "
"release and maintenance, respectively (we'll come back to branches in a "
"second). With the advent of Test Drive program (see below), a third branch "
"named \"staging\" or \"next\" is used to gather all work done on branches "
"under one roof for testing purposes (in 2018, this has changed "
"significantly)."
msgstr ""
"Otra ventaja de Git es su extenso soporte para ramas. Una rama es un flujo "
"de trabajo separado de otras ramas. Por ejemplo, el lector de pantalla NVDA "
"usa al menos tres ramas para su flujo de trabajo: alfa (rama master), beta "
"(rama beta) y rc (candidata a liberación, usada para construir versiones "
"oficiales). El complemento de SPL usa este enfoque así: hay al menos dos "
"ramas en uso, llamadas master y stable, usadas para desarrollo activo y "
"publicación y mantenimiento, respectivamente (volveremos a las ramas en un "
"segundo). Con la llegada del programa de unidad de pruebas (mira debajo), se "
"usa una tercera rama llamada \"staging\" o \"next\" para recopilar todo el "
"trabajo hecho en ramas bajo un techo con propósitos de prueba (en 2018, esto "
"ha cambiado significativamente)."

#: ..\python_docs\spladdoninternals.py:775
msgid "### How an add-on feature is born"
msgstr "### Cómo nace una característica de un complemento"

#: ..\python_docs\spladdoninternals.py:776
msgid ""
"Let's go through a typical development process for an add-on feature by "
"looking at how broadcast profiles was developed (for more information on "
"broadcast profiles, refer to configuration management section above)."
msgstr ""
"Recorramos el proceso típico de desarrollo de una característica de un "
"complemento viendo cómo se desarrollaron los perfiles de emisión (para más "
"información sobre los perfiles de emisión, consulta la sección de gestión de "
"la configuración de arriba)."

#: ..\python_docs\spladdoninternals.py:777
msgid ""
"I started working on broadcast profiles in March 2015 while developing add-"
"on 5.0. This was a natural extension of add-on settings dialog: whereas this "
"dialog (and the configuration database it uses) only dealt with a single "
"profile, I thought it might be a good idea to allow multiple profiles to be "
"defined and to let the settings dialog respond to profile changes."
msgstr ""
"Comencé a trabajar en los perfiles de emisión en marzo de 2015 mientras "
"desarrollaba el complemento 5.0. Se trataba de una extensión natural del "
"diálogo de configuración del complemento: mientras que este cuadro de "
"diálogo (y la base de datos de configuración que usa) sólo se ocupa de un "
"único perfil, pensé que sería una buena idea permitir que se definan varios "
"perfiles y hacer que el diálogo de configuración reaccione ante el cambio de "
"perfiles."

#: ..\python_docs\spladdoninternals.py:778
msgid ""
"There was an important reason for writing this feature: Since NVDA supports "
"multiple configuration profiles and since some broadcasters were hosting "
"multiple shows, I thought it would be a good idea to implement a similar "
"feature in the SPL add-on. Thus, I envisioned broadcast profiles to be used "
"primarily by people hosting multiple shows, with each show defined as a "
"profile."
msgstr ""
"Había una razón importante para crear esta característica: ya que NVDA "
"soporta varios perfiles de configuración y ya que algunos locutores "
"presentan varios programas, pensé que sería una buena idea implementar una "
"característica similar en el complemento. Por lo tanto, preví que los "
"perfiles de emisión serían usados principalmente por gente que tuviera "
"varios programas, definiendo un perfil para cada programa."

#: ..\python_docs\spladdoninternals.py:779
msgid ""
"In March and April 2015, I started rewriting certain parts of add-on "
"configuration manager (splstudio.splconfig) in preparation for developing "
"broadcast profiles (now included as part of add-on 6.0). I started by "
"writing todo comments (where appropriate) describing what the future feature "
"should be like. I then modified initConfig and saveConfig (discussed in app "
"module articles), initially telling them to work with the default profile "
"(the one and only configuration map then), then I left it alone until add-on "
"5.0 was released in June 2015."
msgstr ""
"En marzo y abril de 2015, comencé a reescribir ciertas partes del gestor de "
"configuración del complemento (splstudio.splconfig) como preparación para "
"desarrollar los perfiles de emisión (incluidos ahora como parte del "
"complemento 6.0). Comencé anotando algunas tareas (donde correspondía) "
"describiendo cómo debería ser la característica futura. Después modifiqué "
"initConfig y saveConfig (expuestas en los artículos del módulo de "
"aplicación), diciéndoles inicialmente que trabajaran con el perfil "
"predeterminado (el único mapa de configuración por entonces), luego las dejé "
"solas hasta que se publicó el complemento 5.0 en junio de 2015."

#: ..\python_docs\spladdoninternals.py:780
msgid ""
"In June 2015, I opened a new branch (initially using the codename \"starfish"
"\") to house code related to broadcast profiles. Before any \"real\" code "
"was written, I studied NvDA source code dealing with configuration profiles "
"to learn more about how Jamie (James Teh from NV Access) implemented this "
"feature. Once I understood how it worked, I copied, pasted and changed the "
"code to match the overall add-on code base (giving nV Access the credit they "
"deserve)."
msgstr ""
"En junio de 2015, abrí una nueva rama (usando inicialmente el nombre "
"\"starfish\") para alojar el código relacionado con los perfiles de emisión. "
"Antes de escribir cualquier código \"real\", estudié el código fuente de "
"NVDA relacionado con los perfiles de configuración para aprender más sobre "
"cómo Jamie (James Teh de NV Access) implementó esta característica. Una vez "
"entendí cómo funcionaba, copié, pegué y modifiqué el código para que "
"encajara con el del complemento (dando a NV Access el crédito que le "
"corresponde)."

#: ..\python_docs\spladdoninternals.py:781
msgid ""
"One of the first things I had to decide was how to store profiles. I "
"experimented with using ConfigObj sections, one per profile, but this proved "
"to be problematic (a profile could be given the name of an existing "
"configuration map key). I then went back to NVDA source code to find out how "
"NV Access solved this problem (using separate ini files), implemented it, "
"and was met with another problem: transfering values between profiles. This "
"was resolved by specifying whether a setting was \"global\" (applies to all "
"profiles) or specific to a profile. Next came profile controls in the add-on "
"settings dialog and using choice events to set alarm values using values "
"from the selected profile."
msgstr ""
"Una de las primeras cosas que tenía que decidir era cómo almacenar los "
"perfiles. Experimenté usando secciones de ConfigOBJ, una por perfil, pero "
"resultó que daba problemas (se podía dar a un perfil el nombre de la clave "
"de un mapa existente). Entonces fui de vuelta al código fuente de NVDA para "
"saber cómo resolvió NV Access este problema (usando archivos ini separados), "
"lo implementé, y me encontré con otro problema: la transferencia de valores "
"entre perfiles. Esto lo resolví especificando si un ajuste era \"global"
"\" (se aplica a todos los perfiles) o específico de un perfil. Lo siguiente "
"que vino fueron los controles en el diálogo de configuración del complemento "
"y usar eventos de elección para establecer valores para la alarma usando los "
"valores del perfil seleccionado."

#: ..\python_docs\spladdoninternals.py:782
msgid ""
"The last thing I did before merging the broadcast profiles branch to master "
"branch in July was revising configuration error dialog and writing "
"documentation for broadcast profiles. Once the documentation was ready and "
"small issues were fixed after going through many rounds of testing (on my "
"own computer and from the profiles branch itself), broadcast profiles branch "
"was merged into master. But the development didn't stop there: thanks to "
"provisions I made, it was quite simple to implement instant switch profiles "
"(again it had issues which are now largely resolved)."
msgstr ""
"Lo último que hice antes de mezclar la rama de perfiles de emisión en la "
"rama master en julio fue revisar el diálogo de error de configuración y "
"escribir documentación para los perfiles de emisión. Una vez la "
"documentación estuvo lista y se solucionaron pequeños errores después de "
"hacer muchas rondas de pruebas (en mi propio ordenador y desde la rama de "
"perfiles), se mezcló la rama de perfiles de emisión en master. Pero el "
"desarrollo no se detuvo ahí: gracias a las previsiones que hice, fue "
"bastante simple implementar los perfiles de cambio instantáneo (de nuevo "
"hubo problemas que ya están de sobra resueltos)."

#: ..\python_docs\spladdoninternals.py:783
msgid ""
"### Dealing with threaded code: headaches during development of background "
"encoder monitoring feature"
msgstr ""
"### Trato con código en hilos: dolores de cabeza durante el desarrollo de la "
"característica de monitorización del codificador en segundo plano"

#: ..\python_docs\spladdoninternals.py:784
msgid ""
"You may recall our discussion of Cart Explorer and how it went through "
"extensive testing to arrive at the current state (this was a difficult code "
"segment). When it comes to difficulty, nothing beats multithreaded code, "
"especially if it involves multiple threads working in parallel (rather, "
"almost parallel), and I tasted this when writing background encoder monitor "
"(add-on 5.0). This involved tracking how many threads were running to make "
"sure no unnecessary threads were running, catching suttle errors and race "
"conditions (a connection attempt could run a thread without checking if the "
"encoder is being monitored) and so on. Thankfully, I went through a similar "
"set of problems a few months earlier when I struggled with library scan (add-"
"on 4.0), and that experience taught me to be careful with threads (and to "
"experience fewer headaches)."
msgstr ""
"Puedes recordar nuestra exposición sobre el explorador cart y cómo pasó unas "
"extensas pruebas hasta llegar a su estado actual (fue un segmento de código "
"difícil). Cuando hablamos de dificultad, nada supera al código multihilo, "
"especialmente si implica varios hilos trabajando en paralelo (bueno, casi en "
"paralelo). Yo saboreé esto al programar el monitor del codificador en "
"segundo plano (complemento 5.0). Esto implicó rastrear cuántos hilos estaban "
"ejecutándose para asegurarse de que no había hilos innecesarios, capturar "
"errores y condiciones de carrera (un intento de conexión podía lanzar un "
"hilo sin comprobar si el codificador estaba siendo monitorizado) y demás. "
"Afortunadamente, pasé por unos problemas similares unos meses atrás cuando "
"desarrollé el escaneo de biblioteca (complemento 4.0), y esa experiencia me "
"enseñó a tener cuidado con los hilos (y experimentar menos dolores de "
"cabeza)."

#: ..\python_docs\spladdoninternals.py:785
msgid "### Add-on development process"
msgstr "### El proceso de desarrollo del complemento"

#: ..\python_docs\spladdoninternals.py:786
msgid ""
"Follow me as I show you how a typical SPL add-on version is developed, "
"released and maintained:"
msgstr ""
"Sígueme mientras te muestro cómo se desarrolla, publica y mantiene una "
"versión típica del complemento para SPL:"

#: ..\python_docs\spladdoninternals.py:787
msgid ""
"1. Before starting work on the new add-on version, I write down some goals "
"the add-on should achieve, including feature ideas, user (your) suggestions "
"and so on. With changes to the process in 2017, a feature development may "
"span multiple versions."
msgstr ""
"1. Antes de comenzar a trabajar en la nueva versión del complemento, apunto "
"algunos objetivos que el complemento debería alcanzar, incluyendo ideas de "
"características, sugerencias del usuario (tuyas) y demás. Con los cambios "
"del proceso en 2017, el desarrollo de una característica puede hacerse a lo "
"largo de varias versiones."

#: ..\python_docs\spladdoninternals.py:788
msgid ""
"2. I then hold a conference call with add-on users to see what they think "
"about some ideas and gather feedback (these are also written down)."
msgstr ""
"2. A continuación hago una conferencia por llamada con usuarios del "
"complemento para ver qué piensan de algunas ideas y recopilar comentarios "
"(que también me apunto)."

#: ..\python_docs\spladdoninternals.py:789
msgid ""
"3. I then create separate branches for each feature in order to isolate  "
"code and not to break existing code."
msgstr ""
"3. Después creo ramas separadas para cada característica para aislar código "
"y no romper el código existente."

#: ..\python_docs\spladdoninternals.py:790
msgid ""
"4. Next, I write todo comments reminding myself as to what the feature "
"should be like, then I start working on it. As each feature is being "
"developed, I do mental simulations as to how you might use the feature under "
"development, such as possible errors, messages spoken and so on."
msgstr ""
"4. Después, escribo comentarios para recordarme a mí mismo cómo debería ser "
"la característica, luego empiezo a trabajar en ella. Según se va "
"desarrollando cada característica, hago simulaciones mentales sobre cómo "
"podrías usar la característica en desarrollo, posibles errores, mensajes "
"verbalizados y así."

#: ..\python_docs\spladdoninternals.py:791
msgid ""
"5. Once the feature is quite stable, I test the feature to uncover bugs and "
"to fill in the missing pieces. When it comes to testing, I test the new "
"feature branch on both of my computers running different versions of Studio "
"to make sure it works across versions (if not, I go back and modify the code "
"to recognize differences between Studio versions)."
msgstr ""
"5. Una vez la característica está bastante estable, la pruebo para descubrir "
"fallos y rellenar los huecos que faltan. Cuando pasa a pruebas, pruebo la "
"nueva rama de características en mis dos ordenadores, que ejecutan versiones "
"distintas de Studio, para asegurarme de que funciona entre versiones (si no, "
"vuelvo atrás y modifico el código para reconocer las diferencias entre "
"versiones de Studio)."

#: ..\python_docs\spladdoninternals.py:792
msgid ""
"6. Starting in fall 2015, I've merged development branches into a staging "
"branch for testing purposes. This branch is also used to generate try (Test "
"Drive program) builds so those who've signed up for early access program can "
"leave feedback (try builds are generated about once a week)."
msgstr ""
"6. Empezando a finales del 2015, he mezclado las ramas de desarrollo en una "
"única rama con propósitos de prueba. Esta rama también se usa para generar "
"compilaciones de prueba (programa de unidad de pruebas), así que todo el que "
"se ha registrado para el programa de acceso previo puede dejar comentarios "
"(las compilaciones de prueba se generan aproximadamente una vez a la semana)."

#: ..\python_docs\spladdoninternals.py:793
msgid ""
"7. After testing the feature for a while and if the feature is stable, I "
"merge the feature branch into master."
msgstr ""
"7. Después de probar la característica durante un rato y si esta es estable, "
"mezclo la rama de la característica en master."

#: ..\python_docs\spladdoninternals.py:794
msgid ""
"8. Every few weeks, I publish master branch snapshots to gather feedback "
"from users willing to test drive snapshots. With the advent of add-on "
"updates in add-on 7.0, one can update between snapshots or stable versions "
"(whichever branch one is using, the update check routine wil use that "
"branch; for example, if one is using master snapshots, updates will be "
"fetched from master branch only)."
msgstr ""
"8. Cada pocas semanas, publico versiones de desarrollo de la rama master "
"para recopilar comentarios de los usuarios que estén dispuestos a probar "
"versiones de desarrollo dirigidas. Con la llegada de las actualizaciones del "
"complemento en la versión 7.0, cualquiera puede actualizar entre versiones "
"estables o de prueba (la rama en uso será utilizada por el actualizador; por "
"ejemplo, si alguien usa las versiones de desarrollo master, las "
"actualizaciones sólo se recuperarán desde la rama master)."

#: ..\python_docs\spladdoninternals.py:795
msgid ""
"9. At some point, I set release target window for the next add-on version "
"(for 6.0, it was December 2015). This determines when feature freeze should "
"be and beta release window (for 6.0, beta 1 was released in October 2015). "
"Between feature freeze and the first beta release, I concentrate on code "
"refinements and bug fixes. This has changed significnatly in 2017 (see "
"below)."
msgstr ""
"9. En algún momento, establezco la fecha de la publicación de la próxima "
"versión del complemento (para la versión 6.0, fue en diciembre del 2015). "
"Esto determina cuándo debería ser la congelación de características y la "
"fecha de liberación de la beta (para el 6.0, la beta 1 se publicó en octubre "
"del 2015). Entre la congelación de características y la primera liberación "
"beta, me concentro en refinar el código y arreglar fallos. Esto ha cambiado "
"significativamente en 2017 (mira más abajo)."

#: ..\python_docs\spladdoninternals.py:796
msgid ""
"10. After going through several beta cycles (typically two), I ask NVDA "
"community add-on reviewers to review my add-on code and request add-on "
"release during the release window (this is done by merging master branch "
"into stable branch)."
msgstr ""
"10. Después de hacer varios ciclos beta (generalmente dos), pido a los "
"revisores de la comunidad de NVDA que revisen el código de mi complemento y "
"pidan su publicación en las fechas apropiadas (esto se hace mezclando la "
"rama master en la rama stable)."

#: ..\python_docs\spladdoninternals.py:797
msgid ""
"11. Once the add-on version is released, subsequent maintenance versions "
"(localization updates, bug fixes, minor tweaks) will be released from the "
"stable branch, with the master branch containing the code for the next major "
"version."
msgstr ""
"11. Una vez se publica la versión del complemento, las siguientes versiones "
"de mantenimiento (actualización de traducciones, solución de fallos, "
"retoques menores) se liberarán desde la rama stable, con la rama master "
"conteniendo el código para la siguiente gran versión."

#: ..\python_docs\spladdoninternals.py:798
msgid ""
"12. Once the next version enters beta cycle, further maintenance releases "
"may or may not happen (an exception is long-term support release, described "
"below)."
msgstr ""
"12. Una vez la siguiente versión entra en el ciclo de betas, podría haber o "
"podría no haber más versiones de mantenimiento (una excepción son las "
"versiones de soporte extendido, descritas más abajo)."

#: ..\python_docs\spladdoninternals.py:799
msgid "#### Changes in 2017"
msgstr "#### Cambios en 2017"

#: ..\python_docs\spladdoninternals.py:800
msgid ""
"In late 2016, I and some users had a conference call regarding the future "
"direction of the add-on. During this call, participants felt that the add-on "
"now includes all the features people need, so it was decided to scale back "
"on features and focus on compatibility with new Studio releases. In the end, "
"it was decided that a version of the add-on to be released in 2017 will be "
"the final major version of the Studio add-on, with future updates being byte-"
"sized chunks."
msgstr ""
"Ya entrado 2016, algunos usuarios y yo tuvimos una conferencia por llamada "
"relacionada con la dirección futura del complemento. Durante esta llamada, "
"los participantes sentían que el complemento ya incluye todas las funciones "
"que la gente necesita, por lo que se decidió dejar de escalar en "
"características y enfocarse en la compatibilidad con nuevas versiones de "
"Studio. Al final, se decidió que una versión del complemento que se "
"publicaría en 2017 sería la versión final principal del complemento de "
"Studio, con las futuras actualizaciones siendo muy pequeñas."

#: ..\python_docs\spladdoninternals.py:801
msgid ""
"This decision also aligned with my other add-ons where new versions were "
"released every month or so, along with the fact that features are complete "
"for most add-ons. The new regular update schedule for SPL add-on was "
"implemented as of June 2017."
msgstr ""
"Esta decisión también se alineó con mis otros complementos, donde las nuevas "
"versiones se liberaban cada mes o así, junto al hecho de que las "
"características están completas en la mayoría de complementos. La nueva "
"programación regular de actualizaciones del complemento de SPL se implementó "
"en junio de 2017."

#: ..\python_docs\spladdoninternals.py:802
msgid "There were two more implications of this decision:"
msgstr "Esta decisión implicaba dos cosas más:"

#: ..\python_docs\spladdoninternals.py:803
msgid ""
"* No more waits: a new stable feature should not be held up for up to six "
"months if it is ready for the public, thus updates include both new features "
"and bug fixes."
msgstr ""
"* No más esperas: una nueva característica estable no debería retenerse "
"hasta dentro de seis meses si está lista para el público, y por tanto las "
"actualizaciones incluyen nuevas características y solución de fallos."

#: ..\python_docs\spladdoninternals.py:804
msgid ""
"* The Test Drive program (see below) should not be an exclusive thing "
"anymore, but an opt-in process, as I felt early feedback loop is crucial to "
"success of a product such as this add-on."
msgstr ""
"* El programa de pruebas dirigidas (mira más abajo) no debería ser algo "
"exclusivo nunca más, sino un proceso al que se pueda optar, ya que yo sentía "
"que el bucle de retroalimentación temprana es crucial para el éxito de un "
"producto como este complemento."

#: ..\python_docs\spladdoninternals.py:805
msgid "With this in mind, the following things were changed in 2017:"
msgstr "Con esto en mente, las siguientes cosas cambiaron en 2017:"

#: ..\python_docs\spladdoninternals.py:806
msgid ""
"* No more betas: the development branch (now called slow ring) is considered "
"live beta branch."
msgstr ""
"* No más betas: la rama de desarrollo (ahora llamada anillo lento) se "
"considera como rama de betas."

#: ..\python_docs\spladdoninternals.py:807
#, fuzzy
#| msgid ""
#| "* Anyone can switch to try build branch (now called fast ring snapshots) "
#| "provided that they are willing to provide early feedback."
msgid ""
"* Anyone can switch to try build branch (called fast ring snapshots) "
"provided that they are willing to provide early feedback."
msgstr ""
"* Cualquiera puede cambiar a la rama de compilaciones de prueba (ahora "
"llamada anillo rápido de instantáneas) suponiendo que estén interesados en "
"proporcionar retroalimentación temprana."

#: ..\python_docs\spladdoninternals.py:808
msgid ""
"* Long-term support updates are now tied to new major Studio releases. This "
"criteria was extended in late 2017 to include critical changes to NVDA (see "
"below)."
msgstr ""
"* Las actualizaciones de soporte extendido ahora están atadas a las nuevas "
"versiones principales de Studio. Este criterio se extendió entrado 2017 para "
"incluir cambios críticos en NVDA (mira más abajo)."

#: ..\python_docs\spladdoninternals.py:809
msgid "#### Further changes in 2018"
msgstr "#### Más cambios en 2018"

#: ..\python_docs\spladdoninternals.py:810
msgid ""
"In July 2018, NV Access announced changes to NVDA's release process in order "
"to make testing and integration easier. Prior to this, an NVDA feature was "
"incubated in the next snapshot for at least two weeks, and this meant having "
"to deal with increasing number of pull requests which sometimes produced "
"conflicts. To avoid this, and to let features come to master branch "
"directly, what used to be live beta (master) branch became \"alpha\" "
"snapshots. People who wanted more stability were moved to beta releases."
msgstr ""
"En julio de 2018, NV Access informó sobre cambios en el proceso de "
"liberación para facilitar la integración y las pruebas. Antes de eso, se "
"estaba incubando una nueva función de NVDA en la versión de desarrollo next "
"durante al menos dos semanas, y esto significaba tratar con el creciente "
"número de solicitudes de cambio que en ocasiones producían conflictos. Para "
"evitar esto, y hacer que las nuevas funciones vinieran a la rama master "
"directamente, lo que solía ser la rama de beta en vivo (master) se convirtió "
"en las versiones de desarrollo \"alpha\". Se movió a la gente que quería más "
"estabilidad a las versiones beta."

#: ..\python_docs\spladdoninternals.py:811
msgid ""
"On the SPL add-on side, Test Drive Fast and Slow ring builds have become "
"identical in late July 2018. I also felt that add-on development has slowed "
"down considerably, as well as preparing for the next long-term support "
"release (18.09), thus I felt an overhaul of Test Drive Program was in order."
msgstr ""
"Por parte del complemento para SPL, las compilaciones de los anillos lento y "
"rápido del programa de prueba se han vuelto idénticas a finales de agosto de "
"2018. He sentido también que el desarrollo del complemento se ha ralentizado "
"considerablemente mientras se preparaba la siguiente versión LTS (18.09) y, "
"por tanto, reacondicioné el programa de unidad de pruebas."

#: ..\python_docs\spladdoninternals.py:812
msgid ""
"Then in August 2018, I released Add-on Updater, a proof of concept add-on "
"that allows NVDA to check for add-on updates for all add-ons registered with "
"NVDA Community Add-ons website. In its early days, SPL add-on was excluded "
"because it interfered with Add-on Updater's own update check facility. In "
"reality, I generalized SPL add-on's update check code and transfered it to "
"the new Add-on Updater, hence almost identical internals."
msgstr ""
"Después, en agosto de 2018, publiqué Add-on Updater, un complemento que "
"actuaba como prueba de concepto que permite que NVDA busque actualizaciones "
"de todos los complementos registrados en el sitio web de complementos de la "
"comunidad. En sus primeros días, se excluyó el complemento de SPL porque "
"interfería con la propia función de búsqueda de actualizaciones de Add-on "
"Updater. En realidad, generalicé el código de búsqueda de actualizaciones "
"del complemento de SPL y lo transferí al nuevo Add-on Updater, por lo que "
"era casi idéntico por dentro."

#: ..\python_docs\spladdoninternals.py:813
msgid ""
"Given that my long-term goal is to let NVDA itself check for SPL add-on "
"updates, coupled with observations from above, I asked the community if it "
"would be better to change the nature of Test Drive Fast ring and to let Add-"
"on Updater check for all add-on updates. The community agreed, hence the "
"following changes were made in August 2018 prior to release of 18.09:"
msgstr ""
"Dado que mi objetivo a largo plazo es hacer que NVDA busque por sí mismo las "
"actualizaciones del complemento para SPL, además de las observaciones "
"anteriores, pregunté a la comunidad si sería mejor cambiar la naturaleza del "
"anillo rápido de la unidad de pruebas para que sea Add-on Updater el que "
"busque todas las actualizaciones. La comunidad estuvo deacuerdo, por lo que "
"se llevaron a cabo los siguientes cambios en agosto de 2018 antes de "
"publicar la versión 18.09:"

#: ..\python_docs\spladdoninternals.py:814
msgid ""
"* Test Drive Fast and Slow rings were combined into a single \"development\" "
"channel. Consequently, there is no more update channel selection capability, "
"with users encouraged to obtain the right releases from add-ons website. "
"This was extended in September 2018 to cover long-term support releases."
msgstr ""
"* Los anillos rápido y lento de la unidad de pruebas se combinaron en un "
"único canal de \"desarrollo\". Como consecuencia ya no existe la posibilidad "
"de elegir el canal de actualización, siendo los usuarios los encargados de "
"obtener la versión correcta desde la web de complementos. Esto se extendió "
"en septiembre de 2018 para cubrir las versiones de soporte extendido."

#: ..\python_docs\spladdoninternals.py:815
msgid ""
"* A new concept of \"pilot features\" replaced Test Drive Fast, configurable "
"via a checkbox and internal flags."
msgstr ""
"* Un nuevo concepto de \"funciones piloto\" reemplazó al anillo rápido de la "
"unidad de pruebas, configurable mediante una casilla de verificación e "
"indicadores internos."

#: ..\python_docs\spladdoninternals.py:816
msgid ""
"* New features under development will be enabled if pilot features facility "
"is turned on, otherwise content is identical to regular development build."
msgstr ""
"* Las nuevas funciones en desarrollo se activarán si la opción de funciones "
"piloto se activa, en cualquier otro caso el contenido es idéntico al de las "
"versiones de desarrollo regulares."

#: ..\python_docs\spladdoninternals.py:817
msgid ""
"* Add-on update checking facility is now taken care of by Add-on Updater, "
"and in the future, to be done by NVDA itself."
msgstr ""
"* La función de búsqueda de actualizaciones del complemento la lleva a cabo "
"Add-on Updater, y en el futuro, el propio NVDA."

#: ..\python_docs\spladdoninternals.py:818
msgid "#### Long-term support release"
msgstr "#### Versión de soporte extendido"

#: ..\python_docs\spladdoninternals.py:819
msgid ""
"A typical add-on version is supported until the next add-on version is "
"released (currently several weeks to months). However, there are times when "
"an add-on version receives extended support (termed long-term support (LTS) "
"release). This happens if the next major version of Studio is released, a "
"version of Studio with user interface changes is released, or critical "
"changes are expected in future NVDA releases such as ending support for a "
"Windows version."
msgstr ""
"Una versión típica de un complemento se soporta hasta que se publica la "
"siguiente versión del complemento (actualmente varias semanas o meses). Sin "
"embargo, hay veces en las que una versión de un complemento recibe soporte "
"extendido (llamadas versiones lts). Esto pasa si se publica la siguiente "
"versión de Studio, se publica una versión de Studio con cambios en la "
"interfaz de usuario, o se esperan cambios críticos en versiones futuras de "
"NVDA tales como finalización de soporte para una versión de Windows."

#: ..\python_docs\spladdoninternals.py:820
msgid ""
"A LTS version is a major version or a major periodic release of the SPL add-"
"on with some notable differences:"
msgstr ""
"Una versión lts es una versión mayor o una versión periódica del complemento "
"de SPL con algunas diferencias destacables:"

#: ..\python_docs\spladdoninternals.py:821
msgid ""
"* Support duration: A LTS version is supported for at least twelve months."
msgstr ""
"* Duración del soporte: una versión LTS recibe soporte durante al menos doce "
"meses."

#: ..\python_docs\spladdoninternals.py:822
msgid ""
"* Features: A LTS version may contain some features from future add-on "
"releases provided that they can be safely backported."
msgstr ""
"* Características: una versión lts puede contener algunas características de "
"versiones futuras del complemento que pueden agregarse de forma segura."

#: ..\python_docs\spladdoninternals.py:823
msgid ""
"* Studio version supported: A LTS version is the last version to support the "
"oldest supported Studio version. This is designed to give people plenty of "
"time to upgrade to newer Studio releases."
msgstr ""
"* Versión soportada de Studio: una versión lts es la última versión en dar "
"soporte a la versión de Studio más antigua soportada. Esto se diseña así "
"para dar a la gente todo el tiempo posible para actualizarse a una nueva "
"versión de Studio."

#: ..\python_docs\spladdoninternals.py:824
msgid ""
"* Last version with old NVDA technology in use: in some cases, LTS releases "
"are made to support users of old NVDA releases. After the LTS release is "
"created, add-on source code will shift to using newer code from NVDA. This "
"criteria will first be applied to an LTS release scheduled for 2018 as a "
"result of NVDA's end of support for Windows XP, Vista and 7 without Service "
"Pack 1, as well as planned transition to Python 3."
msgstr ""
"* Última versión que usa tecnología de NVDA antigua: en algunos casos, las "
"versiones lts están hechas para dar soporte a usuarios de versiones antiguas "
"de NVDA. Después de crear la versión lts, el código fuente del complemento "
"cambiará para usar el código más reciente de NVDA. Este criterio primero se "
"aplicará a una versión lts prevista para 2018 como resultado del fin de "
"soporte de NVDA para Windows XP, Vista y 7 sin Service Pack 1, así como para "
"la transición planeada a Python 3."

#: ..\python_docs\spladdoninternals.py:825
msgid ""
"As of September 2018, the most recent LTS version is add-on 18.09.x "
"(September 2018 to December 2019 at the earliest). Previous LTS releases "
"have included 15.x (formerly 7.x until October 2016; October 2016 to April "
"2018) and 3.x (September 2014 to June 2015). For example, add-on 3.x was "
"maintained thus:"
msgstr ""
"A fecha de septiembre de 2018, la versión LTS más reciente es la 18.09.x "
"(desde septiembre de 2018 hasta diciembre de 2019 como muy pronto). Entre "
"las versiones LTS anteriores se incluyen la 15.x, conocida como 7.x hasta "
"octubre de 2016 (de octubre de 2016 a abril de 2018). La versión lts "
"anterior era la 3.x (de septiembre de 2014 a junio de 2015). Por ejemplo, el "
"complemento 3.x se mantuvo de la siguiente manera:"

#: ..\python_docs\spladdoninternals.py:826
msgid "1. Add-on 3.0 was released in September 2014."
msgstr "1. El complemento 3.0 fue publicado en 2014."

#: ..\python_docs\spladdoninternals.py:827
msgid ""
"2. Add-on 3.5 (December 2014) could have been the last maintenance version "
"for add-on 3.x if it was not a LTS version."
msgstr ""
"2. El complemento 3.5 (diciembre de 2014) podría haber sido la última "
"versión de mantenimiento del complemento 3.x si no hubiera sido una versión "
"lts."

#: ..\python_docs\spladdoninternals.py:828
msgid ""
"3. When add-on 4.0 was released (January 2015), add-on 3.6 was released, "
"backporting some features from 4.0. Users were told that add-on 3.x will be "
"the last version to support Studio versions earlier than 5.00. From that "
"time on, add-on 3.x was taken off the stable branch and was moved to an "
"internal branch."
msgstr ""
"3. Cuando se publicó el complemento 4.0 (enero de 2015), se liberó el "
"complemento 3.6, que traía algunas características del 4.0. Se dijo a los "
"usuarios que el complemento 3.x sería el último en dar soporte a versiones "
"de Studio anteriores a la 5.00. A partir de entonces, el complemento 3.x se "
"trasladó desde la rama stable a una rama interna."

#: ..\python_docs\spladdoninternals.py:829
msgid ""
"4. When add-on 5.0 beta was released (May 2015), add-on 3.x (3.9 was "
"available then) entered end of support countdown (no more maintenance "
"releases)."
msgstr ""
"4. Cuando se publicó la beta del complemento 5.0 (mayo de 2015), el "
"complemento 3.x (3.9 por entonces) entró en la cuenta atrás de fin de "
"soporte (sin más versiones de mantenimiento)."

#: ..\python_docs\spladdoninternals.py:830
msgid ""
"5. A few weeks later, when add-on 5.0 came out (June 2015), add-on 3.x "
"became unsupported."
msgstr ""
"5. Unas semanas más tardes, cuando llegó el complemento 5.0 (junio de 2015), "
"el complemento 3.x se quedó sin soporte."

#: ..\python_docs\spladdoninternals.py:831
msgid "### Final thoughts"
msgstr "### Consideraciones finales"

#: ..\python_docs\spladdoninternals.py:832
msgid ""
"As I end this article on StationPlaylist Studio Add-on Internals, I feel it "
"is time I reveal why my add-ons are free: it is because I love you users and "
"as a service for NVDA user and developer community (and in extension, to all "
"blind broadcasters using SPL Studio). What brings me joy as an add-on writer "
"is the fact that this add-on (and accompanying documentation) has made "
"impact in your lives and lives of listeners to your shows, as well as to "
"other NVDA users and developers around the world. Thank you users for your "
"continued support and feedback, and I promise once again that all my add-on "
"code (including SPL Studio add-on) will be free and anyone is welcome to "
"study and improve upon it."
msgstr ""
"Según termino este artículo sobre los interiores del complemento de "
"StationPlaylist Studio, siento que es el momento de que revele por qué mis "
"complementos son gratuitos: es porque amo a los usuarios como un servicio "
"para la comunidad de usuarios y desarrolladores de NVDA (y en extensión, a "
"todos los locutores que usan SPL Studio). Lo que me trae alegría como "
"escritor de complementos es el hecho de que este complemento (y la "
"documentación que lo acompaña) haya impactado en vuestras vidas y las vidas "
"de los oyentes de vuestros programas, así como a otros usuarios y "
"desarrolladores de NVDA por todo el mundo. Gracias a vosotros, usuarios, por "
"vuestro soporte continuo y vuestros comentarios, prometo una vez más que "
"todo el código de mis complementos (incluido el complemento de SPL Studio) "
"será libre y cualquiera es bienvenido para estudiarlo y mejorarlo."

#: ..\python_docs\spladdoninternals.py:833
msgid ""
"For add-on writers looking for quality add-on documentation, I hope this "
"series gave you an inspiration as to how to write amazing documentation in "
"your future projects. For people new to add-on writing or for those "
"interested in writing an add-on, I hope this Add-ons Internals series served "
"as a handy resource for your projects, and in extension, gave you an idea as "
"to how certain NVDA functions work. If you'd like to reference this "
"documentation or use it as a blueprint, you are more than welcome to do so. "
"Thank you community add-on reviewers for your continued support and reviews."
msgstr ""
"Para creadores de complementos que buscan documentación de calidad, espero "
"que este artículo os haya inspirado para escribir buena documentación en "
"vuestros proyectos futuros. Para la gente nueva en el desarrollo de "
"complementos o para aquellos interesados en desarrollar un complemento, "
"espero que este artículo de complementos de NVDA vistos por dentro haya "
"servido como un recurso útil para vuestros proyectos, y extensión, os haya "
"dado una idea de cómo funcionan ciertas funciones de NVDA. Si queréis hacer "
"referencia a esta documentación o usarla como un modelo, os invito a "
"hacerlo. Gracias a los revisores de la comunidad de complementos por vuestro "
"soporte continuo y vuestras revisiones."

#: ..\python_docs\spladdoninternals.py:834
msgid "### Important notices and credits"
msgstr "### Avisos importantes y créditos"

#: ..\python_docs\spladdoninternals.py:835
msgid ""
"I'd like to thank StationPlaylist staff for continued collaboration with "
"screen reader users in regards to accessibility of Studio. A special thanks "
"goes to Jamie Teh from NV Access and Geoff Shang (original add-on author) "
"for giving me and others a foundation for future goodies. As always, the "
"biggest thanks goes to you, the users of SPL add-on for your continued "
"feedback and teaching me new things about studio."
msgstr ""
"Me gustaría dar las gracias al personal de StationPlaylist Studio por su "
"colaboración continua con usuarios de lectores de pantalla en cuanto a la "
"accesibilidad de Studio. Va un agradecimiento especial para Jamie Teh de NV "
"Access y Geoff Shang (el autor original del complemento) por darme a mí y a "
"otros una base de la que partir. Y como siempre, el mayor agradecimiento es "
"para vosotros, los usuarios del complemento para SPL, por vuestros continuos "
"comentarios y por enseñarme cosas nuevas sobre Studio."

#: ..\python_docs\spladdoninternals.py:836
msgid ""
"Source code notice: to protect copyrights, parts of Studio API has not been "
"documented. Also, source code discussed throughout this series may change as "
"future add-on versions are developed."
msgstr ""
"Aviso del código fuente: para proteger los derechos de copia, no se han "
"documentado algunas partes de la api de Studio. Además, el código fuente "
"expuesto a lo largo de este artículo puede cambiar según se desarrollen "
"versiones futuras del complemento."

#: ..\python_docs\spladdoninternals.py:837
msgid ""
"Copyrights: StationPlaylist Studio, Track Tool and StationPlaylist Encoders "
"are copyright StationPlaylist.com. NonVisual Desktop Access is copyright "
"2006-2016 NV access Limited (released under GPL). SAM Encoders is copyright "
"Spatial Audio. Microsoft Windows and Windows API are copyright Microsoft "
"Corporation. Python is copyright Python Software Foundation. StationPlaylist "
"Studio add-on for NvDA is copyright 2011, 2013-2016 Geoff Shang, Joseph Lee "
"and others (released under GPL). Other products mentioned are copyrighted by "
"owners of these products (licenses vary)."
msgstr ""
"Derechos de copia: StationPlaylist Studio, la herramienta de pista y los "
"codificadores de StationPlaylist tienen copyright de StationPlaylist.com. "
"NonVisual Desktop Access tiene copyright 2006-2018 de NV access Limited "
"(liberado bajo la GPL). Los codificadores SAM tienen copyright de Spatial "
"Audio. Microsoft Windows y la API de Windows tienen copyright de Microsoft "
"Corporation. Python tiene copyright de la Python Software Foundation. El "
"complemento StationPlaylist Studio para NVDA tiene copyright 2011, 2013-2018 "
"de Geoff Shang, Joseph Lee y otros (liberado bajo la GPL). Otros productos "
"mencionados tienen copyright de sus respectivos propietarios (las licencias "
"varían)."

#: ..\python_docs\spladdoninternals.py:838
msgid "## References"
msgstr "## Referencias"

#: ..\python_docs\spladdoninternals.py:839
msgid ""
"1. JAWS scripts for StationPlaylist Studio (Hartgen Consultancy): http://www."
"hartgen.org/studio.html"
msgstr ""
"1. Scripts de JAWS para StationPlaylist Studio (Hartgen Consultancy): http://"
"www.hartgen.org/studio.html"

#: ..\python_docs\spladdoninternals.py:840
msgid ""
"2. Window-Eyes app for StationPlaylist (Jeff Bishop/AI Squared): https://www."
"gwmicro.com/App_Central/Apps/App_Details/index.php?"
"scriptid=1268&readMore&media=print"
msgstr ""
"2. Aplicación de Window-Eyes para StationPlaylist (Jeff Bishop/AI Squared): "
"https://www.gwmicro.com/App_Central/Apps/App_Details/index.php?"
"scriptid=1268&readMore&media=print"

#: ..\python_docs\spladdoninternals.py:841
msgid ""
"3. Plug-in (Wikipedia): https://en.wikipedia.org/wiki/Plug-in_(computing)"
msgstr ""
"3. Plug-in (Wikipedia): https://en.wikipedia.org/wiki/Plug-in_(computing)"

#: ..\python_docs\spladdoninternals.py:842
msgid ""
"4. Application Programming Interface (Wikipedia): https://en.wikipedia.org/"
"wiki/Application_programming_interface"
msgstr ""
"4. Application Programming Interface (Wikipedia): https://en.wikipedia.org/"
"wiki/Application_programming_interface"

#: ..\python_docs\spladdoninternals.py:843
msgid ""
"5. Python 2.7.13 documentation overview (Python Software Foundation): "
"https://docs.python.org/2/"
msgstr ""
"5. Descripción de la documentación de Python 2.7.13 (Python Software "
"Foundation): https://docs.python.org/2/"

#: ..\python_docs\spladdoninternals.py:844
msgid "6. Handle (Wikipedia): https://en.wikipedia.org/wiki/Handle_(computing)"
msgstr ""
"6. Handle (Wikipedia): https://en.wikipedia.org/wiki/Handle_(computing)"

#: ..\python_docs\spladdoninternals.py:845
msgid ""
"7. What is a Windows handle (Stack Overflow): http://stackoverflow.com/"
"questions/902967/what-is-a-windows-handle"
msgstr ""
"7. Qué es un manejador de Windows (Stack Overflow): http://stackoverflow.com/"
"questions/902967/what-is-a-windows-handle"

#: ..\python_docs\spladdoninternals.py:846
msgid ""
"8. FindWindow (user32.dll) reference (Windows API): https://msdn.microsoft."
"com/en-us/library/windows/desktop/ms633499(v=vs.85).aspx"
msgstr ""
"8. Referencia de FindWindow (user32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms633499(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:847
msgid ""
"9. SendMessage (user32.dll) reference (Windows API): https://msdn.microsoft."
"com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx"
msgstr ""
"9. Referencia de SendMessage (user32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:848
msgid ""
"10. NVDA Developer Guide (NV Access): http://www.nvaccess.org/files/nvda/"
"documentation/developerGuide.html"
msgstr ""
"10. Guía del desarrollador de NVDA (NV Access): http://www.nvaccess.org/"
"files/nvda/documentation/developerGuide.html"

#: ..\python_docs\spladdoninternals.py:849
msgid ""
"11. OpenProcess (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms684320(v=vs.85).aspx"
msgstr ""
"11. Referencia de OpenProcess (kernel32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms684320(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:850
msgid "12. wxPython online docs: http://www.wxpython.org/onlinedocs.php"
msgstr ""
"12. Documentación en línea de wxPython: http://www.wxpython.org/onlinedocs."
"php"

#: ..\python_docs\spladdoninternals.py:851
msgid ""
"13. Higher order functions (How do you make a higher order function): http://"
"effbot.org/pyfaq/how-do-you-make-a-higher-order-function-in-python.htm"
msgstr ""
"13. Funciones de alto nivel (cómo hacer una función de alto nivel): http://"
"effbot.org/pyfaq/how-do-you-make-a-higher-order-function-in-python.htm"

#: ..\python_docs\spladdoninternals.py:852
msgid ""
"14. Time (Python documentation, Python Software Foundation): https://docs."
"python.org/2/library/time.html"
msgstr ""
"14. Time (Documentación de Python, Python Software Foundation): https://docs."
"python.org/2/library/time.html"

#: ..\python_docs\spladdoninternals.py:853
msgid ""
"15. GetTimeFormat (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/dd318130(v=vs.85).aspx"
msgstr ""
"15. Referencia de GetTimeFormat (kernel32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/dd318130(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:854
msgid "16. Event loop (Wikipedia): https://en.wikipedia.org/wiki/Event_loop"
msgstr ""
"16. Bucle de eventos (Wikipedia): https://en.wikipedia.org/wiki/Event_loop"

#: ..\python_docs\spladdoninternals.py:855
msgid ""
"17. Event-driven programming (Wikipedia): https://en.wikipedia.org/wiki/"
"Event-driven_programming"
msgstr ""
"17. Programación dirigida por eventos (Wikipedia): https://en.wikipedia.org/"
"wiki/Event-driven_programming"

#: ..\python_docs\spladdoninternals.py:856
msgid ""
"18. Sinclair, Rob. Microsoft Active Accessibility architecture, Microsoft "
"Developer Network, August 2000. https://msdn.microsoft.com/en-us/library/"
"ms971310.aspx"
msgstr ""
"18. Sinclair, Rob. Arquitectura de Microsoft Active Accessibility, Microsoft "
"Developer Network, Agosto del 2000. https://msdn.microsoft.com/en-us/library/"
"ms971310.aspx"

#: ..\python_docs\spladdoninternals.py:857
msgid ""
"19. UI Automation Overview, Microsoft Developer Network. https://msdn."
"microsoft.com/en-us/library/ms747327(v=vs.110).aspx"
msgstr ""
"19. Descripción de UI Automation, Microsoft Developer Network. https://msdn."
"microsoft.com/en-us/library/ms747327(v=vs.110).aspx"

#: ..\python_docs\spladdoninternals.py:858
msgid ""
"20. Java Access Bridge overview, Java SE Desktop Accessibility, Oracle. "
"http://www.oracle.com/technetwork/articles/javase/index-jsp-136191.html"
msgstr ""
"20. Descripción de Java Access Bridge, Java SE Desktop Accessibility, "
"Oracle. http://www.oracle.com/technetwork/articles/javase/index-jsp-136191."
"html"

#: ..\python_docs\spladdoninternals.py:859
msgid ""
"21. Introduction to OOP (Object-Oriented Programming) with Python, "
"Voidspace. http://www.voidspace.org.uk/python/articles/OOP.shtml"
msgstr ""
"21. Introducción a la POO (programación orientada a objetos) con Python, "
"Voidspace. http://www.voidspace.org.uk/python/articles/OOP.shtml"

#: ..\python_docs\spladdoninternals.py:860
msgid ""
"22. Non-Programmer's Tutorial for Python 3/Intro to Object Oriented "
"Programming in Python 3 - Wikibooks. https://en.wikibooks.org/wiki/Non-"
"Programmer%27s_Tutorial_for_Python_3/"
"Intro_to_Object_Oriented_Programming_in_Python_3"
msgstr ""
"22. Tutorial de no programadores para Python 3/Introducción a la "
"programación orientada a objetos en Python 3 - Wikibooks. https://en."
"wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_3/"
"Intro_to_Object_Oriented_Programming_in_Python_3"

#: ..\python_docs\spladdoninternals.py:861
msgid ""
"23. Method Resolution Order, The History of Python, june 23, 2010. http://"
"python-history.blogspot.com/2010/06/method-resolution-order.html"
msgstr ""
"23. Orden de resolución de métodos, la historia de Python, 23 de junio de "
"2010. http://python-history.blogspot.com/2010/06/method-resolution-order.html"

#: ..\python_docs\spladdoninternals.py:862
msgid ""
"24. List View, Microsoft Developer Network: https://msdn.microsoft.com/en-us/"
"library/windows/desktop/bb774737(v=vs.85).aspx"
msgstr ""
"24. Vista de lista, Microsoft Developer Network: https://msdn.microsoft.com/"
"en-us/library/windows/desktop/bb774737(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:863
msgid ""
"25. List View Messages, Microsoft Developer Network: https://msdn.microsoft."
"com/en-us/library/windows/desktop/ff485961(v=vs.85).aspx"
msgstr ""
"25. Mensajes de vista de lista, Microsoft Developer Network: https://msdn."
"microsoft.com/en-us/library/windows/desktop/ff485961(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:864
msgid ""
"26. List View Item structure, Microsoft Developer Network: https://msdn."
"microsoft.com/en-us/library/windows/desktop/bb774760(v=vs.85).aspx"
msgstr ""
"26. Estructura de un elemento de una vista de lista, Microsoft Developer "
"Network: https://msdn.microsoft.com/en-us/library/windows/desktop/"
"bb774760(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:865
msgid ""
"27. VirtualAllocEx (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/aa366890(v=vs.85).aspx"
msgstr ""
"27. Referencia de VirtualAllocEx (kernel32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/aa366890(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:866
msgid ""
"28. VirtualFreeEx (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/aa366894(v=vs.85).aspx"
msgstr ""
"28. Referencia de VirtualFreeEx (kernel32.dll) (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/aa366894(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:867
msgid ""
"29. WriteProcessMemory (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms681674(v=vs.85).aspx"
msgstr ""
"29. Referencia de WriteProcessMemory (kernel32.dll) (Windows API): https://"
"msdn.microsoft.com/en-us/library/windows/desktop/ms681674(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:868
msgid ""
"30. ReadProcessMemory (kernel32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx"
msgstr ""
"30. Referencia de ReadProcessMemory (kernel32.dll) (Windows API): https://"
"msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx"

#: ..\python_docs\spladdoninternals.py:869
msgid ""
"31. Ctypes (Python documentation, Python Software Foundation): https://docs."
"python.org/2/library/ctypes.html"
msgstr ""
"31. Ctypes (Documentación de Python, Python Software Foundation): https://"
"docs.python.org/2/library/ctypes.html"

#: ..\python_docs\spladdoninternals.py:870
msgid ""
"32. Thread (Wikipedia): https://en.wikipedia.org/wiki/Thread_(computing)"
msgstr ""
"32. Thread (Wikipedia): https://en.wikipedia.org/wiki/Thread_(computing)"

#: ..\python_docs\spladdoninternals.py:871
msgid ""
"33. Multi-core processor (wikipedia): https://en.wikipedia.org/wiki/Multi-"
"core_processor"
msgstr ""
"33. Procesadores de múltiples núcleos (wikipedia): https://en.wikipedia.org/"
"wiki/Multi-core_processor"

#: ..\python_docs\spladdoninternals.py:872
msgid ""
"34. Multi-core introduction, Intel Developer Zone, March 5, 2012: https://"
"software.intel.com/en-us/articles/multi-core-introduction"
msgstr ""
"34. Introducción al multinúcleo, zona de desarrolladores de Intel, 5 de "
"marzo de 2012: https://software.intel.com/en-us/articles/multi-core-"
"introduction"

#: ..\python_docs\spladdoninternals.py:873
msgid ""
"35. Intel Core I7-5960X specifications (Intel ARK): http://ark.intel.com/"
"products/82930/Intel-Core-i7-5960X-Processor-Extreme-Edition-20M-Cache-up-"
"to-3_50-GHz"
msgstr ""
"35. Especificaciones de Intel Core I7-5960X (Intel ARK): http://ark.intel."
"com/products/82930/Intel-Core-i7-5960X-Processor-Extreme-Edition-20M-Cache-"
"up-to-3_50-GHz"

#: ..\python_docs\spladdoninternals.py:874
msgid ""
"36. Intel Xeon E7-8895V3 specifications (Intel ARK): http://ark.intel.com/"
"products/84689/Intel-Xeon-Processor-E7-8895-v3-45M-Cache-2_60-GHz"
msgstr ""
"36. Especificaciones de Intel Xeon E7-8895V3 (Intel ARK): http://ark.intel."
"com/products/84689/Intel-Xeon-Processor-E7-8895-v3-45M-Cache-2_60-GHz"

#: ..\python_docs\spladdoninternals.py:875
msgid ""
"37. Global Interpreter Lock (Python Wiki): https://wiki.python.org/moin/"
"GlobalInterpreterLock"
msgstr ""
"37. Global Interpreter Lock (Python Wiki): https://wiki.python.org/moin/"
"GlobalInterpreterLock"

#: ..\python_docs\spladdoninternals.py:876
msgid ""
"38. Threading (Python documentation, Python Software Foundation): https://"
"docs.python.org/2/library/threading.html"
msgstr ""
"38. Threading (Documentación de Python, Python Software Foundation): https://"
"docs.python.org/2/library/threading.html"

#: ..\python_docs\spladdoninternals.py:877
msgid ""
"39. Multiprocessing (Python documentation, Python Software Foundation): "
"https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing"
msgstr ""
"39. Multiprocessing (Documentación de Python, Python Software Foundation): "
"https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing"

#: ..\python_docs\spladdoninternals.py:878
msgid ""
"40. Comma-separated values (Wikipedia): https://en.wikipedia.org/wiki/Comma-"
"separated_values"
msgstr ""
"40. Valores separados por coma (Wikipedia): https://en.wikipedia.org/wiki/"
"Comma-separated_values"

#: ..\python_docs\spladdoninternals.py:879
msgid ""
"41. RFC 4180 (Common Format and MIME Type for Comma-Separated Values (CSV) "
"Files), Internet Engineering Task Force: https://tools.ietf.org/html/rfc4180"
msgstr ""
"41. RFC 4180 (formato común y tipo MIME para archivos de valores separados "
"por coma (CSV)), Internet Engineering Task Force: https://tools.ietf.org/"
"html/rfc4180"

#: ..\python_docs\spladdoninternals.py:880
msgid ""
"42. Import or export text (.txt or .csv) files, Microsoft Office Support for "
"Microsoft Excel: https://support.office.com/en-za/article/Import-or-export-"
"text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba"
msgstr ""
"42. Importar o exportar texto (archivos .txt or .csv), soporte de Microsoft "
"Office para Microsoft Excel: https://support.office.com/en-za/article/Import-"
"or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba"

#: ..\python_docs\spladdoninternals.py:881
msgid ""
"43. CSV (Python documentation, Python Software Foundation): https://docs."
"python.org/2/library/csv.html"
msgstr ""
"43. CSV (Documentación de Python, Python Software Foundation): https://docs."
"python.org/2/library/csv.html"

#: ..\python_docs\spladdoninternals.py:882
msgid "44. Cache (Wikipedia): https://en.wikipedia.org/wiki/Cache_(computing)"
msgstr "44. Caché (Wikipedia): https://en.wikipedia.org/wiki/Cache_(computing)"

#: ..\python_docs\spladdoninternals.py:883
msgid ""
"45. Os (Python documentation, Python Software Foundation): https://docs."
"python.org/2/library/os.html"
msgstr ""
"45. Os (Documentación de Python, Python Software Foundation): https://docs."
"python.org/2/library/os.html"

#: ..\python_docs\spladdoninternals.py:884
msgid ""
"46. Configparser (Python documentation, Python Software Foundation): https://"
"docs.python.org/2/library/configparser.html"
msgstr ""
"46. Configparser (Documentación de Python, Python Software Foundation): "
"https://docs.python.org/2/library/configparser.html"

#: ..\python_docs\spladdoninternals.py:885
msgid ""
"47. ConfigObj documentation: http://www.voidspace.org.uk/python/configobj."
"html"
msgstr ""
"47. Documentación de ConfigObj: http://www.voidspace.org.uk/python/configobj."
"html"

#: ..\python_docs\spladdoninternals.py:886
msgid ""
"48. Validate module documentation: http://www.voidspace.org.uk/python/"
"validate.html"
msgstr ""
"48. Documentación del módulo Validate: http://www.voidspace.org.uk/python/"
"validate.html"

#: ..\python_docs\spladdoninternals.py:887
msgid ""
"49. Spin control (wx.SpinCtrl) documentation (WXPython): http://wxpython.org/"
"Phoenix/docs/html/SpinCtrl.html"
msgstr ""
"49. Documentación de Spin control (wx.SpinCtrl) (WXPython): http://wxpython."
"org/Phoenix/docs/html/SpinCtrl.html"

#: ..\python_docs\spladdoninternals.py:888
msgid ""
"50. SetForegroundWindow (user32.dll) reference (Windows API): https://msdn."
"microsoft.com/en-us/library/windows/desktop/ms633539(v=vs.85).aspx"
msgstr ""
"50. Referencia de SetForegroundWindow (user32.dll) (Windows API): https://"
"msdn.microsoft.com/en-us/library/windows/desktop/ms633539(v=vs.85).aspx"

#~ msgid ""
#~ "6. As described above, the app module will look for the window handle for "
#~ "the Studio app."
#~ msgstr ""
#~ "6. Como se describe arriba, el módulo de aplicación buscará el manejador "
#~ "de ventana de la aplicación Studio."

#~ msgid ""
#~ "The next LTS release is scheduled for late 2018 not only because it will "
#~ "be the last version to support Studio 5.10 (not 5.11), and also to part "
#~ "ways with Python 2, as NVDA developers are planning to switch to Python 3 "
#~ "in the near future, hence future stable releases after the next LTS will "
#~ "be based mostly on Python 3 code."
#~ msgstr ""
#~ "La próxima versión lts está prevista para finales del 2018, no sólo "
#~ "porque será la última versión que soporte Studio 5.10 (y no 5.11), sino "
#~ "porque también dejará atrás Python 2, ya que los desarrolladores de NVDA "
#~ "están planeando pasar a Python 3 en el futuro cercano, por lo que las "
#~ "futuras versiones estables después de la próxima LTS estarán basadas en "
#~ "su mayoría en código de Python 3."

#~ msgid ""
#~ "So far, we talked about how the add-on was conceived and read about its "
#~ "history. Starting with this section, we'll tour the real internals of "
#~ "this add-on, starting with overall design and a few important notes. But "
#~ "before we get into that, there are some things we need to go over such as "
#~ "programming background, user experience and a few definitions."
#~ msgstr ""
#~ "Hasta ahora, hemos hablado de cómo fue concebido este complemento y leído "
#~ "sobre su historia. Empezando con esta sección, recorreremos los "
#~ "auténticos interiores de este complemento, empezando con el diseño "
#~ "general y unas pocas notas importantes. Pero antes de que vayamos a eso, "
#~ "hay algunas cosas de las que debemos hablar, como el fondo de "
#~ "programación, la experiencia de usuario y algunas definiciones."

#~ msgid ""
#~ "Now you have a bit of an overview of the add-on, let's dive into the core "
#~ "components: SPL app module and support modules. In this section, we'll go "
#~ "through life of the SPL Studio app module: from start to finish and "
#~ "everything in between. We'll cover more specific features of the app "
#~ "module throughout this article."
#~ msgstr ""
#~ "Ahora ya tienes un poquito de la descripción del complemento, buceemos en "
#~ "sus componentes principales: el módulo de aplicación de SPL y los módulos "
#~ "de soporte. En esta sección, iremos a través de la vida del módulo de "
#~ "aplicación de SPL Studio: desde el principio hasta el final y todo lo que "
#~ "hay entre medias. Cubriremos funciones más específicas del módulo de "
#~ "aplicación a lo largo de este artículo."

#~ msgid ""
#~ "After configuring some settings, click OK. NVDA will then locate the "
#~ "selected profile and tell SPLConfig to use this profile, then store "
#~ "options from the settings dialog into the configuration map."
#~ msgstr ""
#~ "Tras configurar algunos ajustes, pulsa aceptar. NVDA ubicará entonces el "
#~ "perfil seleccionado y le dirá a SPLConfig que lo use, luego almacenará "
#~ "las opciones del diálogo de ajustes en el mapa de configuración."
